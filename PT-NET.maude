in EMATRIX
in shared/MAP-SET

*** PT net signature using the extended matrix representation including flush arcs and a description pf place capacity 
fmod PT-NET{L :: TRIV, PL :: TRIV} is
 generated-by MAP-SET{L,Ematrix{PL}} * (sort Map{L,Ematrix{PL}} to Net, sort Entry{L,Ematrix{PL}} to Tran, 
                                        op emptyM to emptyNet, op emptyS to emptySlab) .
 vars L L' : L$Elt . vars T T' : Tran . vars N N' : Net . 
 vars P P' : Place . vars M I O H C B B' : Pbag . vars K K'  : NzNat .
 var EQ : Ematrix . var Q : Tmatrix . var  S : Pset . var F : FlushArcs .
 *** accessor methods
 ops l lab : Tran -> L$Elt .
 eq lab(T) = l(T) .
 op q : Tran -> Ematrix .
 eq l(L |-> EQ) = L .
 eq q(L |-> EQ) = EQ .
 op m : Tran -> Tmatrix .
 eq m(T) = m(q(T)) . *** the associated Tmatrix
 op f : Tran -> FlushArcs .
 eq f(T) = f(q(T)) . *** the associated flushing arcs (is any)
 ops I O H : Tran -> Pbag .
 eq I(T) = I(m(T)) .
 eq O(T) = O(m(T)) .
 eq H(T) = H(m(T)) .
 eq L |-> [nilP, nilP] = emptyNet . *** removes isolated transitions
 *** eq L |-> [M,M,H] = emptyNet [metadata "null t"] . *** removes transitions not changing the marking

 op dead : Tran -> Bool .  *** checks for structurally dead transitions 
 eq dead(L |-> EQ) = dead(m(EQ)) .
ceq L |-> EQ = emptyNet if dead(m(EQ)) . *** removes dead transitions
 *** doesn't consider the capacity
 op enabled : Tran Pbag -> Bool .
 eq enabled(T, M) =  hasConcession(T, M) .
 op hasConcession : Tran Pbag -> Bool .
 eq hasConcession(L |-> EQ, M) = enabled(EQ, M) .
 op enabNet : Net Pbag -> Net . *** the enabled set seen as a net
 eq enabNet(emptyNet, M) = emptyNet .
 eq enabNet(T ; N, M) = enabNet(N, M) ; if hasConcession(T, M) then T else emptyNet fi .   *** riscrivere usando tail rec

 *** doesn't consider enabling and capacity, but considers flush arcs
 op firing : Tran Pbag -> Pbag .
 eq firing(L |-> EQ, M) = firing(EQ, M) . 
 *** test the existence of a transition
 op in :  Net L$Elt -> Bool . 
 eq in(N, L) = $hasMapping(N, L) .
*** check the existence of a place of given type
 ops isIn isOut isH : Net Place -> Bool . 
ceq isIn(L |-> EQ ; N, P) = true if isIn(EQ, P) .
 eq isIn(N, P) = false [owise] .
ceq isOut(L |-> EQ ; N, P) = true if isOut(EQ, P) .
 eq isOut(N, P) = false [owise] .
ceq isH(L |-> EQ ; N, P) = true if isH(m(EQ), P) .
 eq isH(N, P) = false [owise] .
 *** returns the places (of course, the capacity bag is not considered)
 op netPlaces : Net -> Pset [memo] . 
 eq netPlaces(N) = $netPlaces(N, emptyPset) .  
 op $netPlaces : Net Pset -> Pset . 
 eq $netPlaces(emptyNet, S) = S . 
 eq $netPlaces(T ; N, S) = $netPlaces(N, S U placesTran(T)) .
 op placesTran : Tran -> Pset .
 eq placesTran(L |-> EQ) = places(EQ) . 
 ***
 op transitions : Net -> Set{L} .
 eq transitions(N) = keySet(N) .
 ***
 op detache : Net Net -> Net .
 eq detache(N ; N', N') = N .
 eq detache(N, N') = N [owise] .  

endfm