in ../PBAG
*** MQN signature

*** single-server
fmod SERVER{PL :: TRIV} is
  protecting PLACE{PL} .
  protecting FLOAT .
  sort Server .
  op _@_ : Place Float -> Server [prec 19 ctor] . *** a single-server is described by a place and a service rate
  op mu : Server -> Float .
  op p : Server -> Place .
  var P : Place . var F : Float .
  eq mu(P @ F)  = F .
  eq p(P @ F) = P .
endfm


*** default view to SERVER
view Server{PL :: TRIV} from TRIV to SERVER{PL} is
   sort Elt to Server .
endv

fmod SERVER-LIST{PL :: TRIV} is 
   protecting LIST{Server{PL}} * (sort List{Server{PL}} to ServerList, sort NeList{Server{PL}} to NeServerList,
                                  op nil to nilSeL) .
endfm 

*** multi-class queues built over elementary servers 
fmod QUEUE{PL :: TRIV} is 
  protecting SERVER-LIST{PL} .
  protecting PBAG{PL} .
  sorts Queue SimpleQ ElQueue .
  subsort ElQueue < SimpleQ < Queue .
  vars Q Q' : Server . var SQ : SimpleQ . var Qu : Queue .
  vars LQ LQ' LQ'' : ServerList . var NeLQ : NeServerList .
  vars M M' M'' : Pbag . var P : Place .
  op _>_ : NeServerList Place -> SimpleQ [ctor] .
  op _>_ : Server Place -> ElQueue [ctor ditto] . *** an elementary queue
  op [_,_] _  : Pbag Pbag SimpleQ -> Queue [ctor] . *** queue with prefixed enabling conditions
  eq [nilP, nilP] SQ = SQ .  
  op ql : Queue -> NeServerList . *** the enclosed list of elementary queues
  eq ql(LQ > P) = LQ .
  eq ql([M, M'] SQ) = ql(SQ) .
  op out : Queue -> Place .
  eq out(LQ > P) = P .
  eq out([M, M'] SQ) = out(SQ) .
  op well-def : NeServerList -> Bool .
  op pin : Queue -> Place .
  eq pin(Q LQ > P) = p(Q) .
  eq pin([M, M'] SQ ) = pin(SQ) .
 ceq well-def(LQ Q LQ' Q' LQ'') = false if p(Q) = p(Q') .
  eq well-def(Q LQ) = true [owise] . 
  op clients : ServerList Pbag -> [Nat] [memo] .
 ceq clients(Q LQ, M) = M[p(Q)] + clients(LQ, M) if well-def(Q LQ) .
  eq clients(nilSeL, M) = 0 .
  op clients : Queue Pbag -> [Nat] .
  eq clients(Qu, M) = clients(ql(Qu), M) . 
  op qenabled : Queue Pbag -> Bool . *** the queue "enabling" condition
  eq qenabled(SQ, M) = true .
  eq qenabled([M, M'] SQ, M'') = enabCond(M, M', M'')  . *** similar to the PN tran. enabling condition (M input, M' inhibitor)
  *** return the place of the next element if any, otherwise the specified default place (convenience op)
  op nextPosDef : ServerList Place -> Place [memo] .  
  eq nextPosDef(LQ , P) = if LQ  == nilSeL then P else p(head(LQ )) fi .
endfm