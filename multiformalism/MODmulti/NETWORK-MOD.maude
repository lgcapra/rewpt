*** multiformalism "modular" representation exploiting symmetries
in ../NETWORK
in ../../modPT/MONOID-MOD
in ../../modPT/PLAB

*** network using a marking as distributed state, with structured place labels
fmod NETWORK-MOD is
  pr PBAG-MOD .
  pr PSET-MOD .
  *** protecting NETWORK-MARKING{Plab} .
  protecting NETWORK{S-Pbag{Plab}} .
  *** abstract operations: we use the same names as in the theory
  op replaceWithEl : Node NeLab Nat -> Node . *** defined for a single element
  op addLabEl : Node Lab Pset -> Node . 
  op placesEl : Node -> Pset .
  op placesEl : Node NeList{String} -> Pset .
  op inEl : Node Place -> Bool .
endfm


*** view of a network of nodes as a monoid (with associated ops)
view NETWORK-MOD from MO-NET-SYS to NETWORK-MOD is
  sort Elt to Network .
  sort El to Node .
  sort SysNode to NetSys .
  op nil to emptyNetW  .
  op _;_ to _,_ .
endv

fmod NETWORK-MOD-SYS is
 pr MO-NET-SYS-OP{NETWORK-MOD}  .
endfm

in ../../modSPT/SPN-SYS-MOD
in ../../modSPT/SPN-EMU-MOD

*** renaming to avoid multiple definitions

fmod SPN-NODE-MOD{L :: TRIV} is
  extending NETWORK-MOD-SYS .
  inc SPN-SIG-MOD{L} * (op setMark to setMarkSPN, 
                      op replaceWith to replaceWithSPN, 
                      *** op replaceWith to replaceWithEl, 
                      op $replaceWith to $replaceWithSPN,
                      op addLab to addLabSPN, op $addLab to $addLabSPN, op places to placesSPN, op $places to $placesSPN,
                      op abstract to abstractSPN, op abstractBut to abstractButSPN,  op repl&share to  repl&shareSPN,
                      op $repl&share to  $repl&shareSPN, op replica to replicaSPN, op in to inSPN, op exists to existsSPN
                      ) .
  subsort Net < Node .
  eq replaceWithEl(N:Net,L:NeLab, I:Nat) = replaceWithSPN(N:Net,L:NeLab, I:Nat) . 
endfm

 mod SPN-NODE-EMU-MOD{L :: TRIV} is
  extending NETWORK-MOD-SYS .
  inc SPN-EMU-MOD{L} * (op setMark to setMarkSPN, 
                      op replaceWith to replaceWithSPN, 
                      *** op replaceWith to replaceWithEl, 
                      op $replaceWith to $replaceWithSPN,
                      op addLab to addLabSPN, op $addLab to $addLabSPN, op places to placesSPN, op $places to $placesSPN,
                      op abstract to abstractSPN, op abstractBut to abstractButSPN, op repl&share to  repl&shareSPN,
                      op $repl&share to $repl&shareSPN, op replica to replicaSPN, op in to inSPN, op exists to existsSPN
                      ) .
  subsort System < Node .
  eq replaceWithEl(S:System, L:NeLab, I:Nat) = replaceWithSPN(S:System, L:NeLab, I:Nat) . 
endm


in ../QUEUE

*** se volessimo definire le stesse cose come "monoidi", cosÃ¬ come fatto con le SPN
*** si dovrebbe definire una coda come una lista di code elementari
*** oppure si potrebbe definire, internamente ad una coda, la lista di server come monoide

fmod QUEUE-MOD is
   pr QUEUE{Plab} .
   op replaceWithQueue : Queue NeLab Nat -> Queue . *** to define
  *** (anche gli altri?)
endfm

fmod QUEUE-NODE-MOD is
   extending NETWORK-MOD-SYS .
   pr QUEUE-MOD .
   subsort Queue < Node .
   eq replaceWithEl(Q:Queue,L:NeLab, I:Nat) = replaceWithQueue(Q:Queue,L:NeLab, I:Nat) . 
endfm

 mod NETWORK-EXE is
   inc QUEUE-NODE-MOD .
   *** inc SPN-NODE-MOD{String} .
   inc SPN-NODE-EMU-MOD{String} . *** the node is a marked SPN
endm

 *** just make some trials
 mod FIRST-EXE is
   inc NETWORK-EXE .
   ops loadLab assLab failLab workLab : -> Tlab [memo] .
   eq loadLab = t("ld", 0.5,   1 ) .
   eq assLab =  t("as", 2.0,   0 ) .
   eq workLab = t("ln", 0.1,   1 ) .
   eq failLab = t("ft", 0.001, 1 ) .
   ops line load ass  : -> Tran . 
   op cycle  : -> Net [memo] .
   eq line =  workLab  |-> [1 . p(< "w" ; 0 >) , 1 . p(< "a" ; 1 >), 1 . p(< "f" ; 0 >) ].
   eq load  = loadLab  |-> [1 . p(< "s" ; 0 >) , 1 . p(< "w" ; 0 >) , nilP ] .
   eq ass   = assLab  |-> [1 . p(< "a" ; 1 >) , 1 . p(< "s" ; 0 >)  , nilP ] .
   eq cycle = load ; line ; ass .
   op PL : NzNat -> Net . 
   op NPL  : NzNat NzNat -> Net [memo]. *** N (faulty) prod lines 0 .. N- 1 each of K lines
   op NPLsys : NzNat NzNat NzNat -> System . 
   vars N K M : NzNat .

   eq PL(K) = repl&shareSPN(cycle, K, "L", p (< "o" ; 0 >) U p(< "s" ; 0 >)) . *** a PL is built of K symmetric lines 
   eq NPL(N, K) = repl&shareSPN(PL(K), N, "PL", p(< "s" ; 0 >)) . *** change here to vary the lines of a PL
   eq NPLsys(N, K, M) = setMarkSPN(setMarkSPN(NPL(N, K), "o" "PL", 1), "s", K * M) .
 
endm

