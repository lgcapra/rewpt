in ../QUEUE
in ../../modPT/MO-NET-OP

fmod SERVER-LIST-LAB is 
   protecting SERVER-LIST{Plab} .
   protecting PSET-MOD .
   vars P P' : Place . var F : Float .  var J  : Nat . var S : Pset .
   var L : Lab . var NeL : NeLab . var WL : List{String} . 
   op replaceWithServer : Server NeLab Nat -> Server .
   eq replaceWithServer(P @ F, NeL, J) = replaceWithP(P, NeL, J) @ F .
   op addLabServer : Server Lab Pset -> Server . 
   eq addLabServer(P @ F, L, S) = addLabP(P, L, S) @ F .
   op placesServer : Server List{String} -> Pset .
   eq placesServer(P @ F, WL) = placesP(P, WL) .
   op placesServer : Server NeLab -> Pset .
   eq placesServer(P @ F, NeL) = placesP(P, NeL) .
   op placesServer : Server -> Pset .
   eq placesServer(P @ F) = P .
endfm 

view SERVER-LIST-LAB from MO-NET to SERVER-LIST-LAB is
  sort Elt to ServerList .
  sort El to Server .
  op nil to nilSeL  .
  op _;_ to __ .
  op replaceWithEl to replaceWithServer . 
  op addLabEl to addLabServer .
  op placesEl to placesServer .
endv

*** SERVER-LIST with structured label wrapped as a modular monoid with suitable compositional and normalization operators
fmod SERVER-LIST-MOD is
 pr MO-NET-OP{SERVER-LIST-LAB} .
endfm

*** multi-class queues built over elementary servers 
fmod QUEUE-MOD is 
  protecting SERVER-LIST-MOD .
  protecting PBAG-MOD .
  sorts Queue SimpleQ ElQueue .
  subsort ElQueue < SimpleQ < Queue .
  vars Q Q' : Server .
  var SQ : SimpleQ .
  var Qu : Queue .
  vars LS LS' LS'' : ServerList . 
  var NeLS : NeServerList .
  vars M M' M'' : Pbag . 
  vars P P' : Place .
  op _>_ : NeServerList Place -> SimpleQ [ctor] .
  op _>_ : Server Place -> ElQueue [ctor ditto] . *** an elementary queue
  op [_,_] _  : Pbag Pbag SimpleQ -> Queue [ctor] . *** queue with prefixed enabling conditions
  eq [nilP, nilP] SQ = SQ .  
  op ql : Queue -> NeServerList . *** the enclosed list of elementary queues
  eq ql(LS > P) = LS .
  eq ql([M, M'] SQ) = ql(SQ) .
  op out : Queue -> Place .
  eq out(LS > P) = P .
  eq out([M, M'] SQ) = out(SQ) .
  op well-def : NeServerList -> Bool .
  op in : Queue -> Place .
  eq in(Q LS > P) = p(Q) .
  eq in([M, M'] SQ ) = in(SQ) .
 ceq well-def(LS Q LS' Q' LS'') = false if p(Q) = p(Q') .
  eq well-def(Q LS) = true [owise] . 
  op clients : ServerList Pbag -> [Nat] [memo] .
 ceq clients(Q LS, M) = M[p(Q)] + clients(LS, M) if well-def(Q LS) .
  eq clients(nilSeL, M) = 0 .
  op clients : Queue Pbag -> [Nat] .
  eq clients(Qu, M) = clients(ql(Qu), M) . 
  op qenabled : Queue Pbag -> Bool . *** the queue "enabling" condition
  eq qenabled(SQ, M) = true .
  eq qenabled([M, M'] SQ, M'') = enabCond(M, M', M'')  . *** similar to the PN tran. enabling condition (M input, M' inhibitor)
  op cap : ElQueue -> NzNat .
  eq cap(X:ElQueue) = cap(in(X:ElQueue)) .
  *** return the place of the next element if any, otherwise the specified default place (convenience op)
   op nextPosDef : ServerList Place -> Place [memo] .  
   eq nextPosDef(LS , P) = if LS  == nilSeL then P else p(head(LS )) fi .
   
   *** "modular" ops
   var J  : Nat . var S : Pset . var L : Lab . var NeL : NeLab . var WL : List{String} .  
   op replaceWithQueue : Queue NeLab Nat -> Queue . 
   eq replaceWithQueue(NeLS > P, NeL, J) = replaceWith(NeLS, NeL, J) >  replaceWithP(P, NeL, J) . 
   op addLabQueue : Queue Lab Pset -> Queue . 
   eq addLabQueue(NeLS > P, L, S) = addLab(NeLS, L, S) > addLabP(P, L, S)   .
   op placesQueue : Queue List{String} -> Pset .
   eq placesQueue(NeLS > P, WL) = places(NeLS, WL) U placesP(P, WL) .
   op placesQueue : Queue NeLab -> Pset .
   eq placesQueue(NeLS > P, NeL) = places(NeLS, NeL) U placesP(P, NeL) .
   op placesQueue : Queue  -> Pset .
   eq placesQueue(NeLS > P) = places(NeLS) U P .

endfm