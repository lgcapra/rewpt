*** multiformalism "modular" representation exploiting symmetries
in ../NETWORK
in ../../modPT/MONOID-MOD
in ../../modPT/PLAB

*** network using a marking as distributed state, with structured place labels
fmod NETWORK-MOD is
  pr PBAG-MOD .
  pr PSET-MOD .
  protecting NETWORK{S-Pbag{Plab}} .
  *** abstract operations: we use the same names as in the theory
  op replaceWithEl : Node NeLab Nat -> Node . *** defined for a single element
  op addLabEl : Node Lab Pset -> Node . 
  op placesEl : Node NeList{String} -> Pset .
  op inEl : Node Place -> Bool .
endfm


*** view of a network of nodes as a monoid (with associated ops)
view NETWORK-MOD from MO-NET-SYS to NETWORK-MOD is
  sort Elt to Network .
  sort El to Node .
  sort SysNode to NetSys .
  op nil to emptyNetW  .
  op _;_ to _,_ .
endv

*** wraps a NETWORK into a MONOID with modular ops
fmod NETWORK-MOD-SYS is
 pr MO-NET-SYS-OP{NETWORK-MOD}  .
endfm

in ../../modSPT/SPN-SYS-MOD
in ../../modSPT/SPN-EMU-MOD

*** renaming necessary to avoid multiple definitions
fmod SPN-NODE-MOD{L :: TRIV} is
  extending NETWORK-MOD-SYS .
  inc SPN-SIG-MOD{L} * ( 
                       op replaceWith to replaceWithEl, op $replaceWith to $replaceWithEl, op in to inEl,
                       op addLab to addLabEl, op $addLab to $addLabEl, op places to placesEl, op $places to $placesEl,
                       op abstract to abstractEl, op abstractBut to abstractButEl,
                       op repl&share to  repl&shareEl, op $repl&share to  $repl&shareEl, op replica to replicaEl,
                       op normalize to normalizeEl, op normalizeBut to normalizeButEl
                      ) .
  subsort Net < Node .
endfm

in ../QUEUE

*** se volessimo definire le stesse cose come "monoidi", cosÃ¬ come fatto con le SPN
*** si dovrebbe definire una coda come una lista di code elementari
*** oppure si potrebbe definire, internamente ad una coda, la lista di server come monoide

fmod QUEUE-MOD is
   pr QUEUE{Plab} .
   *** to define
   op replaceWithEl : Queue NeLab Nat -> Queue . 
   op addLabEl : Queue Lab Pset -> Queue . 
   op placesEl : Queue List{String} -> Pset .
   op inEl : Queue Place -> Bool .
endfm

fmod QUEUE-NODE-MOD is
   extending NETWORK-MOD-SYS .
   pr QUEUE-MOD .
   subsort Queue < Node .
endfm

 mod NETWORK-EXE is
   inc QUEUE-NODE-MOD .
   inc SPN-NODE-MOD{String} .
endm

 *** just make some trials
 mod FIRST-EXE is
   inc NETWORK-EXE .
   ops loadLab assLab failLab workLab : -> Tlab [memo] .
   eq loadLab = t("ld", 0.5,   1 ) .
   eq assLab =  t("as", 2.0,   0 ) .
   eq workLab = t("ln", 0.1,   1 ) .
   eq failLab = t("ft", 0.001, 1 ) .
   ops line load ass  : -> Tran . 
   op cycle  : -> Net [memo] .
   eq line =  workLab  |-> [1 . p(< "w" ; 0 >) , 1 . p(< "a" ; 1 >), 1 . p(< "f" ; 0 >) ].
   eq load  = loadLab  |-> [1 . p(< "s" ; 0 >) , 1 . p(< "w" ; 0 >) , nilP ] .
   eq ass   = assLab  |-> [1 . p(< "a" ; 1 >) , 1 . p(< "s" ; 0 >)  , nilP ] .
   eq cycle = load ; line ; ass .
   op PL : NzNat -> Net . 
   op NPL  : NzNat NzNat -> Net [memo]. *** N (faulty) prod lines 0 .. N- 1 each of K lines
   op NPLsys : NzNat NzNat NzNat -> NetSys . 
   vars N K M : NzNat .

   eq PL(K) = repl&shareEl(cycle, K, "L", p (< "o" ; 0 >) U p(< "s" ; 0 >)) . *** a PL is built of K symmetric lines 
   eq NPL(N, K) = repl&shareEl(PL(K), N, "PL", p(< "s" ; 0 >)) . *** change here to vary the lines of a PL
   eq NPLsys(N, K, M) = setMark(setMark(NPL(N, K), "o" "PL", 1), "s", K * M) . *** si dovrebbe fare sull'intero network
 
endm

