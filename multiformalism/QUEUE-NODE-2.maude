in QUEUE
in NETWORK-2

*** MQN nodes of a network -- solution 2
fmod QUEUE-NODE{PL :: TRIV} is
   pr QUEUE{PL} .
   pr MSET-MARKING-RATE{PL} .
   pr CONVERSION .
   var S  : Server . var Q : Queue . var LS  : List{Server} . 
   var K : Nat . var rate : Float . var M : Pbag .
   var MS : StatesRates . vars P P' : Place .
   *** return the place of the next element if any, otherwise the specified default place (convenience op)
   op nextPorDef : List{Server} Place -> Place [memo] .  
   eq nextPorDef(LS, P) = if LS == nilElQ then P else p(head(LS)) fi .
   op qnext  : Queue Pbag -> StatesRates . *** non deterministic firing (see the corresponding rule)
  ceq qnext(Q, M) = $qnext(ql(Q), noStateRate, out(Q), K, M) if K := clients(ql(Q), M) /\ K > 0 /\ qenabled(Q, M) .
   eq qnext(Q, M) = noStateRate [owise]. 
   op $qnext : List{Server} StatesRates Place NzNat Pbag -> StatesRates .
   eq $qnext(nilElQ, MS, P, K, M) = MS .
  ceq $qnext(S LS, MS, P, K, M) = $qnext(LS, MS, P, K, M) if mu(S) == 0.0 or-else M[p(S)] == 0 or-else M[nextPorDef(LS, P)] >= cap(nextPorDef(LS, P)) . *** takes cap into accout
  ceq $qnext(S LS, MS, P, K, M) = $qnext(LS, MS < M  + 1 . nextPorDef(LS, P) - 1 . p(S) ; rate >, P, K, M) 
         if rate := mu(S) * float(M[p(S)]) / float(K) [owise] .  
endfm

view QueueNode{PL :: TRIV} from NODE to QUEUE-NODE{PL} is
   sort Node to Queue . 
   sort State to Pbag .
   op next to qnext .
endv 
