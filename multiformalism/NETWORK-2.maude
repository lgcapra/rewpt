in NETWORK
in ../shared/MSET
in ../shared/PAIR

*** we adopt the convention that a theory name cannot contain '-'
*** PER ORA USATA SOLO PER MODULARITA
fth STATERATE is
  pr FLOAT .
  inc STATE .
  sort StateRate . *** pair (state,rate)
  sort StatesRates . *** multiset of (state,rate)
  subsort StateRate < StatesRates .
  *** getters expressing that StateRate is a pair
  op state : StateRate -> State .
  op rate  : StateRate -> Float .
  op noStateRate : -> StatesRates .
  op __ : StatesRates StatesRates -> StatesRates [assoc comm id: noStateRate] .
endfth

*** theory of nodes of a stochastic network
fth NODE is
  inc STATERATE . *** includes another theory 
  sort Node . *** network node
  op next : Node State -> StatesRates . *** encoding the (non-deterministic) firing rule as operator
endfth

*** signature of a generic network
fmod NETWORK-SIG is
   sorts Network State NetSys .
   op emptyNetW : -> Network [ctor] .
   op _,_ : Network Network -> Network [ctor assoc comm prec 123 id: emptyNetW] .
   op _:_ : Network State -> NetSys [ctor prec 125] . *** network with associated state (lowest priority)
   op netw  : NetSys -> Network .
   op state : NetSys -> State .
   vars N N'  : Network . 
   var M : State .
   eq netw((N : M))  = N .
   eq state((N : M)) = M .
   op remove : Network Network -> Network .
   eq remove((N, N'), N) = N' .
   eq remove(N, N') = N [owise] .
   op in : Network Network -> Bool .
   eq in((N, N'), N) = true .
   eq in(N, N') = false [owise] .
endfm

fmod NETWORK-NODE{N :: NODE} is
  pr NETWORK-SIG .
  sorts Network{N} NetSys{N} .
  subsort N$Node < Network{N} < Network .
  subsort N$State < State .
  subsort NetSys{N}  < NetSys .
  op _,_ : Network{N} Network{N} -> Network{N} [ctor ditto] . *** convenience overloading
  op _:_ : Network{N} N$State -> NetSys{N} [ctor ditto] . 
endfm 

mod NETWORK-SYS{N :: NODE} is
  inc NETWORK-NODE{N} .
  var N : N$Node .
  vars M M' : N$State .
  var SR  : N$StateRate .
  var SRs : N$StatesRates .
  var NW : Network .
  var R : Float .
  crl [firing-rule] : (N, NW) : M => (N, NW) : M' if SR SRs := next(N, M) /\ M' := state(SR) /\ R := rate(SR) . 
endm


*** concrete definition of a pair state-rate
fmod STATE-RATE{S :: STATE} is
  pr FLOAT .
  sort StateRate .
  op _--_ : S$State Float -> StateRate .
  op state : StateRate -> S$State .
  op rate  : StateRate -> Float .
  var S : S$State . var R : Float .
  eq state(S -- R) = S .
  eq rate(S -- R) = R .
endfm

view StateRate{S :: STATE} from TRIV to STATE-RATE{S} is
  sort Elt to StateRate .
endv

*** multiset of pairs (S:State, Float)
fmod MSET-STATE-RATE{S :: STATE} is
   pr MSET{StateRate{S}} * (sort Mset{StateRate{S}} to StatesRates, sort NeMset{StateRate{S}} to NeStatesRates,                  
                            op empty{StateRate{S}} to noStateRate) .
endfm

*** multiset of pairs (Pbag, Float)
fmod MSET-MARKING-RATE{PL :: TRIV} is
   pr MSET-STATE-RATE{S-Pbag{PL}} .
endfm
