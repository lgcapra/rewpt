in SPN-STATE-TRAN

fmod SPN-MC-EXE is
 pr SPN-EXE .
 pr MATCH-CLASS{Net} .
 pr MATCH-CLASS{System} .
 pr MATCH-CLASS{Pbag} .
 pr MATCH-CLASS{Tlab} .
 pr MATCH-CLASS{Tmatrix} .
 pr SPN-STATE-TRAN .
 var P : Place .
 vars T T' : Tran .
 vars B  B' M  M' : Pbag  .
 vars N N' N'' : Net .
 vars S S' : System .
 vars R r r' : Float .
 vars L L' : Tlab .
 var Q : Tmatrix .
 var W : String .
 var E : Nat .
 var X : Set{StateTran{System}} .
 var Z : Set{StateTran{Net}} .
 var Y : Set{StateTran{Pbag}} .
 
  var XM : Matches .
  *** encoding of rule matches: STESSA struttura per ogni regola
  *** op firing-matches : System -> Set{StateTran{System}}  .
  *** eq firing-matches(S) = $firing-matches(S, noStateTranS) .
  *** op $firing-matches : System Set{StateTran{System}} -> Set{StateTran{System}} .
  *** ceq $firing-matches(S, X) = $firing-matches(S,  (XM  --> S' : R)  U X) if (T ; N) M := S /\ enabled(T, M) /\ 
      ***    S' := (T ; N) firing(T, M)  /\ R := firing-rate(T, M) /\  XM := {N} & {T} & {M} /\ (XM  --> S' : R) in X = false .
  *** eq $firing-matches(S, X) = X [owise] .
  *** OTTIMIZZATO
  op firing-matches : System -> Set{StateTran{Pbag}}  .
  eq firing-matches(S) = $firing-matches(S, noStateTranM) .
  op $firing-matches : System Set{StateTran{Pbag}} -> Set{StateTran{Pbag}} .
  ceq $firing-matches(S, Y) = $firing-matches(S,  (XM  --> M' : R)  U Y) if (T ; N) M := S /\ enabled(T, M) /\ 
         M' := firing(T, M)  /\ R := firing-rate(T, M) /\  XM := {N} & {T} & {M} /\ (XM  --> M' : R) in Y = false .
  eq $firing-matches(S, Y) = Y [owise] .

  *** merge rule
  op merge-matches : System -> Set{StateTran{System}} [memo].
  eq merge-matches(S) = $merge-matches(S, noStateTranS) .
  op $merge-matches : System Set{StateTran{System}} -> Set{StateTran{System}} .
  ceq $merge-matches(S, X) = $merge-matches(S, (XM  --> S' : R)  U X)  if (N ; T ; T') M := S /\ W := tag(T) /\ W = tag(T') /\ E := pol(T) /\
        E = pol(T') /\ enabled(T, M) = enabled(T', M) /\ S' := (N ; merge(T, T', t(W, rate(T) + rate(T'), E))) M  /\ R := 0.02 /\ XM := {N} & {T , T'} & {M} /\ (XM --> S' : R) in X = false .
  eq $merge-matches(S, X) = X [owise] .
  
  *** agg rule
  op aggr-matches : System -> Set{StateTran{System}} .
  eq aggr-matches(S) = $aggr-matches(S, noStateTranS) .
  op $aggr-matches : System Set{StateTran{System}} -> Set{StateTran{System}} .
  ceq $aggr-matches(S, X) = $aggr-matches(S,  (XM  --> S' : R)  U X) if (N ; T ; T')  M := S /\ E := pol(T) /\ E = pol(T') /\ O(q(T)) = I(q(T')) /\ enabled(T', M) = false /\ 
       r := rate(T) /\ r' := rate(T')  /\ S' := (N ; aggr(T, T', t(tag(T) + "-" + tag(T'), r * r' / (r + r'), E))) M   /\ R := 0.05 /\ XM := {N} & {T , T'} & {M} /\ (XM  --> S' : R) in X = false . 
  eq $aggr-matches(S, X) = X [owise] .
  
  *** fold rule (Net portion)
  op fold-matches : Net -> Set{StateTran{Net}} [memo].
  eq fold-matches(N) = $fold-matches(N, noStateTranN) .
  op $fold-matches : Net Set{StateTran{Net}} -> Set{StateTran{Net}} .
  ceq $fold-matches(N, Z) = $fold-matches(N, (XM  --> N' : R)  U Z)  if N'' ; L |-> Q ; L' |-> Q := N  /\ E := pol(L) /\
         E = pol(L') /\ N' := N'' ; t("fold" ,  rate(L) + rate(L'), E) |-> Q  /\ R := 0.02 /\ XM := {N''} & {L , L'} & {Q} /\ (XM  --> N' : R) in Z = false  .
  eq $fold-matches(N, Z) = Z [owise] .

  *** calculate the cumulative state-transition rates
  op allRewM : System -> Set{Rate{Pbag}} .
  eq allRewM(S) = cumrate(firing-matches(S)) . 
  op allRewN : System -> Set{Rate{Net}} .
  eq allRewN(N M) = cumrate(fold-matches(N)) .
  op allRewS : System -> Set{Rate{System}} .
  eq allRewS(S) = cumrate(aggr-matches(S) U merge-matches(S)) .

endfm

