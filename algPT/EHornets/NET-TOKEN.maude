in ../../SPN

*** the tag of net-token transition, built of a parametric tag followed by a string representing a channel
fmod TAG{L :: TRIV} is
  protecting PAIR{L,String} * (sort Pair{L,String} to Tag, op <_;_> to _@_) .
endfm

view Tag{L :: TRIV} from TRIV to TAG{L} is 
 sort Elt to Tag .
endv

in ../../shared/MSET

*** compact net-token marking description (multiset of markings) parametric in place labels
fmod NT-MARKING{PL :: TRIV} is
   pr MSET-BAG{Pbag{PL}} * (sort Mset{Pbag{PL}} to Mset{Pbag}, op empty to emptyMNT,
                            sort Bag{Pbag{PL}} to Bag{Pbag}, sort NeBag{Pbag{PL}} to NeBag{Pbag}, sort ElBag{Pbag{PL}} to ElBag{Pbag}, op nil to nilMNT).
endfm 


*** signature of (stochastic) net-tokens (derived from that of SPN)
fmod NT-SIG{L :: TRIV, PL :: TRIV} is
  pr SPN-SIG{Tag{L}, PL} . *** change to SPN-GEN if we want to import net + marking 
  var L : Lab . 
  var T : Tran .
  *** getters (for convenience)
  op ch : Tran -> String .
  eq ch(T) = ch(l(T)) . 
  op ch : Lab  -> String .
  eq ch(L) = 2nd(tag(L)) . *** channel (2nd part of tag) - the empty string means that no channel is associated with the tran.
endfm

*** trivial view of NT-SIG mapping Elt to Tran
view Tran{L :: TRIV, PL :: TRIV} from TRIV to NT-SIG{L, PL} is
  sort Elt to Tran .
endv

*** da qui vecchia def.

*** net-tokens structure definition (without marking)
fmod NT-STRUCT{L :: TRIV, PL :: TRIV} is 
  pr MSET-BAG{Tran{L, PL}} * (op nil to nilT, op empty to emptyMsetT, sort Bag{Tran{L, PL}} to Bag{Tran}, sort ElBag{Tran{L, PL}} to ElBag{Tran},
                         sort NeBag{Tran{L, PL}} to NeBag{Tran}, sort Mset{Tran{L, PL}} to Mset{Tran} ) .
  pr MSET-BAG{String} * (op nil to nilS, op empty to emptyMsetS) .
  var N : Net .
  var T : Tran .
  var PB : Pbag .
  var K : NzNat .
  var SB : Bag{String} .
  var TB : Bag{Tran} .
  var TM : Mset{Tran} .
  op hasInhibitor : Net -> Bool .
  eq hasInhibitor(N ; L:Lab |-> [I:Pbag,O:Pbag,H:NePbag]) = true .
  eq hasInhibitor(N) = false [owise] .
  op pre : Bag{Tran} -> Pbag . *** cumulative pre-set
  eq pre(TB) = $pre(TB, nilP) .
  op $pre : Bag{Tran} Pbag -> Pbag .
  eq $pre(nilT, PB) = PB .
  eq $pre(K . T + TB, PB) = $pre(TB, PB + K * I(T)) . 
  op post : Bag{Tran} -> Pbag . *** cumulative post-set
  eq post(TB) = $post(TB, nilP) .
  op $post : Bag{Tran} Pbag -> Pbag .
  eq $post(nilT, PB) = PB .
  eq $post(K . T + TB, PB) = $post(TB, PB + K * O(T)) .
  op ch : Bag{Tran} -> Bag{String} . *** ch extension to multisets
  eq ch(TB) = $ch(TB, nilS) .
  op $ch : Bag{Tran} Bag{String} -> Bag{String} .
  eq $ch(nilT, SB) = SB .
  var S : String .
 ceq $ch(K . T + TB, SB) = $ch(TB, if S =/= "" then K . S + SB else SB fi) if S := ch(T) .
endfm


*** net-token representation with compact state (markings) description parametric in node labels 
fmod NET-TOKEN{L :: TRIV, PL :: TRIV} is 
  pr NT-MARKING{PL} .
  pr NT-STRUCT{L, PL} .
  sort NetToken .
  var N : Net .
  var B : Mset{Pbag} . *** nested multiset
  var TB : Bag{Tran} .
  var T : Tran .
  var PB : Pbag .
  var K : NzNat .
  op __ : Net Mset{Pbag} -> [NetToken] [ctor] .
  op n : NetToken -> Net .
  op m : NetToken -> Mset{Pbag} .
  cmb N B : NetToken if hasInhibitor(N) = false . *** we suppose that net-tokens do not have inhibitor arcs
  eq n(N B) = N .
  eq m(N B) = B .
endfm

view NetToken{L :: TRIV, PL :: TRIV} from TRIV to NET-TOKEN{L, PL} is
  sort Elt to NetToken .
endv


*** net-token including the object-autonomous firing rule
mod NET-TOKEN-SYS{L :: TRIV, PL :: TRIV} is
 inc NET-TOKEN{L, PL} .
 vars N N' : Net .
 var B : Mset{Pbag} . 
 vars M M' : Pbag .
 var K : NzNat .
 var T : Tran .
 var NT : NetToken .
 crl [aut-firing] : (T ; N) B M => (T ; N) B firing(T, M) if ch(T) = "" /\ I(T) <= M /\ R:Float := firing-rate(T, M) .
endm

in ../ALG-PN


*** definition of an eHornet marking parametric vs the net-tokens' and system net's place labels -- net-tokems may be of any type and parametric in turn in node labels
fmod EHORNET-GEN{L :: TRIV, PL :: TRIV, PL' :: TRIV} is
   generated-by MSET-MARKING{NetToken{L, PL}, PL'} * (sort Mset{NetToken{L, PL}} to Mset{NetToken}, 
                            sort Bag{NetToken{L, PL}} to Bag{NetToken}, sort NeBag{NetToken{L, PL}} to NeBag{NetToken}, sort ElBag{NetToken{L, PL}} to ElBag{NetToken},
                            sort MsetMarking{NetToken{L, PL}} to  MsetMarking{NetToken}, sort  PmsetMarking{NetToken{L, PL}} to  PmsetMarking{NetToken},
                            op nil to nilNT, op empty to emptyNT ) .
   var N : Net .
   vars B B' : Mset{Pbag} . *** compact net-token markings' representation
   eq (N B) (N B') = N (B B') . 
   eq (N emptyMNT) = emptyNT .
endfm

*** theory for particular types of net-tokens, defined through subsorting
fth NET-TOKEN-TYPE is
 inc NET-TOKEN{Ntlab} .
 sort Token .
 subsort Token < NetToken .
endfth 

*** trivial view to NET-TOKEN-TYPE
view NetTokenType from TRIV to NET-TOKEN-TYPE is
 sort Elt to Token .
endv

*** alternative eHORNET definition parameterized in the (sub)type of net-tokens -- transitions' lab is NTLAB 
fmod EHORNET{NT :: NET-TOKEN-TYPE} is
   generated-by MSET-MARKING{NetTokenType}{NT} * (sort Mset{NetTokenType}{NT} to Mset{NT}, 
                            sort Bag{NetTokenType}{NT} to Bag{NT}, sort NeBag{NetTokenType}{NT} to NeBag{NT}, sort ElBag{NetTokenType}{NT} to ElBag{NT},
                            sort MsetMarking{NetTokenType}{NT} to  MsetMarking{NT}, sort  PmsetMarking{NetTokenType}{NT} to  PmsetMarking{NT},
                            op nil to nilNT, op empty to emptyNT ) .
   var N : Net .
   vars B B' : Mset{Pbag} . *** compact net-token markings' representation
   eq (N B) (N B') = N (B B') . 
   eq (N emptyMNT) = emptyNT .
endfm 

*** this theory defines the synchronization maps between system- and object-nets (not used here)
fth SYNCH is
 inc NT-STRUCT{Ntlab} .
 op synch : Net String -> Bag{String} . *** maps each rule (label) to a bag of channels
 op theta : Net -> Bag{Tran} . *** maps each net-token to a bag of transitions
endfth
