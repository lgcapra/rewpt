in ./BAG
in ../PLACE

*** marking of any algebraic net
fmod ALG-PN-MARK is 
 protecting PLACE .
 sorts Pmarking Marking Bag .
 subsort Pmarking < Marking .
 op _|->_ : Place Bag -> Pmarking [ctor] .
 op empty : -> Marking [ctor] .
 op _,_ : Marking Marking -> [Marking] [ctor assoc comm id: empty prec 121 format (d r os d)] .
 op undefined : -> [Bag] [ctor] .
 op init : -> Marking . *** should be defined in an importing module
 
 vars P P' : Place .
 vars B B' : Bag .
 var M : Marking .
 var PM : Pmarking . 
 var M' : [Marking] .

 *** well-definiteness of marking (no duplicate places)
op well-def : [Marking] -> Bool .
eq well-def((P |-> B , P |-> B', M')) = false .
eq well-def(M') = true  [owise] .
*** well-definiteness characterization
cmb M' : Marking if well-def(M') .
*** look-up OP
op _[_] : Marking Place -> [Bag] [prec 23] .
eq (M, P |-> B)[P] = B .
eq M[P] = undefined [owise] .
op marked : Marking Place -> Bool .
eq marked(M, P) = M[P] =/= undefined .

endfm

fmod Marking is 
 sort Bag . *** denotes a generic multiset
endfm


fmod ALG-PN-MARK-2 is 
 protecting PLACE .
 protecting MAP{Place, AnyBag} .
endfm

*** submarking of an algebraic net of specific type
fmod MARK{X :: TRIV} is
  protecting ALG-PN-MARK .
  protecting BAG{X} .
  sorts Pmark{X} Mark{X} .
  subsort Pmark{X} < Pmarking Mark{X} < Marking .
  subsort Bag{X} < Bag .
  op _|->_ : Place Bag{X} -> Pmark{X} [ctor ditto] .
  op _,_ : Mark{X} Mark{X} -> [Mark{X}] [ctor ditto] .
  op empty : -> Mark{X} [ctor ditto ] .
  op undefined : -> [Bag{X}] [ctor ditto] .
  var M : Mark{X} .
  var M' : [Mark{X}] .
  *** cmb  M' : Mark{X} if M' :: Marking .
endfm


*** an example of algebraic net
mod ALG-PN-EXE is
 pr ALG-PN-MARK .
 *** types of model's places
 pr MARK{Nat} * ( op nil : -> Bag{Nat} to 0nat) .
 pr MARK{List{Nat}} * (op nil : -> Bag{List{Nat}} to 0lsnat) .
 *** NOTA in questo esempio termini come 1 . 2 NON sono preregolari (due least sorts: Bag{Nat} e Bag{List{Nat}})
 op init : -> Marking .
 eq init =  p(1) |-> 1 . nil , p(2) |-> 2 . 1 + 3 . 2 . 
 var P : Place .
 var B : Bag{Nat} .
 var M : Marking .
 var L : List{Nat} .
 var NeL : NeList{Nat} .
 var LB : Bag{List{Nat}} .
 vars N N' N'' : Nat .
 vars K K' : NzNat .
 *** transitions encoded as rewrite rules
 *** dati (almeno) due elementi identici in p2 t1 ne rimuove uno e lo accoda nella lista in p1 
 *** crl [t1] : p(1) |-> 1 . L , p(2) |-> K . N + B => p(1) |-> 1 . (L N), p(2) |-> sd(K,1) . N + B  if K > 1 . *** works
 *** rl [t1] : p(1) |-> 1 . L , p(2) |-> 2 . N + B => p(1) |-> 1 . (L N), p(2) |->  1 . N + B  . *** doesn't work: doesn't perform all matches
 *** crl [t1] : p(1) |-> 1 . L , p(2) |-> B => p(1) |-> 1 . (L N), p(2) |->  B - 1 . N if 1 . N <= B . *** N used before bound
 
 *** rimuove K elementi identici da p2 e li accoda alla lista p1
 *** rl [t2] : p(1) |-> 1 . L , p(2) |-> K . N + B => p(1) |-> 1 . L ncopies(N, K) , p(2) |->  B . *** works
 *** rimuove un elemento dalla lista p1 e lo mette in p2
 *** rl [t3] : p(1) |-> 1 . NeL , p(2) |-> B => p(1) |-> 1 . tail(NeL) , p(2) |->  B + 1 . head(NeL) . *** works
 
 *** altri esempi che hanno/non hanno match : rimuove dalla lista in p1 un elemento in testa la cui somma corrisponde a due elementi in p2 (rimossi anche loro)
*** rl [t4] : p(1) |-> 1 . (N + N') L , p(2) |-> K . N + K' . N' + B => p(1) |-> 1 . L, p(2) |-> sd(K,1) . N + sd(K',1) . N' + B   . *** no match
crl [t4] : p(1) |-> 1 . N'' L , p(2) |-> K . N + K' . N' + B => p(1) |-> 1 . L, p(2) |-> sd(K,1) . N + sd(K',1) . N' + B  
     if N'' = N' + N . *** works
endm

*** nested algebraic net!!
mod ALG2-PN-EXE is
 inc ALG-PN-EXE .
 pr P-MARK{Pmark{Nat}}  .
 pr P-MARK{Pmark{List{Nat}}} * (op nil : -> Bag{Pmark{List{Nat}}} to 0l2snat) .
endm