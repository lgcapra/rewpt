in ./BAG
in ../PLACE

*** marking of any algebraic net (an example)
fmod ALG-PN-MARK is 
 protecting PLACE .
 sorts Pmarking Marking Bag .
 subsort Pmarking < Marking .
 op _|->_ : Place Bag -> Pmarking [ctor] .
 op empty : -> Marking [ctor] .
 op _,_ : Marking Marking -> [Marking] [ctor assoc comm id: empty prec 121 format (d r os d)] .
 op undefined : -> [Bag] [ctor] .

 vars P P' : Place .
 vars B B' : Bag .
 var M : Marking .
 var PM : Pmarking . 
 var M' : [Marking] .

 *** well-definiteness OF A MARKING (no duplicates)
op well-def : [Marking] -> Bool .
eq well-def((P |-> B , P |-> B', M')) = false .
eq well-def(M') = true  [owise] .
*** well-definiteness characterization
cmb M' : Marking if well-def(M') .
*** look-up OP
op _[_] : Marking Place -> [Bag] [prec 23] .
eq (M, P |-> B)[P] = B .
eq M[P] = undefined [owise] .
op marked : Marking Place -> Bool .
eq marked(M, P) = M[P] =/= undefined .

endfm

*** marking of an algebraic net of specific type
fmod MARK{X :: TRIV} is
  protecting ALG-PN-MARK .
  protecting BAG{X} .
  sorts Pmark{X} Mark{X} .
  subsort Pmark{X} < Pmarking Mark{X} < Marking .
  subsort Bag{X} < Bag .
  op _|->_ : Place Bag{X} -> Pmark{X} [ctor ditto] .
  op _,_ : Mark{X} Mark{X} -> [Mark{X}] [ctor ditto] .
  op empty : -> Mark{X} [ctor ditto ] .
  op undefined : -> [Bag{X}] [ctor ditto] .
endfm


*** an example of algebraic net
mod ALG-PN-EXE is
 pr ALG-PN-MARK .
 *** types of model's places
 pr MARK{Nat} * ( op nil : -> Bag{Nat} to 0nat) .
 pr MARK{List{Nat}} * (op nil : -> Bag{List{Nat}} to 0lsnat) .
 *** NOTA in questo esempio termini come 1 . 2 NON sono preregolari (due least sorts: Bag{Nat} e Bag{List{Nat}})
 op init : -> Marking .
 eq init =  p(1) |-> 1 . nil , p(2) |-> 2 . 1 + 3 . 2 . 
 var P : Place .
 var B : Bag{Nat} .
 var M : Marking .
 var L : List{Nat} .
 var LB : Bag{List{Nat}} .
 var N : Nat .
 vars K K' : NzNat .
 *** transitions encoded as rewrite rules
 *** dati (almeno) due elementi identici in p2 t1 ne rimuove uno e lo accoda nella lista in p1 
 *** crl [t1] : p(1) |-> 1 . L , p(2) |-> K . N + B => p(1) |-> 1 . (L N), p(2) |-> sd(K,1) . N + B  if K > 1 . *** works
 *** rl [t1] : p(1) |-> 1 . L , p(2) |-> 2 . N + B => p(1) |-> 1 . (L N), p(2) |->  1 . N + B  . *** doesn't work: doesn't do all matches
 *** crl [t1] : p(1) |-> 1 . L , p(2) |-> B => p(1) |-> 1 . (L N), p(2) |->  B - 1 . N if 1 . N <= B . *** N used before bound
 
 *** rimuove K elementi identici da p2 e li accoda alla lista p1
 rl [t2] : p(1) |-> 1 . L , p(2) |-> K . N + B => p(1) |-> 1 . L ncopies(N, K) , p(2) |->  B  . *** works
endm