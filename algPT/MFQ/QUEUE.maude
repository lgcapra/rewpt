in TASK

*** Round Robin (FIFO) queue - builds on predefined module LIST and on module TASK
fmod QUEUE{X :: TRIV} is
 protecting LIST{Task{X}} * (sort List{Task{X}} to List{Task}, sort NeList{Task{X}} to NeList{Task}, op __  to _`,_ ) .
 sorts Queue NeQueue .
 subsort NeQueue < Queue .
 op q:_ts:_ : List{Task} NzNat -> Queue .
 op inf : -> NzNat [memo] . *** alias for a big value representing the infinity
 eq inf = 10000 .
 var K : NzNat .
 var L : List{Task} .
 var T : Task .
 var Q : Queue .
 mb (q: NeL:NeList{Task} ts: K) : NeQueue . 
 op ts : Queue -> NzNat . *** time slice of the queue (infinite means fifo)
 op q :  Queue -> List{Task} . *** list of tasks
 eq ts(q: L ts: K) = K .
 eq q(q: L ts: K)  = L .
 op add : Queue Task -> NeQueue .
 eq add((q: L ts: K), T) = q: L, T ts: K .
 op empty : Queue -> Bool .
 eq empty(Q) = q(Q) == nil .
endfm

*** parameterized trivial view
view Queue{X :: TRIV} from TRIV to QUEUE{X} is 
 sort Elt to Queue . 
endv

*** a network of queues
fmod QUEUE-NET{X :: TRIV} 
 is protecting LIST{Queue{X}} * (sort List{Queue{X}} to Qnet, sort NeList{Queue{X}} to NeQnet,
                                op nil : -> List{Queue{X}} to nilQnet, op __  to _`,_ ) .
 vars Q Q' : Queue .
 vars QN QN' : Qnet .
 
 op ordered : Qnet -> Bool [memo] . *** checks for ordering (notice that ordered implies with no repeated priority)
 ceq ordered(QN, Q, Q', QN') = false if ts(Q) >= ts(Q') .
 eq ordered(QN) = true [owise] .

 op firstNe : NeQnet -> [Queue] . *** the first non-empty queue, if any
 eq firstNe(Q, QN) = if empty(Q) == false then Q else firstNe(QN) fi .  
 
endfm


*** parameterized trivial view
view Qnet{X :: TRIV} from TRIV to QUEUE-NET{X} is 
 sort Elt to Qnet . 
endv

in ../ALG-PN

mod MFQ{X :: TRIV} is
 pr MS-MARKING-STR{Task{X}} *  (sort PmsMarking{Task{X}} to PmsMarking{Task}, 
                               sort  Mset{Task{X}} to  Mset{Task}, sort NeMset{Task{X}} to  NeMset{Task}, op empty{Task{X}} to empty{Task}) .
 pr MS-MARKING-STR{Qnet{X}} * (sort PmsMarking{Qnet{X}} to PmsMarking{Qnet}, sort Mset{Qnet{X}} to Mset{Qnet}, sort NeMset{Qnet{X}} to NeMset{Qnet},
                                op empty{Qnet{X}} to  empty{Qnet}, op mark to markQ ) . *** renaming mark is mandatory

 vars Q Q' : Queue .
 vars QN QN' : Qnet .
 var T : Task .
 var B : Mset{Task} .
 var L : List{Task} .
 vars K K' : NzNat .
 var X : X$Elt .

 
 *** append a task (selected non deterministically) to the header queue
  rl [assign] : p("queue") |-> Q, QN ;  p("task") |-> T B => p("queue") |-> add(Q, T), QN ; p("task") |-> B  .
*** serve a task that finishes its residual time burst
crl [serve-exhausted] : p("queue") |-> QN, Q, QN' ;  p("served") |-> B  => p("queue") |-> QN, (q: L ts: K), QN' ;  p("served") |-> B (X @ 0) 
      if Q = firstNe(QN, Q) /\ (q: X @ K', L ts: K) := Q /\ K' <= K .  
*** serve a task that doesn't exhaust its burst, by appending the task to the next-level queue
crl [serve-notexh-shift] : p("queue") |-> QN, Q, Q', QN'  => p("queue") |-> QN, (q: L ts: K), add(Q', X @ K' - K), QN'  
      if Q = firstNe(QN, Q) /\ (q: X @ K', L ts: K) := Q /\ K' > K .
*** serve a task that doesn't exhaust its burst, in the event the queue is the last (possibly the only)
crl [serve-notexh-last] : p("queue") |-> QN, Q  => p("queue") |-> QN, (q: L, X @ K' - K ts: K)  
      if Q = firstNe(QN, Q) /\ (q: X @ K', L ts: K) := Q /\ K' > K .

endm

*** instance of MFQ using strings as task labels
mod MFQ-STR is
   inc MFQ{String} . 
   op burst : String -> [NzNat] [memo].
   eq burst("a") = 1 .
   eq burst("b") = 4 .
   op tsk : String -> [Task] .
   var s : String .
   eq tsk(s) = s @ burst(s) .
   op m0 : -> Marking [memo] . 
   eq m0 =  p("queue") |-> (q: nil ts: 1), (q: nil ts: 2), (q: nil ts: inf)  ; p("task") |-> tsk("a") tsk("a")tsk("b")  ; p("served") |-> empty{Task} . 
   var T : Task .
   vars B B' : Mset{Task} .
   *** uncomment the following rule if you want the model becomes live (otherwise it enters an absorbing state)
   *** rl [reset] : p("served") |-> B s @ 0 ; p("task") |->  B' => p("served") |-> B ; p("task") |->  B' tsk(s) .
endm

view Mfq from TRIV to MFQ-STR is
   sort Elt to Marking .
endv 