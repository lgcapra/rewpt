in TASK
in ../ELIST

*** Round Robin (FIFO) queue - builds on predefined module LIST and on module TASK
fmod QUEUE{X :: TRIV-NZ} is
 protecting LIST{Task{X}} * (
      *** sort List{Task{X}} to List{Task}, sort NeList{Task{X}} to NeList{Task}, 
      op __  to _`,_ ) .
 sorts Queue{X} NeQueue{X} .
 subsort NeQueue{X} < Queue{X} .
 op q:_ts:_ : List{Task{X}} NzNat -> Queue{X} .
 op inf : -> NzNat [memo] . *** alias for a big value representing the infinity
 eq inf = 10000 .
 var K : NzNat .
 var L : List{Task{X}} .
 var T : Task{X} .
 var Q : Queue{X} .
 mb (q: NeL:NeList{Task{X}} ts: K) : NeQueue{X} . 
 op ts : Queue{X} -> NzNat . *** time slice of the queue (infinite means fifo)
 op q :  Queue{X} -> List{Task{X}} . *** list of tasks
 eq ts(q: L ts: K) = K .
 eq q(q: L ts: K)  = L .
 op add : Queue{X} Task{X} -> NeQueue{X} .
 eq add((q: L ts: K), T) = q: L, T ts: K .
 op empty : Queue{X} -> Bool .
 eq empty(Q) = q(Q) == nil .
endfm

*** parameterized trivial view
view Queue{X :: TRIV} from TRIV to QUEUE{X} is 
 sort Elt to Queue{X} . 
endv

*** a network of queues
*** op __  to _`,_  
fmod QUEUE-NET{X :: TRIV-NZ} 
 is protecting ELIST{Queue{X}} * (sort Elist{Queue{X}} to Qnet{X}, sort NeElist{Queue{X}} to NeQnet{X},
                                 op nil : -> List{Queue{X}} to nilQnet ).
 *** sort List{Queue{X}} to List{Queue}, sort NeList{Queue{X}} to NeList{Queue},
                                 
 vars Q Q' : Queue{X} .
 vars LQ LQ' : List{Queue{X}} .
 op ordered : List{Queue{X}} -> Bool [memo] . *** checks for ordering (notice that ordered implies with no repeated priority)
 ceq ordered(LQ, Q, Q', LQ') = false if ts(Q) >= ts(Q') .
 eq ordered(LQ) = true [owise] .

 op firstNe : List{Queue{X}} -> [Queue{X}] . *** the first non-empty queue, if any
 eq firstNe(Q, LQ) = if empty(Q) == false then Q else firstNe(LQ) fi .  
 
endfm


*** parameterized trivial view
view Qnet{X :: TRIV-NZ} from TRIV-NZ to QUEUE-NET{X} is 
 sort Elt to Qnet{X} . 
endv

in ../ALG-PN

mod MFQ{X :: TRIV-NZ} is
 pr MARKING-STR{Task{X}}  .
 pr MARKING-STR{Qnet{X}}   * (op mark to markQnet) . *** renaming mark is mandatory
 pr MARKING-STR{Queue{X}}  * ( op mark to markQ )  .  *** renaming mark is mandatory

 vars Q Q' : Queue{X} .
 vars LQ LQ' LQ'' : List{Queue{X}} .
 var T : Task{X} .
 var B : Mset{Task{X}} .
 var L : List{Task{X}} .
 var MQ : Mset{Queue{X}} .
 vars K K' : NzNat .
 var X : X$Elt .
 *** append a task (selected non deterministically) to the header queue
  rl [assign] : p("queue") |-> [Q, LQ] ;  p("task") |-> T B => p("queue") |-> [add(Q, T), LQ] ; p("task") |-> B  .
*** serve a task that finishes its residual time burst
crl [serve-exhausted] : p("queue") |-> [LQ, Q, LQ'] ;  p("served") |-> B  => p("queue") |-> [LQ, (q: L ts: K), LQ'] ;  p("served") |-> B (X @ 0) 
      if Q = firstNe(LQ, Q) /\ (q: X @ K', L ts: K) := Q /\ K' <= K .  
*** serve a task that doesn't exhaust its burst, by appending the task to the next-level queue
crl [serve-notexh-shift] : p("queue") |-> [LQ, Q, Q', LQ']  => p("queue") |-> [LQ, (q: L ts: K), add(Q', X @ K' - K), LQ']  
      if Q = firstNe(LQ, Q) /\ (q: X @ K', L ts: K) := Q /\ K' > K .
*** serve a task that doesn't exhaust its burst, in the event the queue is the last (possibly the only)
crl [serve-notexh-last] : p("queue") |-> [LQ, Q]  => p("queue") |-> [LQ, (q: L, X @ K' - K ts: K)]  
      if Q = firstNe(LQ, Q) /\ (q: X @ K', L ts: K) := Q /\ K' > K .
*** simulates a failure on a queue in the network
rl [fail] :  p("queue") |-> [LQ, Q, LQ'] ; p("fail") |-> MQ  => p("queue") |-> [LQ, LQ'] ; p("fail") |-> Q MQ .

endm

*** the MFQ module with some renaming to use as base-level
mod BL-MFQ{X :: TRIV-NZ} is 
    inc MFQ{X} * (sort Place{String} to BL-Place{String}, op p to bl-p, sort Marking to BL-Marking, sort Pmarking to BL-Pmarking,
          sort Pmarking{Queue{X}} to BL-Pmarking{Queue{X}}, sort Pmarking{Qnet{X}} to BL-Pmarking{Qnet{X}},
          sort Pmarking{Task{X}} to BL-Pmarking{Task{X}}) . 
endm


*** parametric view to BL-MFQ
view Mfq{X :: TRIV-NZ} from TRIV-NZ to BL-MFQ{X} is
    sort Elt to BL-Marking . 
endv

*** instance of MFQ using strings as task labels
mod MFQ-STR is 
   inc MFQ{String} . 
   op burst : String -> [NzNat] [memo] .
   eq burst("a") = 1 .
   eq burst("b") = 4 .
   eq burst("c") = 5 .
   op tsk : String -> [Task{String}] .
   var s : String .
   eq tsk(s) = s @ burst(s) .
   op m0 : -> [Marking] [memo] .
   var LQ : List{Queue{String}} .
  ceq m0 =  p("queue") |-> [LQ]  ; p("task") |-> tsk("c") tsk("a") tsk("a") tsk("b") tsk("b")  ; 
            p("served") |-> empty{Task{String}} ; p("fail") |-> empty{Queue{String}} if LQ := (q: nil ts: 1), (q: nil ts: 2), (q: nil ts: inf) /\ ordered(LQ) .                         
   *** uncomment the following rule if you want the model becomes live (otherwise it enters an absorbing state)
   var T : Task{String} .
   vars B B' : Mset{Task{String}} .
   rl [reset] : p("served") |-> B s @ 0 ; p("task") |->  B' => p("served") |-> B ; p("task") |->  B' tsk(s) .
endm