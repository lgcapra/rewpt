in ./BAG
in ../PLACE

*** used in the example
*** embedded list (builds on built-in LIST) --- avoids any preregularity issue, e.g., between terms like: 1 . 1 and 1 . 1 2
fmod E-LIST{X :: TRIV} is
 protecting LIST{X} .
 sorts NeElist{X} Elist{X} .
 subsort NeElist{X} < Elist{X} .

 op `[`] : -> Elist{X} [ctor] .
 op `[_`] : List{X} -> Elist{X} [ctor] .
 op __ : Elist{X} Elist{X} -> Elist{X} [assoc id: `[`] prec 25] .
 op __ : NeElist{X} Elist{X} -> NeElist{X} [ditto] .
 op __ : Elist{X} NeElist{X} -> NeElist{X} [ditto] .

 var E E' : X$Elt .
 vars A L : List{X} .
 eq [nil] = [] .
 eq [A] [L] = [A L] .
 *** inherit all the other ops from LIST
endfm

*** parameterized trivial view to E-LIST{X}
view Elist{X :: TRIV} from TRIV to E-LIST{X} is 
 sort Elt to Elist{X} . 
endv

*** specification of algebraic PN
fmod ALG-PN-MARK is 
 sorts Pmarking Marking .
 subsort Pmarking < Marking .
 op empty : -> Marking [ctor] .
 op _,_ : Marking Marking -> Marking [ctor assoc comm id: empty prec 121 format (d r os d)] .
 op init : -> Marking .
endfm

*** submarking of a specific type
fmod MARK{X :: TRIV} is
  extending ALG-PN-MARK .
  protecting PLACE  .
  protecting BAG{X} .
  sorts Pmark{X}  Mark{X} .
  subsort Pmark{X} < Pmarking Mark{X} < Marking .
  op _|->_ : Place Bag{X} -> Pmark{X} [ctor] .
  op _,_ : Mark{X} Mark{X} -> Mark{X} [ctor ditto] .
  var B  : Bag{X} .
  var P  : Place .
  op place : Pmark{X} -> Place .
  eq place(P |-> B) = P .
endfm

*** parameterized trivial view to MARK
view Mark{X :: TRIV} from TRIV to MARK{X} is 
 sort Elt to Mark{X} . 
endv


*** an example of algebraic net
mod ALG-PN-EXE is
 *** types of model's places
 pr MARK{Nat} * ( op nil : -> Bag{Nat} to 0nat ) .
 pr MARK{Elist{Nat}} * (op nil : -> Bag{Elist{Nat}} to 0lsnat ) .
 *** sorts Pmarking Marking .
 **** subsort Mark{Nat} Mark{Elist{Nat}} < Marking .
 **** subsort Pmark{Nat} Pmark{Elist{Nat}} < Pmarking < Marking .
 eq init =  p(1) |-> 1 . [] , p(2) |-> 2 . 1 + 3 . 2 . 
 *** eq init =  p(1) |-> 1 . [] ; p(2) |-> 2 . 1 + 3 . 2 . 
 var M : Marking .
 var B : Bag{Nat} .
 var L : Elist{Nat} .
 var LB : Bag{Elist{Nat}} .
 var N : Nat .
 vars K K' : NzNat .
 *** transitions encoded as rewrite rules
 *** dati (almeno) due elementi identici in p2 t1 ne rimuove uno e lo accoda nella lista in p1 
 crl [t1] : p(1) |-> 1 . L , p(2) |-> K . N + B => p(1) |-> 1 . L [N], p(2) |-> sd(K,1) . N + B  if K > 1 . *** works
 *** rl  [t1] : p(1) |-> 1 . L , p(2) |-> 2 . N + B => p(1) |-> 1 . L [N], p(2) |->  1 . N + B  . *** doesn't work: doesn't do all matches
 *** crl [t1] : p(1) |-> 1 . L , p(2) |-> B => p(1) |-> 1 . (L N), p(2) |->  B - 1 . N if 1 . N <= B . *** N used before bound
 
 *** rimuove K elementi identici da p2 e li accoda alla lista p1
 *** rl [t2] : p(1) |-> 1 . L , p(2) |-> K . N + B => p(1) |-> 1 . L [ncopies(N, K)] , p(2) |->  B  . *** works
endm

fmod MARK-NAT is
 pr MARK{Nat} * (sort Marking to Marking2, sort Pmarking to Pmarking2, op empty to empty2) .
endfm

fmod MARK-LIST-NAT is
 pr MARK{Elist{Nat}} * (sort Marking to Marking2, sort Pmarking to Pmarking2, op empty to empty2) .
endfm

view MarkNat from TRIV to MARK-NAT is 
   sort Elt to Mark{Nat} . 
endv

view MarkListNat from TRIV to MARK-LIST-NAT is 
  sort Elt to Mark{Elist{Nat}} . 
endv

***  nested algebraic net
mod NEST-ALG-PN-EXE is
  *** inc ALG-PN-EXE * (sort Marking to Marking2, sort Pmarking to Pmarking2, op empty to empty2) .
  pr MARK{MarkNat} .
  pr MARK{MarkListNat} .
endm