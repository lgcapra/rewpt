*** "pseudo" lexicographically ordered lists
*** in the case of a strict-total-order, the pseodo lex order collapses with the usual lex order 
fmod COMPARABLE-LIST{X :: STRICT-WEAK-ORDER+} is 
 pr WEAKLY-SORTABLE-LIST+{X} .
 pr EXT-BOOL . 
 
 op lex : Nat List{X} List{X} -> Bool .  *** we use the name lex instead of lt to avoid a conflict
 op cmp : Nat List{X} List{X} -> Nat .   *** compare method (defined for convenience and efficiency) -- results in {0,1,2}
 
 vars E E' : X$Elt .
 vars L L' : List{X} .
 vars  NeL NeL' : NeList{X} .
 var C : Nat .
 
 eq [lex]  : lex(C, L, L') = cmp(C, L, L') == 1 . *** pseudo lex ordering (builds on cmp)
 eq [cmp1] : cmp(C, nil, NeL) = 1 .
 eq [cmp2] : cmp(C, NeL, nil) = 2 .
 eq [cmp3] : cmp(C, L, L) = 0 .
ceq [cmp4] : cmp(C, E L, E' L') = 1 if lt(C, E , E') .
ceq [cmp5] : cmp(C, E L, E' L') = 2 if lt(C, E', E) .
 eq [cmp6] : cmp(C, E L, E' L') = cmp(C, L, L') [owise] .
endfm


view ComparableList<{X :: STRICT-WEAK-ORDER+} from STRICT-TOTAL-ORDER to COMPARABLE-LIST{X} is 
 sort Elt to  List{X} .
 vars X Y : Elt . 
 op X < Y to term lt(0, X, Y) .
endv

*** stuff to defined nested list of comparable elements (plus partitioning into similar blocks)

*** "embedded" list definition by @Lorenzo Capra
fmod ELIST{X :: TRIV} is
    pr LIST{X} .
    sort Elist{X} .
    op {_} : List{X} -> Elist{X}  [ctor] .
    op join : Elist{X} Elist{X} -> Elist{X} [assoc] .
    op arg : Elist{X} -> List{X} .
    vars L L' : List{X} .
    eq join({L}, {L'}) = {L L'} .
    eq arg({L}) = L .
 endfm
    
view Elist{X :: TRIV} from TRIV to ELIST{X} is
   sort Elt to Elist{X} .
endv

*** fmod NESTED-LIST{X :: TRIV} is
***  pr LIST{Elist{X}} * (op nil : -> List{Elist{X}} to {}) .
*** endfm

*** "embedded" sortable list definition
fmod SORTABLE-ELIST{X :: STRICT-WEAK-ORDER+} is
  pr ELIST{STRICT-WEAK-ORDER+}{X} * (sort Elist{STRICT-WEAK-ORDER+}{X} to Elist{X},
                                     sort List{STRICT-WEAK-ORDER+}{X} to List{X},
                                     sort NeList{STRICT-WEAK-ORDER+}{X} to NeList{X} ) .
  pr  WEAKLY-SORTABLE-LIST+{X } . 

  var C : Nat . var L : List{X} .
  op sort : Nat Elist{X} -> Elist{X} .
  eq sort(C, {L}) = {sort(C,L)} . 
endfm

view SortableElist{X :: STRICT-WEAK-ORDER+} from TRIV to SORTABLE-ELIST{X} is
   sort Elt to Elist{X} .
endv

fmod NESTED-SORTABLE-LIST{X :: STRICT-WEAK-ORDER+} is
  pr LIST{SortableElist{X}} * (sort  List{SortableElist{X}} to ListOfList{X}, sort NeList{SortableElist{X}} to NeListOfList{X},
                               op nil : -> List{SortableElist{X}} to {}) .
endfm

*** defines nested lists of sortable elements 
fmod COMPARABLE-NESTED-LIST{X :: STRICT-WEAK-ORDER+} is 
 pr COMPARABLE-LIST{X} .
 pr NESTED-SORTABLE-LIST{X}  .          
 
 var E  : X$Elt .
 vars L L' : List{X} .
 vars  NeL NeL' : NeList{X} .
 var C : Nat .
 *** gets "equivalent" elements from the head of a (sorted) list
 op headeq : Nat List{X} -> List{X} .
 op headeq : Nat NeList{X} -> NeList{X} .
 eq headeq(C, L) = $headeq(C, L, nil) .
 op $headeq : Nat List{X} List{X} -> List{X} . *** auxiliary op
 eq $headeq(C, E L, nil) = $headeq(C, L, E) .
ceq $headeq(C, E L, NeL) = $headeq(C, L, NeL E) if cmp(C, head(NeL), E) == 0 .
 eq $headeq(C, L, L') = L' [owise] .
 *** partitions a (sorted) list into similarity" blocks (holding contigous elements for which cmp evaluates to 0) 
 var LoL : ListOfList{X} .
 op partition : Nat List{X} ->  ListOfList{X} .
 eq partition(C, nil) = {nil} .
 eq partition(C, NeL) = $partition(C, NeL, {}) .
 op $partition : Nat List{X} ListOfList{X} ->  ListOfList{X} .
 eq $partition(C, nil, LoL) = LoL .
ceq $partition(C, NeL, LoL) = $partition(C, pop(NeL, NeL'), LoL {NeL'}) if NeL' := headeq(C, NeL) .
 *** internally sorts (reorders) the nested lists (blocks)
 op reorder : Nat ListOfList{X} ->  ListOfList{X} .
 eq reorder(C, {}) = {} .
 eq reorder(C, {L} LoL) = {sort(C,L)} reorder(C, LoL) .
endfm

view ComparableNestedList<{X :: STRICT-WEAK-ORDER+} from STRICT-TOTAL-ORDER to COMPARABLE-NESTED-LIST{X} is 
 sort Elt to  List{X} .
 vars X Y : Elt . 
 op X < Y to term lt(0, X, Y) .
endv
