*** "embedded" list definition (useful to define nested lists) by @Lorenzo Capra
fmod ELIST{X :: TRIV} is
    pr LIST{X} .
    sort Elist{X} .
    op {_} : List{X} -> Elist{X}  [ctor] .
    op join : Elist{X} Elist{X} -> Elist{X} [assoc] .
    op arg : Elist{X} -> List{X} .
    vars L L' : List{X} .
    eq join({L}, {L'}) = {L L'} .
    eq arg({L}) = L .
 endfm
    
view Elist{X :: TRIV} from TRIV to ELIST{X} is
   sort Elt to Elist{X} .
endv

fmod NESTED-LIST{X :: TRIV} is
  pr LIST{Elist{X}} * (op nil : -> List{Elist{X}} to {}) .
endfm

*** version with sort renaming
*** fmod NESTED-LIST{X :: TRIV} is
***  pr LIST{Elist{X}} * (sort List{Elist{X}} to ListOfList{X}, sort NeList{Elist{X}} to NeListOfList{X}, op nil : -> List{Elist{X}} to nilnest).
*** endfm

*** "embedded" sortable list definition
fmod SORTABLE-ELIST{X :: STRICT-WEAK-ORDER+} is
  pr ELIST{STRICT-WEAK-ORDER+}{X} * (sort Elist{STRICT-WEAK-ORDER+}{X} to Elist{X},
                                     sort List{STRICT-WEAK-ORDER+}{X} to List{X},
                                     sort NeList{STRICT-WEAK-ORDER+}{X} to NeList{X} ) .
  pr  WEAKLY-SORTABLE-LIST+{X } . 

  var C : Nat . var L : List{X} .
  op sort : Nat Elist{X} -> Elist{X} .
  eq sort(C, {L}) = {sort(C,L)} . 
endfm

view SortableElist{X :: STRICT-WEAK-ORDER+} from TRIV to SORTABLE-ELIST{X} is
   sort Elt to Elist{X} .
endv

fmod NESTED-SORTABLE-LIST{X :: STRICT-WEAK-ORDER+} is
  pr LIST{SortableElist{X}} * (sort  List{SortableElist{X}} to List{Elist{X}}, sort NeList{SortableElist{X}} to NeList{Elist{X}},
                               op nil : -> List{SortableElist{X}} to {}) .
endfm



*** "pseudo" lexicographically ordered lists (plus partitioning into similar blocks)
*** in the case of a strict-total-order the pseudo lexicographic order collapses with the usual lexicographic order 
fmod COMPARABLE-LIST{X :: STRICT-WEAK-ORDER+} is 
 pr WEAKLY-SORTABLE-LIST+{X} .
 pr NESTED-SORTABLE-LIST{X}  .         
 pr EXT-BOOL . 
 
 op lex : Nat List{X} List{X} -> Bool .  *** we use the name lex instead of lt to avoid a conflict
 op cmp : Nat List{X} List{X} -> Nat .   *** compare method (defined for convenience and efficiency) -- results in {0,1,2}
 
 vars E E' : X$Elt .
 vars L L' : List{X} .
 vars  NeL NeL' : NeList{X} .
 var C : Nat .
 
 eq [lex]  : lex(C, L, L') = cmp(C, L, L') == 1 . *** pseudo lex ordering (builds on cmp)
 eq [cmp1] : cmp(C, nil, NeL) = 1 .
 eq [cmp2] : cmp(C, NeL, nil) = 2 .
 eq [cmp3] : cmp(C, L, L) = 0 .
ceq [cmp4] : cmp(C, E L, E' L') = 1 if lt(C, E , E') .
ceq [cmp5] : cmp(C, E L, E' L') = 2 if lt(C, E', E) .
 eq [cmp6] : cmp(C, E L, E' L') = cmp(C, L, L') [owise] .
 *** PART2 (might be defined as an apart module)
 *** gets "equivalent" elements from the head of a (sorted) list
 op headeq : Nat List{X} -> List{X} .
 op headeq : Nat NeList{X} -> NeList{X} .
 eq headeq(C, L) = $headeq(C, L, nil) .
 op $headeq : Nat List{X} List{X} -> List{X} . *** auxiliary op
 eq $headeq(C, E L, nil) = $headeq(C, L, E) .
ceq $headeq(C, E L, NeL) = $headeq(C, L, NeL E) if cmp(C, head(NeL), E) == 0 .
 eq $headeq(C, L, L') = L' [owise] .
 *** partitions a (sorted) list into similarity" blocks (holding contigous elements for which cmp evaluates to 0) 
 var LoL : List{Elist{X}} .
 op partition : Nat List{X} ->  List{Elist{X}} .
 eq partition(C, nil) = {nil} .
 eq partition(C, NeL) = $partition(C, NeL, {}) .
 op $partition : Nat List{X} List{Elist{X}} ->  List{Elist{X}} .
 eq $partition(C, nil, LoL) = LoL .
ceq $partition(C, NeL, LoL) = $partition(C, pop(NeL, NeL'), LoL {NeL'}) if NeL' := headeq(C, NeL) .
 *** internally sorts (reorders) the nested lists (blocks)
 op reorder : Nat List{Elist{X}} ->  List{Elist{X}} .
 eq reorder(C, {}) = {} .
 eq reorder(C, {L} LoL) = {sort(C,L)} reorder(C, LoL) .
endfm


view ComparableList<{X :: STRICT-WEAK-ORDER+} from STRICT-TOTAL-ORDER to COMPARABLE-LIST{X} is 
 sort Elt to  List{X} .
 vars X Y : Elt . 
 op X < Y to term lt(0, X, Y) .
endv