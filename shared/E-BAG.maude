*** generalized multisets where multiplicities can be parameters
fmod G-BAG{X :: TRIV} is
 protecting INT .
 protecting EXT-BOOL .

 sorts Param Mult . *** the parameter subsort and the multiplicity sort
 subsorts Nat Param < Mult . 
 
 sorts Gbag{X} NeGbag{X} ElGbag{X} Bag{X} NeBag{X} ElBag{X} .
 subsort ElBag{X} < ElGbag{X} .
 subsort NeBag{X} < NeGbag{X} .
 subsort Bag{X} < Gbag{X} .
 subsorts ElBag{X} < NeBag{X} < Bag{X} . 
 subsorts ElGbag{X} < NeGbag{X} < Gbag{X}  .
 
 op k : Nat -> Param [ctor] . *** parameters take the form k(0), k(1), etc
 op undefined : -> [Mult] [ctor] . *** undefined multiplicity

 vars M M' : Mult .
 var J : Nat .
 vars N N' : NzNat .
 vars X Y Z : X$Elt .
 vars B B' B'' : Gbag{X} .
 vars NeB NeB' NeB'' : NeGbag{X} .
 *** constructors
 op nil{X} : -> Bag{X} [ctor] .
 op _._  : Mult X$Elt ->  ElGbag{X} [prec 35 ctor] .
 op _._  : Nat X$Elt ->  ElBag{X} [ditto] .
 eq 0 . X = nil{X} .
 *** bag operations
 op _`[_`] : Gbag{X} X$Elt -> [Nat] [prec 23] .
 op _`[_`] : Bag{X} X$Elt -> Nat [ditto] .
 op _+_  : Gbag{X} Gbag{X} -> Gbag{X} [prec 39 ctor assoc comm id: nil{X}] .
 op _+_  : NeGbag{X} Gbag{X} -> NeGbag{X} [ctor ditto] .
 op _+_  : Bag{X} Bag{X} -> Bag{X} [ctor ditto] .
 op _+_  : NeBag{X} Bag{X} -> NeBag{X} [ctor ditto] .
 op _in_ : X$Elt Gbag{X} -> Bool .
 eq X in M . X + B = true .
 eq X in B = false [owise] .
 *** eq (N . X + B)[X] = N .
 eq (M . X + B)[X] = if X in B then undefined else M fi .
 eq B[X] = 0 [owise] .
 *** sum
 eq N . X + N' . X = (N + N') . X .
 *** difference
 op _-_  : Gbag{X} Gbag{X} -> Gbag{X} [prec 41 gather (E e) right id: nil{X}] .
 eq N . X + B - N' . X + B' = max(0, N - N') . X + (B - B') . *** more compact
ceq B - NeB = B  if B =/= NeB  [owise] .
*** intersection
 op _∩_ : Gbag{X} Gbag{X} -> [Gbag{X}] [prec 43 assoc comm] .  *** intersection
 op _∩_ : Bag{X} Bag{X} -> Bag{X} [ditto] .  *** intersection
 eq B ∩ B = B .
 eq B ∩ nil{X} = nil{X} .
 eq N . X + B ∩ N' . X + B' = min(N,N') . X + (B ∩ B') .
ceq k(j) . X + B ∩ B' = B ∩ B' if B'[X] = undefined .
 *** eq N . X + B ∩ B' = B ∩ B' [owise] .
 op _I_ : Gbag{X} Gbag{X} -> Gbag{X} [prec 43 assoc comm] .  *** intersection (aliasing)
 eq B I B' = B ∩ B' .
*** scalar product
 op _*_ : Nat Gbag{X} -> Gbag{X}  [prec 37] . *** higher priority than the sum (in any case parenthese needed to disambiguate)
 eq 0 * B = nil{X} .
 eq N' * nil{X} = nil{X} .
 eq N' * (N . X + B) = (N' * N) . X + N' * B .
 *** sets an element's multiplicity (if zero removes it from the bag)
 op set  : Gbag{X} X$Elt Nat -> Gbag{X} . 
 eq set(B + N . X, X, J) =  B + J . X  .
 eq set(B, X, J) = B + J . X [owise] .
 *** remove a given element from a bag
 op remove :  Gbag{X} X$Elt -> Gbag{X} .
 eq remove(B, X) = set(B, X, 0) .
 
 *** relational ops
 op _<=_ : Gbag{X} Gbag{X} -> Bool [prec 43] .
 eq B <= B = true . *** optimization
ceq N . X + B <= B' = false if N > B'[X] .
ceq B <= B' = true if B =/= B' [owise] . 
 op _<_ : Gbag{X} Gbag{X} -> Bool [prec 43] .
 eq B < B = false . *** optimization
ceq N . X + B < B' = false if N >= B'[X] .
ceq B < B' = true if B =/= B' [owise] . 
 **** greater than restricted to the elements of 1st bag
 op _>_ : Gbag{X} Gbag{X} -> Bool [prec 43] .
 ceq N . X + B > B' = false if N <= B'[X] .
 eq B > B' = true [owise] .
 
 *** bag's cardinality
 op |_| : Gbag{X} -> Nat . 
 op |_| : NeGbag{X} -> NzNat . 
 eq | B | = $bcard(B, 0) . 
 op $bcard : Gbag{X} Nat -> Nat . 
 eq $bcard(nil{X}, J) = J . 
 eq $bcard(N . X + B, J) = $bcard(B, J + N) .
 *** bag's size (n. of elements)
 op size : Gbag{X} -> Nat . 
 op size : NeGbag{X} -> NzNat . 
 eq size(B) = $size(B, 0) .  
 op $size : Gbag{X} Nat -> Nat . 
 eq $size(nil{X}, J) = J . 
 eq $size(N . X + B, J) = $size(B, J + 1) .

 *** checks whether two bags are pairwise disjoint
 op disjoint : Gbag{X} Gbag{X} -> Bool [ comm ] .
 eq disjoint(N . X + B, N' . X + B') = false .
 eq disjoint(B, B') = true [owise] .
 *** checks whether a bag is a "set" (muliplicities < 2)
 op isaset : Gbag{X} -> Bool .
ceq isaset(N . X + B) = false if N > 1 .
 eq isaset(B) = true [owise] .
endfm

*** parameterized view to G-BAG{X}
view Gbag{X :: TRIV} from TRIV to G-BAG{X} is 
 sort Elt to Gbag{X} . 
endv

fmod G-BAG-STRING is
  pr G-BAG{String} .
endfm 
