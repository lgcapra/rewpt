fmod MAP+{X :: TRIV, Y :: TRIV} is 
  protecting BOOL .
  protecting SET{X} * (op empty to nokeys) + LIST{Y} * (op nil to novalues)  .
  sorts Entry{X,Y} Map{X,Y} .
  subsorts Entry{X,Y} < Map{X,Y} .
  op _|->_ : X$Elt Y$Elt -> Entry{X,Y} [ctor] .
  op empty : -> Map{X,Y} [ctor] .
  op _`,_ : [Map{X,Y}] [Map{X,Y}] -> [Map{X,Y}] [assoc comm id: empty ctor prec 121 format (d r os d)] .
  op undefined : -> [Y$Elt] [ctor] .
  op insert : X$Elt Y$Elt [Map{X,Y}] -> [Map{X,Y}] .
  op insert : X$Elt Y$Elt Map{X,Y} -> Map{X,Y} .
  op remove : X$Elt [Map{X,Y}] -> [Map{X,Y}] .
  op remove : X$Elt Map{X,Y} -> Map{X,Y} .
  
  op _`[_`] : [Map{X,Y}] X$Elt -> [Y$Elt] [prec 23] .
  op $hasMapping : [Map{X,Y}] X$Elt -> Bool .
  
  op keyset : [Map{X,Y}] -> Set{X} .
  op values : [Map{X,Y}] -> List{Y} .
  op hasduplicate : [Map{X,Y}] -> Bool .
  
  var D : X$Elt .
  vars R R' : Y$Elt .
  var M : [Map{X,Y}] .
  
  eq $hasMapping ((M, D |-> R), D) = true .
  eq $hasMapping (M, D) = false [owise] .
  eq insert (D, R, (M, D |-> R')) = if $hasMapping (M, D) then insert (D, R, M) else (M, D |-> R) fi .
  eq insert (D, R, M) = (M, D |-> R) [owise] .
  eq remove (D, (M, D |-> R)) = remove(D, M) .
  eq remove (D, M) = M [owise] .
  eq insert (D, R, M) = (M, D |-> R) [owise] .
  eq (M, D |-> R) [D] = if $hasMapping (M, D) then undefined else R fi .
  eq M [D] = undefined [owise] .
  
  eq hasduplicate((D |-> R, D |-> R', M)) = true .
  eq hasduplicate(M) = false [owise] .
  cmb M : Map{X,Y} if hasduplicate(M) = false .
  eq keyset(empty) = nokeys .
  eq keyset((D |-> R, M)) = D, keyset(M) .
  eq values(empty) = novalues .
  eq values((D |-> R, M)) = R values(M) .
endfm