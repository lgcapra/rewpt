in BAGP
in TRAN
in ATYPE

fmod IMATRIX is
 pr BAGP .
 pr ATYPE .
 sorts Imatrix Limatrix .
 op [_,_,_] : Pbag Pbag Pbag -> Imatrix [ctor] .
 
 vars X Y Z X' Y' Z' : Pbag .
 vars P P' : Place .
 vars N N' C1 C2 : Nat .
 vars IL IL' OL OL' HL HL' : List{Nat,Place} .
 vars Q Q' : Imatrix .
 
 op remove : Imatrix Place -> Imatrix .
 eq remove([X,Y,Z], P) = [set(X,P,0),set(Y,P,0),set(Z,P,0)] .
 
 ops I O H : Imatrix -> Pbag .
 eq I([X,Y,Z]) = X .
 eq O([X,Y,Z]) = Y .
 eq H([X,Y,Z]) = Z .

 op _(_) : Imatrix Atype -> Pbag [prec 23] . *** introduced for convenience
 var a : Atype .
 eq Q(i) = I(Q) .
 eq Q(o) = O(Q) . 
 eq Q(h) = H(Q) .

 op in :  Imatrix Place -> Bool . *** test the existence of a place
 var K : NzNat .
 eq in([X + K . P, Y, Z], P) = true .
 eq in([X, Y + K . P, Z], P) = true .
 eq in([X, Y, Z + K . P], P) = true .
 eq in(Q, P) = false [owise] .

 op places : Imatrix -> Pset .
 eq places([X,Y,Z]) = support(X) U support(Y) U support(Z) .

 *** canonization ops
 op swap : Imatrix Place Place -> Imatrix .
 eq swap([X,Y,Z], P, P') = [swap(X,P,P'),swap(Y,P,P'),swap(Z,P,P')] .

 op replace : Imatrix Place Place -> Imatrix .
 eq replace([X,Y,Z], P, P') = [replace(X,P,P'),replace(Y,P,P'),replace(Z,P,P')] .

 *** part used for canonization
 op [_,_,_] : List{Nat,Place} List{Nat,Place} List{Nat,Place} -> Limatrix . *** list view
 ops toListS  toListS1 : Imatrix -> Limatrix [memo] . *** maybe only toListS1 should be set memo
 eq toListS([X,Y,Z])  = [toListS(X),  toListS(Y),  toListS(Z) ] .
 eq toListS1([X,Y,Z]) = [toListS1(X), toListS1(Y), toListS1(Z)] .

 ops _<_  _<1_ : Limatrix Limatrix -> Bool . *** strict total-order between matrices based on lt relation between bags and (partial) order based on bag weights  
 vars LX LY LZ LX' LY' LZ' : List{Nat,Place} .
 vars LQ LQ' : Limatrix .
 eq [LX,LY,LZ] <  [LX',LY',LZ'] = LX lt LX' or-else LX == LX' and-then (LY lt LY' or-else LY == LY' and-then LZ lt LZ') .
 op cmp1 : Limatrix Limatrix -> Nat . *** compares the wights of the corresponding (sorted1) lists considering I,O,H in order
ceq cmp1([LX,LY,LZ], [LX',LY',LZ']) = C1 if C1 := cmp1(LX, LX') /\ C1 =/= 0 . 
ceq cmp1([LX,LY,LZ], [LX',LY',LZ']) = C2 if C2 := cmp1(LY ,LY') /\ C2 =/= 0 [owise]. 
 eq cmp1([LX,LY,LZ], [LX',LY',LZ']) = cmp1(LZ, LZ') [owise] .
 eq LQ <1 LQ' = cmp1(LQ, LQ') == 1 . 
 
 *** derived operators (defined only for convenience: helpful?)
 ops _<_  _<1_ : Imatrix Imatrix -> Bool . *** strict total-order between matrices based on lt relation between bags and (partial) order based on bag weights  
 eq Q < Q'  = toListS(Q)  <  toListS(Q') .
 op cmp1 : Imatrix Imatrix -> Nat .
 eq cmp1(Q, Q') = cmp1(toListS1(Q), toListS1(Q')) .
 eq Q <1 Q' = cmp1(Q, Q') == 1 .
 
endfm

*** default view to IMATRIX
view Imatrix from TRIV to IMATRIX is 
 sort Elt to Imatrix . 
endv

*** standard total-order view to IMATRIX
view Imatrix< from STRICT-TOTAL-ORDER to IMATRIX is 
 sort Elt to Imatrix . 
endv

*** total order based on subscripts first
view Imatrix<1 from STRICT-TOTAL-ORDER to IMATRIX is 
 sort Elt to Imatrix . 
   op _<_ to _<1_ .
endv

*** the same views for the list-views
view Limatrix< from STRICT-TOTAL-ORDER to IMATRIX is 
 sort Elt to Limatrix . 
endv

view Limatrix<1 from STRICT-TOTAL-ORDER to IMATRIX is 
 sort Elt to Limatrix . 
   op _<_ to _<1_ .
endv