in PT-SYS+
in LAZYEVAL

view EmptyListP from DEFAULT to PT-SYS is 
 sort Elt to ListP .
 op 0 to emptyListP  . 
endv

fmod CAN-PT-SYS is
 inc PT-SYS .
 pr LAZYEVAL{EmptyListP} .
 vars Q Q' : Imatrix .
 vars S S' : String .
 vars I J : Nat .
 vars P P' P'' : Place .
 vars T T' : Tran .
 vars SYS  SYS' : System .
 vars N  N' : Net .
 vars B M0 M0' : BagP .
 vars SP SP' : SetP .
 vars LP LP' : ListP .
 vars LT LT'  : ListT .
 var NeLP : NeListP .
 var NeSP : NeSetP .
 var NeLT : NeListT .
 vars Sy Sy' Sy'' : System .
 var C : Bool .
 
 *** ceq t(I,S) |-> Q, t(J,S) |-> Q' = t(I,S) |-> Q', t(J,S) |-> Q if I < J /\ Q' < Q . *** preserves order

 *** ceq Sy = Sy' if B := marking(Sy) /\ N := net(Sy) /\ Sy' := canonize(Sy,"") /\ B =/= marking(Sy') or-else  N =/= net(Sy') .

 *** ceq Sy = Sy' if  Sy' := canonize(Sy,"") /\ Sy'' := Sy /\ Sy' =/= Sy'' .

 *** implementation of canonization

 sort CanSys .
 op __ : System Bool -> CanSys  [ctor] . *** the boolean flag sets the system's (net) canonization status
 eq Sy false =  canonize(Sy, "", "") true .

 op sys : CanSys -> System .
 eq sys(Sy C) = Sy .

 op canonical?  : CanSys -> Bool .
 eq canonical?(Sy C) = C .
 

 op replacePindices : System String -> System . *** replace the place indices (with a given label) so that they range throug 0..n-1 
 
 
 **** var AL : ListBT .
 **** var NeAL : NeListBT .
 **** op canonizeNet : Atype ListP System -> System . *** canonizes a system w.r.t. a sorted list of (net) places and a type of (sorted) adjacency list
 **** eq canonizeNet(A, NeLP, Sy) = canonizeNet(A, makeAdjList(net(Sy),A), NeLP, Sy) .
 **** eq canonizeNet(A, emptyListP, Sy) = Sy .
 **** op canonizeNet  : Atype ListBT ListP System -> System . *** canonizes a system w.r.t. a sorted list of (net) places and a (sorted) adjacency list
 **** eq canonizeNet(A, AL, emptyListP, Sy) = Sy  .
**** ceq canonizeNet(A, AL, P LP, Sy) = canonizeNet(A, LP, Sy')  if Sy' := canonizeP(AL, P, Sy) /\ Sy' =/= Sy . *** implicitly reorders AL in the case of swap of P with some P'
 **** eq canonizeNet(A, AL, P LP, Sy) = canonizeNet(A, AL, LP, Sy) [owise] . 
 **** op canonizeP : ListBT Place System -> System . *** canonizes a system w.r.t. a place and an adjacency list - builds on minGtIdx
 **** eq canonizeP(AL, P, Sy) = $canonizeP(AL, P, emptyListP, Sy) .
 **** op $canonizeP : ListBT Place ListP System -> System . *** auxiliary version taking a list (set) of places as additional arg - builds on takeAction
 **** eq $canonizeP(emptyListBT, P, LP, Sy) = Sy .
**** ceq $canonizeP(< B ; T > AL, P, LP, Sy) = takeAction(< B ; T > AL, P, LP', Sy) if LP' := minGtIdx(B, P, LP)  /\ LP' =/= emptyListP .
 **** eq $canonizeP(< B ; T > AL, P, LP, Sy) = $canonizeP(AL, P, LP, Sy) [owise] . *** a5 (set A is empty, P doesn't belong to B)  
 
 **** op takeAction : NeListBT Place NeListP System -> System . 
 **** eq takeAction(< B ; T > AL, P, P NeLP, Sy) = $canonizeP(AL, P, NeLP, Sy) . *** a1 (continues from the next bag using P and the tail of listP as args)
**** ceq takeAction(< B ; T > AL, P, (P' P'' LP), Sy) = $canonizeP(swapS(AL, P , P''), P, (P' LP), swap(Sy, P, P'')) if P' =/= P  . *** a2 (swaps P with the 2nd el of listP and sorts then continues from the next bag still using P and the residual of listP)
**** ceq takeAction(NeAL, P, P', Sy) = swap(Sy, P, P' )  if P' =/= P . *** a3 (swaps P with the only el P' of listP, different from P, sorts and continues from the next(P))
 **** eq takeAction(NeAL, P, P, Sy) = Sy . *** a4 (continues from next(P) )

 
 *** equivalent version of canonizeNet using indices (0..K-1) instead of a list of places -- the adjacency list is a list of bags
 *** this version also uses as additional, last parameter a list of bags representing incidence matrices already canonized and that have to be retained
 
 var A : Atype .
 var K : NzNat .
 vars BL BL' : ListBagP .
 var NeBL : NeListBagP .
 *** CAMBIARE DI NOME PER EVITARE CONFUSIONE
 op canonizeNet : System Atype Nat String ListBagP -> System . *** canonizes a system w.r.t. a given number of net places (with the given label) -- start-up
 eq canonizeNet(Sy, A, 0, S, BL) = Sy .
 eq canonizeNet(Sy, A, K, S, BL) = canonizeNet(Sy, A, makeAdjListS(net(Sy),A), 0, K, S, BL) .
 op canonizeNet  : System Atype ListBagP Nat NzNat String ListBagP -> System . *** canonizes a system w.r.t. a number of net places and a (sorted) adjacency list
 eq canonizeNet(Sy, A, BL, K, K, S, BL') = Sy  .
ceq canonizeNet(Sy, A, BL, I, K, S, BL') = canonizeNet(Sy', A, makeAdjListS(net(Sy'),A), I + 1, K, S, BL')  if I =/= K /\ Sy' := canonizeP(Sy, BL, p(I,S), BL') /\ Sy' =/= Sy . *** implicitly reorders the AL in the case of swap of P with some P'
 eq canonizeNet(Sy, A, BL, I, K, S, BL') = canonizeNet(Sy, A, BL, I + 1, K, S, BL') [owise] .

 op canonizeP : System ListBagP Place ListBagP -> System . *** canonizes a system w.r.t. a place and an adjacency list - builds on minGtIdx
 eq canonizeP(Sy, BL, P, BL') = $canonizeP(Sy, BL, P, emptyListP, BL') .
 op $canonizeP : System ListBagP Place ListP ListBagP -> System . *** auxiliary version taking a list (set) of places as additional arg - builds on takeAction
 eq $canonizeP(Sy, emptyListBagP, P, LP, BL') = Sy .
ceq $canonizeP(Sy, B BL, P, LP, BL') = takeAction(Sy, B BL, P, LP', BL') if LP' := minGtIdx(B, P, LP)  /\ LP' =/= emptyListP .
 eq $canonizeP(Sy, B BL, P, LP, BL') = $canonizeP(Sy, BL, P, LP, BL') [owise] . *** a5 (LP', i.e., set A is empty and P doesn't belong to B)  
 *** on the basis of minGtIdx outcome, it may perform some swaps between places
 op takeAction : System NeListBagP Place NeListP ListBagP -> System . 
 eq takeAction(Sy, B BL, P, P NeLP, BL') = $canonizeP(Sy, BL, P, NeLP, BL') . *** a1 (continues from the next bag using P and the tail of listP as args)
ceq takeAction(Sy, B BL, P, (P' P'' LP), BL') = $canonizeP(swap(Sy, P, P''), swapS(BL, P , P''), P, (P' LP), BL') if P' =/= P  /\ BL' == $swap(BL', P, P'') . *** a2 (swaps P with the 2nd el of listP and sorts then continues from the next bag still using P and the residual of listP)
ceq takeAction(Sy, NeBL, P, P', BL) = swap(Sy, P, P' )  if P' =/= P /\ BL == $swap(BL, P, P') . *** a3 (swaps P with the only el P' of listP, different from P, sorts and continues from the next(P))
 eq takeAction(Sy, NeBL, P, NeLP, BL) = Sy [owise] . *** a4 (continues from next(P) )

*** top-level ops
 *** canonizes a system (considering nodes with certain labels) 
 op canonize : System String String -> System .
ceq canonize(Sy, S, S') = canonizeTrans(net(Sy'), S') marking(Sy') if Sy' := canonizePlaces(Sy, | places(Sy) |, S) .
 op canonizePlaces : System NzNat String -> System . *** canonizes the system's net places (with a certain label) --- core of the canonization alg.
ceq canonizePlaces(Sy, K, S) = canonizeNet(Sy', h, K, S, (makeAdjList(net(Sy'),i) makeAdjList(net(Sy'),o))) if Sy' := $canonizeInOut(Sy, K, S) .
 op $canonizeInOut : System NzNat String -> System .
ceq $canonizeInOut(Sy, K, S) = canonizeNet(Sy', o, K, S, makeAdjList(net(Sy'),i)) if Sy' := canonizeNet(Sy, i, K, S, emptyListBagP)   .
 op canonizeMark : System NzNat String -> System . *** canonizes the system's marking, assuming that the net is in canonical form  .
 *** to do

 var LQ : ListQ .
 op canonizeTrans : Net String -> Net . *** canonizes the net's transitions (with a certain label) --- assumes that place canonization is done
 eq canonizeTrans(N, S) = $canonizeTrans(makeAdjList(N, S), 0, S, emptyN) .
 op $canonizeTrans : ListQ Nat String Net -> Net .
 eq $canonizeTrans(emptyListQ, I, S, N) = N .
 eq $canonizeTrans(Q LQ, I, S, N) = $canonizeTrans(LQ, I + 1, S, (N, t(I,S) |-> Q)) . 

 *** the following operators replace the indices of nodes so that they lie in 0...n-1
 *** assume that the list of nodes holds all and only the nodes with a certain label, sorted in increasing order
 *** DOMANDA: SI POSSONO DEFINIRE SENZA USARE ListP?
 op replaceIndexP : System ListP -> System . 
 eq replaceIndexP(Sy, emptyListP) = Sy .
ceq replaceIndexP(Sy, NeLP) = Sy if subscript(last(NeLP)) + 1 == size(NeLP) .
 eq replaceIndexP(Sy, NeLP) = $replaceIndexP(Sy, NeLP, 0) [owise] .
 op $replaceIndexP : System ListP Nat -> System . 
 eq $replaceIndexP(Sy, emptyListP, I) = Sy .
 eq $replaceIndexP(Sy, p(I, S) LP, I) = $replaceIndexP(Sy, LP, I + 1) . 
ceq $replaceIndexP(Sy, p(J, S) LP, I) = $replaceIndexP(replace(Sy, p(J, S), p(I, S)), LP, I + 1) if I =/= J .

 op replaceIndexT : Net ListT -> Net . 
 eq replaceIndexT(N, emptyListT) = N .
ceq replaceIndexT(N, NeLT) = N if subscript(last(NeLT)) + 1 == size(NeLT) .
 eq replaceIndexT(N, NeLT) = $replaceIndexT(N, NeLT, 0) [owise] .
 op $replaceIndexT : Net ListT Nat -> Net . 
 eq $replaceIndexT(N, emptyListT, I) = N .
 eq $replaceIndexT(N, t(I, S) LT, I) = $replaceIndexT(N, LT, I + 1) . 
ceq $replaceIndexT(N, t(J, S) LT, I) = $replaceIndexT(replace(N, t(J, S), t(I, S)), LT, I + 1) if I =/= J .

 op replaceIndexP : System -> System .
 eq replaceIndexP(Sy) = replaceIndexP(Sy, placeList(Sy)) .
 op replaceIndexT : Net -> Net .
 eq replaceIndexT(N) = replaceIndexT(N, tranList(N)) .
endfm