in IMATRIX
in ../shared/MAP+
in ../shared/COMP-PAIR-LIST-NEW

*** defines (possibly nested) sortable lists of local incidence matrices (representing a PT systems, when abstracting from T names)
fmod NESTED-MATRIX-LIST is 
  pr COMP-NESTED-LIST{Limatrix+<}  * (sort List{Limatrix+<}  to List{Limatrix}, sort NeList{Limatrix+<}  to NeList{Limatrix},  op nil to emptyListQL ,
                                    sort ListOfList{Limatrix+<} to ListOfList{Limatrix}, sort NeListOfList{Limatrix+<} to NeListOfList{Limatrix},
                                    sort Elist{Limatrix+<} to  Elist{Limatrix}) .
 endfm 

*** trivial view to a nested list of matrices
view NestedMatList from TRIV to NESTED-MATRIX-LIST is 
 sort Elt to ListOfList{Limatrix} .
endv

*** the canonization should be put in another module ...
fmod PT-NET is
 inc MAP+{Tran,Imatrix} * (sort Map{Tran,Imatrix} to Net, sort Entry{Tran,Imatrix} to ImatrixT, op emptyM to emptyN) .
 
 pr SORTABLE-LIST{Tran<}  * (sort List{Tran<} to Tlist, sort NeList{Tran<} to NeTlist, op nil to emptyTlist ) .
 pr SORTABLE-LIST{Place<} * (sort List{Place<} to Plist, sort NeList{Place<} to NePlist, op nil to emptyPlist ) .
 *** pr NESTED-MATRIX-LIST .
 pr SET{NestedMatList} * (sort Set{NestedMatList} to SetOfListOfList{Limatrix}, sort NeSet{NestedMatList} to NeSetOfListOfList{Limatrix},
                          op empty to emptySetOfNestedQL, op _,_ to _U_) .
 pr ATYPE .
 pr PAIR{Pset, Nat} . *** multiple return value (defined for convenience)

 var  N : Net .
 vars T T' : Tran .
 vars P P' : Place .
 vars Y J  : Nat .
 vars K K' : NzNat .
 vars I O H B : Pbag .
 vars Q Q' : Imatrix .
 
 vars S S' SP : Pset . 
 vars L L1 : Plist .
 var W :  String .
 var F :  Bool .
 
 *** vars QL QL' : List{Imatrix} .
 vars QL QL' : Limatrix .
 vars LQL LQL'  : List{Limatrix} .
 vars ELQL ELQL' : Elist{Limatrix} .
 vars LELQL LELQL' : ListOfList{Limatrix} .
 var A :  Atype .
 *** vars BL BL' : List{Pbag} . 
 var E : ImatrixT .
 var LB :  List{Nat,Place} .
 
 eq T |-> [I,I,H] = emptyN [metadata "null t"] . *** transitions not changing the marking are erased

 op welldef : Net -> Bool .
 eq welldef(N) = N =/= emptyN and-then repeatedKeys?(N) == false . 
 
 ops In Out Inh : Net Tran -> [Pbag] . 
 eq In(T |-> Q ; N, T) = I(Q) .
 eq Out(T |-> Q ; N, T) = O(Q) .
 eq Inh(T |-> Q ; N, T) = H(Q) .

 op dead : ImatrixT -> Bool .  *** checks for structurally dead transitions 
 eq dead(T |-> [K . P + I, O, K' . P + H]) = K >= K' [metadata "dead t"] .
 eq dead(Q:ImatrixT) = false [owise] .

 op in :  Net Place -> Bool . *** test the existence of a place
ceq in(T |-> Q ; N, P) = true if in (Q, P) .
 eq in(N, P) = false [owise] .

 op in :  Net Tran -> Bool . *** test the existence of a transition
 eq in(N, T) = $hasMapping(N, T) .

 op places : Net -> Pset .
 eq places(N) = $places(N, emptyPset) .  
 op $places : Net Pset -> Pset . 
 eq $places(emptyN, S) = S . 
 eq $places(T |-> Q ; N, S) = $places(N, S U places(Q)) .

 op placeList : Net -> Plist . *** returns the sorted list of places of a net
 eq placeList(N) = $makePlist(places(N),emptyPlist) .
 op $makePlist : Pset Plist -> Plist . 
 eq $makePlist(emptyPset, L) = sort(L) . 
 eq $makePlist(P U S, L) = $makePlist(S, P L) . 

 var TL : Tlist .
 op tranList : Net -> Tlist .  *** returns the sorted list of transitions
 eq tranList(N) = $makeTlist(N,emptyTlist) .
 op $makeTlist : Net Tlist -> Tlist . 
 eq $makeTlist(emptyN, TL) = sort(TL) . 
 eq $makeTlist(T |-> Q ; N, TL) = $makeTlist(N, T TL) . 

 op places : Net Atype -> Pset . *** return the places of a given type 
 eq places(N, A) = $places(N, A, emptyPset) .
 op $places : Net Atype Pset -> Pset .
 eq $places(emptyN, A, S) = S .
 eq $places(T |-> Q ; N, A, S) = $places(N, A, S U support(Q(A)) ) . 
 
 **** canonization part

 *** gets a sorted list of matrices (better, list-views of matrices) out of a net by sorting on the basis of bag weights
 op matListS : Nat Net String -> List{Limatrix} .  
 eq matListS(Y, N, W) = sort(Y, $matListS(Y, N, W, emptyListQL)) .
 op $matListS : Nat Net String List{Limatrix} -> List{Limatrix} .
 eq $matListS(Y, emptyN, W, LQL) = LQL .
 eq $matListS(Y, T |-> Q ; N, W, LQL) = $matListS(Y, N, W, LQL sort(Y, toList(Q, W)))  .
 op matListS : Nat Net -> List{Limatrix} . *** consider only empty labels
 eq matListS(Y, N) = matListS(Y, N, "") .
 *** regroups PT's (list-views of) matrices into similarity blocks prefixed by the marking (convenience op)
 op regroup : Net Pbag String -> ListOfList{Limatrix} .
 eq regroup(N, B, W) = {[toListS(0,B),emptyListNP,emptyListNP]} partition(1, matListS(1, N, W)) .
 op regroup : Net Pbag -> ListOfList{Limatrix} .
 eq regroup(N, B) = regroup(N, B, "") . *** default
 
 *** operators to swap pairs of elements (various/overloaded versions)
 op swap : Net Place Place -> Net . 
 eq swap(T |-> Q ; N, P, P') = T |-> swap(Q, P, P') ; swap(N, P, P') .
 eq swap(emptyN, P, P') = emptyN .

 op swapLM : List{Limatrix} Place Place -> List{Limatrix} . *** note that "renaming" swap is necessary 
 eq swapLM(emptyListQL, P, P') = emptyListQL .
 eq swapLM(QL LQL, P, P') = swap(QL, P, P') swapLM(LQL, P, P') .

 op swap : ListOfList{Limatrix} Place Place -> ListOfList{Limatrix} .
 eq swap({ }, P, P') = { } .
 eq swap({LQL} LELQL, P, P') = {swapLM(LQL, P, P')} swap(LELQL, P, P') .

 *** transitions
 op swap : Net Tran Tran -> Net .  *** swaps two transitions in a net
 eq swap(T |-> Q ; N, T, T') = T' |-> Q ; swap(N, T, T') . 
 eq swap(T |-> Q ; N, T', T) = T' |-> Q ; swap(N, T', T) .
 *** eq swap((T |-> Q, T' |-> Q', N), T, T') = T |-> Q', T' |-> Q, N . 
 *** eq swap((T |-> Q, N), T, T') = T' |-> Q, N [owise] . 
 *** eq swap((T |-> Q, N), T', T) = T' |-> Q, N [owise] . 
 eq swap(N, T, T') = N [owise] .
 op replace : Net Tran Tran -> [Net] .  *** replace the first transition with the 2nd one in a net
 eq replace(T |-> Q ; N, T, T') = T' |-> Q ; N .
 eq replace(N, T, T') = N [owise] .
 
 op maxint : -> NzNat [memo] .
 eq maxint = 10000000000000 .
 
 op minGtIdxSys : Net Pbag Place -> Pset . *** convenience op (for debug)
 eq minGtIdxSys(N, B, P) = $minGtIdxNet(regroup(N, B), P) .
 *** considers the list of (list-views of) matrices representing a net and logically divides them into block of similar elements
 op $minGtIdxNet : ListOfList{Limatrix} Place -> Pset .
 eq $minGtIdxNet({ }, P) = emptyPset .
ceq $minGtIdxNet(ELQL LELQL, P) = S if S := minGtIdxLM(arg(ELQL), P) /\ S =/= emptyPset .
 eq $minGtIdxNet(ELQL LELQL, P) = $minGtIdxNet(LELQL, P) [owise] .
 *** given a list (block) of assumed similar (list-views of) matrices and a place p, returns the set of places candidate to swap with p
 vars NeLQL NeLQL' : NeList{Limatrix} .
 op minGtIdxLM : List{Limatrix} Place -> Pset . 
ceq minGtIdxLM(LQL, P) = S if S := minGtIdxLM(LQL, i, P) /\ S =/= emptyPset . *** first the i component
ceq minGtIdxLM(LQL, P) = S if S := minGtIdxLM(LQL, o, P) /\ S =/= emptyPset [owise] . *** then o
 eq minGtIdxLM(LQL, P) = minGtIdxLM(LQL, h, P) [owise] . *** finally h
 *** separately considers the i,o,h components of each matrix
 op minGtIdxLM : List{Limatrix} Atype Place -> Pset . 
 eq minGtIdxLM(LQL, A, P) = $minGtIdxLM(LQL, A, P, maxint, emptyPset) .  *** start-up
 op $minGtIdxLM : List{Limatrix} Atype Place NzNat Pset -> Pset .
 eq $minGtIdxLM(emptyListQL, A, P, K, S) = S .
ceq $minGtIdxLM(QL LQL, A, P, K, S) = $minGtIdxLM(LQL, A, P, K', S') if < S' ; K' > := $minGtIdx(QL(A), P, K, S) .
 *** base op. acting on a (list-view of a) bag: this version returns a pair of values (a set of places and a weight)
 *** Given LB, P, LP, if A = {P' in B s.t. index(P') >= index(P) and LP != 0 => P' in LP} is not 0 then returns the elements {P'} of A with MINIMAL-weight s.t. if B[P] > 0 then B[P'] <= B[P] (possibly including P).
 *** If A is empty returns P if B[P] > 0, otherwise 0 .
 *** If the retuned list's size is > 1 the 2nd el. is that with the greatest idx (also if P is not in the list!) 
 op $minGtIdx : List{Nat,Place} Place NzNat Pset -> Pair{Pset,Nat} . *** base op.: works on a single list (bag)
 eq $minGtIdx(emptyListNP, P, K, S) = < S ; K > .
ceq $minGtIdx(< K' ; p(Y,"") > LB, P, K, S) = < S ; K > if K' > K . *** we assume that the list's weights are in increasing order 
ceq $minGtIdx(< K  ; p(Y,"") > LB, p(J,""), K, S) = $minGtIdx(LB, p(J,""), K, S U p(Y,""))  if Y >= J .
ceq $minGtIdx(< K' ; p(Y,"") > LB, p(J,""), K, S) = $minGtIdx(LB, p(J,""), K', p(Y,""))  if K' <  K /\ Y >= J .
 eq $minGtIdx(NP:Pair{Nat,Place} LB, P, K, S) = $minGtIdx(LB, P, K, S) [owise] .
 
 *** canonization op
 vars NeLELQL : NeListOfList{Limatrix} .
 var NeL : NePlist .
 var NeP : NePset .
 var NeSLELQL : NeSetOfListOfList{Limatrix} . 
 var SLELQL  : SetOfListOfList{Limatrix} . 
 op canonize : Net Pbag -> NeListOfList{Limatrix} . *** convenience top op.
 eq canonize(N, B) = canonize(regroup(N, B), placeList(N)) .

 op canonize : NeListOfList{Limatrix} NePlist -> NeListOfList{Limatrix} . *** real top operator
 eq canonize(NeLELQL, P) = NeLELQL . *** canonization makes sense if there are at least two places
 eq canonize(NeLELQL, P NeL) = canonize(min(canonizeP(NeLELQL, P, NeL)), NeL) . 
 op min : NeSetOfListOfList{Limatrix} -> ListOfList{Limatrix} . *** convenience op
 eq min(NeSLELQL) = $min($reorder(NeSLELQL)) .
 op $min : NeSetOfListOfList{Limatrix} -> ListOfList{Limatrix} . *** gets the minimal representative
 eq $min(LELQL) = LELQL .
 eq $min (LELQL U LELQL' U SLELQL) = $min(SLELQL U if lex(0, LELQL, LELQL') then LELQL else LELQL' fi) .
 op $reorder : NeSetOfListOfList{Limatrix} ->  NeSetOfListOfList{Limatrix} . *** reorder a lists of lists of matrices (views)
 eq $reorder(LELQL) = reorder(0,LELQL) . 
 eq $reorder(LELQL U NeSLELQL) = $reorder(LELQL) U $reorder(NeSLELQL) . 
 *** single canonization step (builds on $minGtIdxNet) -- acts recursively (see case 5 of $canonizeP)
 op canonizeP : NeListOfList{Limatrix} Place NePlist -> NeSetOfListOfList{Limatrix} .
 eq canonizeP(NeLELQL, P, NeL) = $canonizeP(NeLELQL, P, $minGtIdxNet(NeLELQL, P), NeL) .
 op $canonizeP : NeListOfList{Limatrix} Place Pset NePlist -> SetOfListOfList{Limatrix} .
 eq [case1] : $canonizeP(NeLELQL, P, emptyPset, NeL) = NeLELQL . *** base case 1
 eq [case2] : $canonizeP(NeLELQL, P, P, NeL) = NeLELQL . *** base case 2
ceq [case3] : $canonizeP(NeLELQL, P, P', NeL) = swap(NeLELQL, P, P') if P =/= P' . *** base case 3  
 eq [case4] : $canonizeP(NeLELQL, P, P U NeP, NeL) = NeLELQL U $canonizeP(NeLELQL, P, NeP, NeL) . *** P is present: we add the current config.
 eq [case5] : $canonizeP(NeLELQL, P, P' U NeP, NeL) = canonize(swap(NeLELQL, P, P'), NeL) U $canonizeP(NeLELQL, P, NeP, NeL) [owise] .
endfm