in IMATRIX
in ../shared/MAP+

*** defines (possibly nested) sortable lists of local incidence matrices (representing a PT systems, when abstracting from T names)
fmod NESTED-MATRIX-LIST is 
  pr COMP-NESTED-LIST{Limatrix+<}  * (sort List{Limatrix+<}  to List{Limatrix}, sort NeList{Limatrix+<}  to NeList{Limatrix},  op nil to emptyListQL ,
                                    sort ListOfList{Limatrix+<} to ListOfList{Limatrix}, sort NeListOfList{Limatrix+<} to NeListOfList{Limatrix},
                                    sort Elist{Limatrix+<} to  Elist{Limatrix}) .
 endfm 

*** trivial view to a nested list of matrices
view NestedMatList from TRIV to NESTED-MATRIX-LIST is 
 sort Elt to ListOfList{Limatrix} .
endv

view NestedMatList< from STRICT-TOTAL-ORDER to NESTED-MATRIX-LIST is 
 sort Elt to ListOfList{Limatrix} .
 vars X Y : Elt .
 op X < Y to term lex(0, X, Y) . 
endv


fmod PT-NET is
 inc MAP+{Tran,Imatrix} * (sort Map{Tran,Imatrix} to Net, sort Entry{Tran,Imatrix} to ImatrixT, op emptyM to emptyN) .
 
 pr SORTABLE-LIST{Tran<}  * (sort List{Tran<} to Tlist, sort NeList{Tran<} to NeTlist, op nil to emptyTlist ) .
 pr SORTABLE-LIST{Place<} * (sort List{Place<} to Plist, sort NeList{Place<} to NePlist, op nil to emptyPlist ) .
 pr NESTED-MATRIX-LIST .
 pr ATYPE .
 pr PAIR{Pset, Nat} . *** multiple return value (defined for convenience)

 var  N : Net .
 vars T T' : Tran .
 vars P P' : Place .
 vars Y J  : Nat .
 vars K K' : NzNat .
 vars I O H B : Pbag .
 vars Q Q' : Imatrix .
 
 vars S S' SP : Pset . 
 vars L L1 : Plist .
 vars W W' :  String .
 var F :  Bool .
 
 *** vars QL QL' : List{Imatrix} .
 vars QL QL' : Limatrix .
 vars LQL LQL'  : List{Limatrix} .
 vars ELQL ELQL' : Elist{Limatrix} .
 vars LELQL LELQL' : ListOfList{Limatrix} .
 var A :  Atype .
 *** vars BL BL' : List{Pbag} . 
 var E : ImatrixT .
 var LB :  List{Nat,Place} .
 
 *** eq T |-> [I,I,H] = emptyN [metadata "null t"] . *** transitions not changing the marking are erased

 op welldef : Net -> Bool .
 eq welldef(N) = N =/= emptyN and-then repeatedKeys?(N) == false . 
 
 ops In Out Inh : Net Tran -> [Pbag] . 
 eq In(T |-> Q ; N, T) = I(Q) .
 eq Out(T |-> Q ; N, T) = O(Q) .
 eq Inh(T |-> Q ; N, T) = H(Q) .

 op dead : ImatrixT -> Bool .  *** checks for structurally dead transitions 
 eq dead(T |-> [K . P + I, O, K' . P + H]) = K >= K' [metadata "dead t"] .
 eq dead(Q:ImatrixT) = false [owise] .

 op in :  Net Place -> Bool . *** test the existence of a place
ceq in(T |-> Q ; N, P) = true if in (Q, P) .
 eq in(N, P) = false [owise] .

 op in :  Net Tran -> Bool . *** test the existence of a transition
 eq in(N, T) = $hasMapping(N, T) .

 op places : Net -> Pset .
 eq places(N) = $places(N, emptyPset) .  
 op $places : Net Pset -> Pset . 
 eq $places(emptyN, S) = S . 
 eq $places(T |-> Q ; N, S) = $places(N, S U places(Q)) .

 op placeList : Net -> Plist . *** returns the sorted list of places of a net
 eq placeList(N) = $makePlist(places(N),emptyPlist) .
 op $makePlist : Pset Plist -> Plist . 
 eq $makePlist(emptyPset, L) = sort(L) . 
 eq $makePlist(P U S, L) = $makePlist(S, P L) . 

 var TL : Tlist .
 op tranList : Net -> Tlist .  *** returns the sorted list of transitions
 eq tranList(N) = $makeTlist(N,emptyTlist) .
 op $makeTlist : Net Tlist -> Tlist . 
 eq $makeTlist(emptyN, TL) = sort(TL) . 
 eq $makeTlist(T |-> Q ; N, TL) = $makeTlist(N, T TL) . 

 op places : Net Atype -> Pset . *** return the places of a given type 
 eq places(N, A) = $places(N, A, emptyPset) .
 op $places : Net Atype Pset -> Pset .
 eq $places(emptyN, A, S) = S .
 eq $places(T |-> Q ; N, A, S) = $places(N, A, S U support(Q(A)) ) . 

 op prefix : Net String -> Net .
 eq prefix(N, W) = prefix&offset(N, 0, W) .
 op prefix&offset : Net Nat String -> Net .
 eq prefix&offset(emptyN, Y, W) = emptyN .
 eq prefix&offset(N ; T |-> Q, Y, W) = prefix&offset(T, Y, W) |-> prefix&offset(Q, Y, W) ; prefix&offset(N, Y, W) .
 
 **** canonization part

 *** gets a sorted list of matrices (better, list-views of matrices) out of a net by sorting on the basis of bag weights
 op matListS : Nat Net  -> List{Limatrix} .  
 eq matListS(Y, N) = sort(Y, $matListS(Y, N, emptyListQL)) .
 op $matListS : Nat Net List{Limatrix} -> List{Limatrix} .
 eq $matListS(Y, emptyN, LQL) = LQL .
ceq $matListS(Y, T |-> Q ; N, LQL) = $matListS(Y, N, LQL sort(Y, LQL' )) if LQL' := toList(Q) /\ null(LQL') == false .
 eq $matListS(Y, T |-> Q ; N, LQL) = $matListS(Y, N, LQL) [owise] .
 

 *** operators to swap pairs of elements (various/overloaded versions)
 op swap : Net Place Place -> Net . 
ceq swap(T |-> Q ; N, P, P') = T |-> swap(Q, P, P') ; swap(N, P, P') if P =/= P' .
 eq swap(N, P, P') = N [owise] .

 op replace : Net Place Place -> Net .  *** replace the first places with the 2nd one in a net
 eq replace(T |-> Q ; N, P, P') = T |-> replace(Q, P, P') ; replace(N, P, P') .
 eq replace(emptyN, P, P') = emptyN .

 op swapLM : List{Limatrix} Place Place -> List{Limatrix} . *** note that "renaming" swap is necessary 
 eq swapLM(emptyListQL, P, P') = emptyListQL .
 eq swapLM(QL LQL, P, P') = swap(QL, P, P') swapLM(LQL, P, P') .

 op swap : ListOfList{Limatrix} Place Place -> ListOfList{Limatrix} .
 eq swap({ }, P, P') = { } .
 eq swap({LQL} LELQL, P, P') = {swapLM(LQL, P, P')} swap(LELQL, P, P') .

 *** transitions
 op swap : Net Tran Tran -> Net .  *** swaps two transitions in a net
 eq swap(T |-> Q ; N, T, T') = T' |-> Q ; swap(N, T, T') . 
 eq swap(T |-> Q ; N, T', T) = T' |-> Q ; swap(N, T', T) .
 eq swap(N, T, T') = N [owise] .
 
 op replace : Net Tran Tran -> [Net] .  *** replace the first transition with the 2nd one in a net
 eq replace(T |-> Q ; N, T, T') = T' |-> Q ; N .
 eq replace(N, T, T') = N [owise] .
 
endfm