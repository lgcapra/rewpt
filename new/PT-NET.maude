in IMATRIX
in ../shared/MAP+
in ../shared/COMP-PAIR-LIST

fmod PT-NET is
 inc MAP+{Tran,Imatrix} * (sort Map{Tran,Imatrix} to Net, sort Entry{Tran,Imatrix} to ImatrixT, op emptyM to emptyN) .
 
 pr SORTABLE-LIST{Tran<}  * (sort List{Tran<} to Tlist, sort NeList{Tran<} to NeTlist, op nil to emptyTlist ) .
 pr SORTABLE-LIST{Place<}  * (sort List{Place<} to Plist, sort NeList{Place<} to NePlist, op nil to emptyPlist ) .
 *** pr SORTABLE-LIST{Imatrix<'} * (sort List{Imatrix<'} to List{Imatrix}, sort NeList{Imatrix<'} to NeList{Imatrix}, op nil to emptyListQ ) .
 pr COMPARABLE-LIST{Limatrix<}  * (sort List{Limatrix<}  to List{Limatrix}, sort NeList{Limatrix<}  to NeList{Limatrix},  op nil to emptyListLQ ) .
 pr COMPARABLE-LIST{Limatrix<1} * (sort List{Limatrix<1} to List{Limatrix}, sort NeList{Limatrix<1} to NeList{Limatrix},  op nil to emptyListLQ, 
                                   op sort to sort1, op $sort to $sort1, op $split to $split1, op merge to merge1, op $merge to $merge1 ) .
 
 pr ATYPE .

 var  N : Net .
 vars T T' : Tran .
 vars P P' : Place .
 vars Y J  : Nat .
 vars K K' : NzNat .
 vars I O H B : Pbag .
 vars Q Q' : Imatrix .
 vars LQ LQ' : Limatrix .
 
 vars S SP : Pset . 
 var W :  String .
 var F :  Bool .
 *** vars QL QL' : List{Imatrix} .
 vars LQL LQL' : List{Limatrix} .
 
 var A :  Atype .
 *** vars BL BL' : List{Pbag} . 
 var L' : Tlist .
 var E : ImatrixT .
 
 eq T |-> [I,I,H] = emptyN [metadata "null t"] . *** transitions not changing the marking are erased

 op welldef : Net -> Bool .
 eq welldef(N) = N =/= emptyN and-then repeatedKeys?(N) == false . 
 
 ops In Out Inh : Net Tran -> [Pbag] . 
 eq In(T |-> Q ; N, T) = I(Q) .
 eq Out(T |-> Q ; N, T) = O(Q) .
 eq Inh(T |-> Q ; N, T) = H(Q) .

 op dead : ImatrixT -> Bool .  *** checks for structurally dead transitions 
 eq dead(T |-> [K . P + I, O, K' . P + H]) = K >= K' [metadata "dead t"] .
 eq dead(Q:ImatrixT) = false [owise] .

 op in :  Net Place -> Bool . *** test the existence of a place
ceq in(T |-> Q ; N, P) = true if in (Q, P) .
 eq in(N, P) = false [owise] .

 op in :  Net Tran -> Bool . *** test the existence of a transition
 eq in(N, T) = $hasMapping(N, T) .

 op places : Net -> Pset .
 eq places(N) = $places(N, emptyPset) .  
 op $places : Net Pset -> Pset . 
 eq $places(emptyN, S) = S . 
 eq $places(T |-> Q ; N, S) = $places(N, S U places(Q)) .

 op placeList : Net -> Plist . *** returns the sorted list of places of a net
 eq placeList(N) = $makePlist(places(N),emptyPlist) .
 var L L1 : Plist .
 op $makePlist : Pset Plist -> Plist . 
 eq $makePlist(emptyPset, L) = sort(L) . 
 eq $makePlist(P U S, L) = $makePlist(S, P L) . 

 op tranList : Net -> Tlist .  *** returns the sorted list of transitions
 eq tranList(N) = $makeTlist(N,emptyTlist) .
 op $makeTlist : Net Tlist -> Tlist . 
 eq $makeTlist(emptyN, L') = sort(L') . 
 eq $makeTlist(T |-> Q ; N, L') = $makeTlist(N, T L') . 

 op places : Net Atype -> Pset . *** return the places of a given type 
 eq places(N, A) = $places(N, A, emptyPset) .
 op $places : Net Atype Pset -> Pset .
 eq $places(emptyN, A, S) = S .
 eq $places(T |-> Q ; N, A, S) = $places(N, A, S U support(Q(A)) ) . 
 
 **** canonization part

 *** gets a sorted adjacency list of a given type (i,o,h) out of a net (NOTE builds on the operator above, i.e., on the order defined on inc. matrices)
 *** op makeAdjListS : Net Atype -> List{Pbag} .
 *** eq makeAdjListS(N, A) = $makeAdjListS(makeAdjList(N), A, emptyListBagP) . *** the list (of matrices) is ordered -- consequently the particular lists are
 *** op $makeAdjListS : List{Imatrix} Atype List{Pbag} -> List{Pbag} .
 *** eq $makeAdjListS(emptyListQ, A, BL) = BL .
*** ceq $makeAdjListS(Q QL, A, BL) = $makeAdjListS(QL, A, BL) if Q(A) == nilP . *** optimization . 
 *** eq $makeAdjListS(Q QL, A, BL) = $makeAdjListS(QL, A, BL Q(A) ) [owise] . 
 
 *** makes an unsorted adjacency list of a given type (i,o,h) out of a net
 *** op makeAdjList : Net Atype -> List{Pbag} .  
 *** eq makeAdjList(N, A) = $makeAdjList(N, A, emptyListBagP) .
 *** op $makeAdjList : Net Atype List{Pbag} -> List{Pbag} .
 *** eq $makeAdjList(emptyN, A, BL) = BL .
 *** eq $makeAdjList(T |-> Q ; N, A, BL) = $makeAdjList(N, A, BL Q(A))  .
 
 *** gets a sorted list of matrices (better, view-lists of matrices) out of a net by sorting on the basis of bag weights
 op makeAdjList1s : Net String -> List{Limatrix} .  
 eq makeAdjList1s(N, W) = sort($makeAdjList1s(N, W, emptyListLQ)) .
 op $makeAdjList1s : Net String List{Limatrix} -> List{Limatrix} .
 eq $makeAdjList1s(emptyN, W, LQL) = LQL .
 eq $makeAdjList1s(t(Y, W) |-> Q ; N, W, LQL) = $makeAdjList1s(N, W, LQL toListS1(Q))  .
 eq $makeAdjList1s(T |-> Q ; N, W, LQL) = $makeAdjList1s(N, W, LQL)  [owise] .
 op makeAdjList1s : Net -> List{Limatrix} . *** consider empty labels
 eq makeAdjList1s(N) = makeAdjList1s(N, "") .
 *** gets the matrices with components having the same weights from the head of a list
 op headblock : List{Limatrix} -> List{Limatrix} . 
 eq headblock(LQL) = $headblock(LQL, emptyListLQ) .
 op $headblock : List{Limatrix} List{Limatrix} -> List{Limatrix} . *** auxiliary op
 eq $headblock(LQ LQL, emptyListLQ) = $headblock(LQL, LQ) .
 var NeL : NeList{Limatrix} .
ceq $headblock(LQ LQL, NeL) = $headblock(LQL, NeL LQ) if cmp1(head(NeL), LQ) == 0 .
 eq $headblock(LQL, LQL') = LQL' [owise] .
 
 *** op regroup : List{Limatrix} -> List{List{Limatrix}} .
 
 
 *** operators to swap pairs of elements (various versions)
 op swap : Net Place Place -> Net . 
 eq swap(T |-> Q ; N, P, P') = T |-> swap(Q, P, P') ; swap(N, P, P') .
 eq swap(emptyN, P, P') = emptyN .

 *** swaps two places in an adjacency list and sorts the resulting list
 *** op swap : List{Pbag} Place Place -> List{Pbag} . *** swaps two places in an adjacency list
 *** eq swap(emptyListBagP, P, P') = emptyListBagP .
 *** eq swap(B BL, P, P') = swap(B, P, P') swap(BL, P, P') . 

 op replace : Net Place Place -> Net .  *** replace the first places with the 2nd one in a net
 eq replace(T |-> Q ; N, P, P') = T |-> replace(Q, P, P') ; replace(N, P, P') .
 eq replace(emptyN, P, P') = emptyN .

 *** transitions
 op swap : Net Tran Tran -> Net .  *** swaps two transitions in a net
 eq swap(T |-> Q ; N, T, T') = T' |-> Q ; swap(N, T, T') . 
 eq swap(T |-> Q ; N, T', T) = T' |-> Q ; swap(N, T', T) .
 *** eq swap((T |-> Q, T' |-> Q', N), T, T') = T |-> Q', T' |-> Q, N . 
 *** eq swap((T |-> Q, N), T, T') = T' |-> Q, N [owise] . 
 *** eq swap((T |-> Q, N), T', T) = T' |-> Q, N [owise] . 
 eq swap(N, T, T') = N [owise] .
 op replace : Net Tran Tran -> [Net] .  *** replace the first transition with the 2nd one in a net
 eq replace(T |-> Q ; N, T, T') = T' |-> Q ; N .
 eq replace(N, T, T') = N [owise] .
 
 
 *** base operator for the canonization algorithm
 op minGtIdx : Pbag Place Plist -> Plist .   *** Given B, P, LP, if A = {P' in B s.t. index(P') >= index(P) and LP != 0 => P' in LP} is not 0 then returns the elements {P'} of A with MINIMAL-weight s.t. if B[P] > 0 then B[P'] <= B[P] (possibly including P).
                                             *** If A is empty returns P if B[P] > 0, otherwise 0 .
                                             *** If the retuned list's size is > 1 the 2nd el. is that with the greatest idx (also if P is not in the list!) 
 op _inNotEmpty_ : Place Plist -> Bool . *** defined for efficiency (occurs is less efficient)
 eq P inNotEmpty emptyPlist = true .
 eq P inNotEmpty L P L1 = true .
 eq P inNotEmpty L = false [owise] .
 
 eq minGtIdx(K . P + B, P, L) = $minGtIdx(B, P, K, L, true) . *** P is in B
 eq minGtIdx(B, P, L) = $minGtIdx(B, P, 10000000000000, L, false)  [owise] . *** P is not in B
 op $minGtIdx : Pbag Place NzNat Plist Bool -> NePlist .
ceq $minGtIdx( K' . p(Y,W)  + B, p(J,W), K, L, F) = $minGtIdx(B, p(Y,W), K', L, true) if Y > J /\ K' < K /\ p(Y,W) inNotEmpty L . *** found el. with idx > and weight <
ceq $minGtIdx( K . p(Y,W)  + B, p(J,W), K, L, F)  = $minGtIdx(B, p(J,W), K, L, F ) p(Y,W)  if Y > J /\ p(Y,W) inNotEmpty L [owise].  *** found el. with idx > and weight =
 eq $minGtIdx(B, P, K, L, F) = if F then P else emptyPlist fi [owise] .

endfm