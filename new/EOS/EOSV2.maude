in BAG-SPLIT

*** this definition of EOS uses an alternative (simpler) definition of object-net types and introduces
*** a synchronization map between EOS transitions and object-net transitions 
*** trivial view of a PT-Net
view Net from TRIV to PT-NET is 
 sort Elt to Net .
endv

*** net-types are defined as a map from strings (place-labels) to nets
fmod NET-TYPES is
   pr MAP+{String,Net} * (sort Map{String,Net} to NeTypeS, sort Entry{String,Net} to EntrySN, op emptyM to emptyNeTypeS) .
   var L : String .
   var N : Net .
   var T : NeTypeS .
   op welldef : NeTypeS -> Bool . *** characterizes well defined net-types
 ceq welldef(T) = false if repeatedKeys?(T)  .
 ceq welldef(L |-> N ; T) = false if not(welldef(N)) .
  eq welldef(T) = true [owise] .
endfm


*** this module defines the synchronization between EOS transitions and (sets of) object-net transitions
fmod SYNCHRO is
  pr SET+{Tran} . 
  pr MAP+{Tran,Set{Tran}} * (sort Map{Tran,Set{Tran}} to Syncmap, sort Entry{Tran,Set{Tran}} to EntrySync, op emptyM to emptySync).
endfm


*** structure of a system-net
fmod EOS-NET is
   pr PT-NET .
   pr NET-TYPES .
   pr SYNCHRO .
   sort Sysnet .
   op ___ : Net NeTypeS Syncmap -> [Sysnet] [ctor] . *** juxtaposition of a net and net-types -- note the use of a kind
   op net : Sysnet -> Net .
   op netypes : Sysnet -> NeTypeS .
   op synchro : Sysnet -> Syncmap .
   vars N N'  : Net .
   vars S S' : Sysnet .
   vars T T' : NeTypeS .
   vars M M' : Syncmap .
   var P : Place .
   eq net(N T M) = N .
   eq netypes(N T M) = T .
   eq synchro(N T M) = M .
 cmb N T M : Sysnet if welldef(N) and-then welldef(T) and-then not(repeatedKeys?(M)) . *** charcterization of well-formed EOS nets
  endfm

*** marked system-net, i.e., EOS
 fmod EOSYS is
   pr EOS-NET + (MAP-PROD{Place,Bag{Bag{Place}}} + BAG-SPLIT{Bag{Place}} + BAG-DECOMP{Place}) * 
                               (op nil : -> Bag{Place} to emptyPbag, 
                                op nil : -> Bag{Bag{Place}} to emptyPbag2, op emptySetBag to emptySetPbag2,
                                op emptyS to emptySetPbag2, op emptyM to emptyEosMark, 
                                op emptyMapS to emptyMapSetPbag2, op emptySetM to emptySetMapPbag2,
                                op emptySetBag2 to emptySetPbag2, op emptyBag2 to emptyPbag2
                                ***, sort Map{Place,Bag{Bag{Place}}} to Sysnetmark, sort Entry{Place,Bag{Bag{Place}}} to SysnetmarkP,
                               ) .  

 
   sort Eosystem .
   *** op __ : Sysnet Sysnetmark -> Eosystem [ctor] . 
   op __ : Sysnet Map{Place,Bag{Bag{Place}}} -> Eosystem [ctor] . 
   op sysnet  : Eosystem -> Sysnet .
   *** op sysmark : Eosystem -> Sysnetmark .
   op sysmark : Eosystem -> Map{Place,Bag{Bag{Place}}} .
   
   var E : Eosystem .
   var S : Sysnet .
   var M : Map{Place,Bag{Bag{Place}}} .
   var MS :  Map{Place,Set{Bag{Bag{Place}}}} .
   var SM :  Set{Map{Place,Bag{Bag{Place}}}} .
   vars B B' : Bag{Place} .
   var BB : Bag{Bag{Place}} .
   var P : Place .
   var T : Tran .
   vars K K' : NzNat .
   eq sysnet(S M)  = S .
   eq sysmark(S M) = M .

   *** the following operators help calculate the firing instances of an EOS transition

   *** calculates the set of EOS firing instance (each denoted by a map (input) places-bags of Pbags)
   *** given an Input function (i.e., a bag) and an EOS marking (a map places-bags of Pbags)
   op firinginstances : Bag{Place} Map{Place,Bag{Bag{Place}}}  -> [Set{Map{Place,Bag{Bag{Place}}}}] . *** undefined if the map is empty
   eq firinginstances(B, M) = prod(localinstances(B, M)) .
   op localinstances  : Bag{Place} Map{Place,Bag{Bag{Place}}}  -> Map{Place,Set{Bag{Bag{Place}}}} .
   eq localinstances(B, M) = $localinstances(B, M, emptyMapSetPbag2) .
   op $localinstances : Bag{Place} Map{Place,Bag{Bag{Place}}}  Map{Place,Set{Bag{Bag{Place}}}} -> Map{Place,Set{Bag{Bag{Place}}}} .
   eq $localinstances(emptyPbag, M, MS) = MS .
   eq $localinstances(K . P + B, (P |-> BB ; M), MS) = $localinstances(B, M, (MS ; P >> split(BB, K))) .  *** core equation: place P of I(O) inc. matrix is marked
   eq $localinstances(K . P + B, M, MS) = emptyMapSetPbag2 [owise].  *** place P of I(O) inc. matrix is NOT marked
   *** main version of firinginstances (builds on the overloaded operator above) 
   op firinginstances : Eosystem Tran -> [Set{Map{Place,Bag{Bag{Place}}}}] .
   eq firinginstances(E, T) = firinginstances(I(net(sysnet(E))[T]), sysmark(E)) . 

   *** distributes the pre-calculated sum of markings corresponding to an EOS firing instance (1st arg)
   *** to the output places (2nd arg); the places of two bags (i.e., the firing instance and the ouput places) are assumed of the same type
   *** builds on decompose(sub) defined in BAG-SPLIT 
   op distribute : Bag{Place} Bag{Place} ->  [Set{Map{Place,Bag{Bag{Place}}}}] . *** undefined if the 2nd arg is null
endfm