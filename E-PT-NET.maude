in E-TMATRIX
in shared/MAP-SET
in shared/PAIR

*** PT net signature using the extended matrix representation including flush arcs and a description pf place capacity 
fmod E-PT-NET{L :: TRIV, PL :: TRIV} is
 generated-by MAP-SET{L,Ematrix{PL}} * (sort Map{L,Ematrix{PL}} to Net, sort Entry{L,Ematrix{PL}} to Tran, op emptyM to emptyNet,
                                        op emptyS to emptySlab) .

 pr PAIR{Pbag{PL}, Bool} * (sort Pair{Pbag{PL}, Bool} to Pair{Pbag, Bool}) . *** encodes the firing outcome considering place capacity 
 sort Enet . ***
 subsort Net < Enet . 
 op _c:_ : Net Pbag  -> Enet [ctor prec 73] . *** lesser priority than Net juxtaposition
 eq N c: nilP = N . *** all places have inf. capacity

 vars L L' : L$Elt . vars T T' : Tran . vars N N' : Net . var EN : Enet .
 vars P P' : Place . vars M I O H C B B' : Pbag . vars K K'  : NzNat .
 var EQ : Ematrix . var Q : Tmatrix . var  S : Pset . var F : FlushArcs .
 *** accessor methods
 ops l lab : Tran -> L$Elt .
 eq lab(T) = l(T) .
 op q : Tran -> Ematrix .
 eq l(L |-> EQ) = L .
 eq q(L |-> EQ) = EQ .
 op m : Tran -> Tmatrix .
 eq m(T) = m(q(T)) . *** the associated Tmatrix
 op f : Tran -> FlushArcs .
 eq f(T) = f(q(T)) . *** the associated flushing arcs (is any)
 ops I O H : Tran -> Pbag .
 eq I(T) = I(m(T)) .
 eq O(T) = O(m(T)) .
 eq H(T) = H(m(T)) .
 op cap : Enet -> Pbag . *** capacity
 eq cap(N c: C) = C .
 eq cap(N) = nilP .
 op net : Enet -> Net .
 eq net(N c: C) = N .
 eq net(N) = N .
 
 eq L |-> [nilP, nilP, nilP] = emptyNet . *** removes isolated transitions
*** eq L |-> [M,M,H] = emptyNet [metadata "null t"] . *** removes transitions not changing the marking

op dead : Tran -> Bool .  *** checks for structurally dead transitions 
eq dead(L |-> EQ) = dead(m(EQ)) .
ceq L |-> EQ = emptyNet if dead(m(EQ)) . *** removes dead transitions
 *** doesn't consider the capacity
 op enabled : Tran Pbag -> Bool .
 eq enabled(L |-> EQ, M) =  enabled(EQ, M) .
 *** doesn't consider enabling and capacity, but considers flush arcs
 op firing : Tran Pbag -> Pbag .
 eq firing(L |-> EQ, M) = firing(EQ, M) .
  *** considers the capacity (2nd par)
 op firing : Tran Pbag Pbag -> Pair{Pbag, Bool} .
ceq firing(T, C, M) = < B ; C >= B > if B := firing(T, M) . 
  *** test the existence of a place (of course, the capacity bag is not considered) 
 op in : Net Place -> Bool . 
ceq in(L |-> EQ ; N, P) = true if in (EQ, P) .
 eq in(N, P) = false [owise] .
 *** test the existence of a transition
 op in :  Enet L$Elt -> Bool . 
 eq in(EN, L) = $hasMapping(EN, L) .
*** check the existence of a place of given type
 ops isIn isOut isH : Net Place -> Bool . 
ceq isIn(L |-> EQ ; N, P) = true if isIn(EQ, P) .
 eq isIn(N, P) = false [owise] .
ceq isOut(L |-> EQ ; N, P) = true if isOut(EQ, P) .
 eq isOut(N, P) = false [owise] .
ceq isH(L |-> EQ ; N, P) = true if isH(m(EQ), P) .
 eq isH(N, P) = false [owise] .
 *** returns the places (of course, the capacity bag is not considered)
 op places : Net -> Pset [memo] . 
 eq places(N) = $places(N, emptyPset) .  
 op $places : Net Pset -> Pset . 
 eq $places(emptyNet, S) = S . 
 eq $places(L |-> EQ ; N, S) = $places(N, S U places(EQ)) .

 op transitions : Enet -> Set{L} .
 eq transitions(EN) = keySet(EN) .

endfm
