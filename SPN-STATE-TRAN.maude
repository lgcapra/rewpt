*** state-transition representation for SPN pointing out state-transitions due to rewrite rules 
in SPN
in MATCH

*** this module defines "triplets" (sort StateTran{X}) composed of a match and a pair (sort Rate{X}) built of a target state (sort X$elt) and a rate
fmod STATE-TRAN{X :: TRIV} is
   pr MATCHES .
   pr FLOAT .
   pr PAIR{X,Float} * (sort Pair{X,Float} to Rate{X}, op <_;_> to _:_, op 1st to target, op 2nd to rate) .
   
   sort StateTran{X} .
   var M : Matches . var X : X$Elt . var F : Float .
   op _-->_ : Matches Rate{X} -> StateTran{X} [ctor prec 50] .
   *** getters
   op match  : StateTran{X} -> Matches .
   eq match(M --> X : F) = M . 
   op target : StateTran{X} -> X$Elt .
   eq target(M --> X : F) = X . 
   op rate   : StateTran{X} -> Float .
   eq rate(M --> X : F) = F . 
endfm

*** views to STATE-TRAN

view StateTran{X :: TRIV} from TRIV to STATE-TRAN{X} is 
   sort Elt to StateTran{X} . 
endv

view Rate{X :: TRIV} from TRIV to STATE-TRAN{X} is 
   sort Elt to Rate{X} . 
endv

*** this module provides an operator to calculate the cumulative rates from a set of StateTran (i.e, triplets defining each a state transition given a match)
fmod STATE-TRAN-RATE{X :: TRIV} is
   pr SET+{StateTran{X}}  * (op emptyS : -> Set{StateTran{X}} to noStateTran) .
   pr SET+{Rate{X}} * (op emptyS : -> Set{Rate{X}} to noRate) .
   var ST : Set{StateTran{X}} . var SR : Set{Rate{X}} .
   var T : StateTran{X} . var X : X$Elt . var F : Float .
   op cumrate : Set{StateTran{X}} ->  Set{Rate{X}} .
   eq cumrate(ST) = $cumrate(ST, noRate) .
   op $cumrate : Set{StateTran{X}} Set{Rate{X}} -> Set{Rate{X}} .
  ceq $cumrate(T U ST, (X : F) U SR ) = $cumrate(ST, (X : F + rate(T)) U SR ) if target(T) = X .
   eq $cumrate(T U ST, SR ) = $cumrate(ST, (target(T) : rate(T)) U SR ) [owise] .
   eq $cumrate(noStateTran, SR ) = SR .
endfm

*** this module defines the syntax of the redundant state representation used for extracting a CTMC from a rewritable SPN
*** for convenience, three different state-transitions are defined: those changing the marking, the net structure, and both of them 
fmod SPN-STATE-TRAN is 
  pr STATE-TRAN-RATE{System} * (op noStateTran to noStateTranS,  op noRate to noRateS) .
  pr STATE-TRAN-RATE{Net} * (op noStateTran to noStateTranN,  op noRate to noRateN) .
  pr STATE-TRAN-RATE{Pbag{Nat}} * (sort Rate{Pbag{Nat}} to Rate{Pbag}, sort StateTran{Pbag{Nat}} to StateTran{Pbag},
            sort Set{Rate{Pbag{Nat}}} to Set{Rate{Pbag}}, sort NeSet{Rate{Pbag{Nat}}} to NeSet{Rate{Pbag}},
            sort Set{StateTran{Pbag{Nat}}} to Set{StateTran{Pbag}}, sort NeSet{StateTran{Pbag{Nat}}} to NeSet{StateTran{Pbag}}, 
            op noStateTran to noStateTranM,  op noRate to noRateM) .

  sort SpnStateTran .
  var T  : Tran .
  var N  : Net .
  var RM : Set{Rate{Pbag}} .
  var RN : Set{Rate{Net}} .
  var RS : Set{Rate{System}} .
  var R :  Float .
  vars M M' : Pbag .
  
  *** System (SPN) description pointing out state-transitions
  op NET:_ M:_ REWM:_REWN:_REWS:_ : Net Pbag Set{Rate{Pbag}} Set{Rate{Net}} Set{Rate{System}} -> SpnStateTran [ctor  format (n d n d n d n d n d d)] .
  *** getters
  op net : SpnStateTran -> Net .
  eq net(NET: N M: M REWM: RM REWN: RN REWS: RS) = N .
  op m : SpnStateTran -> Pbag .
  eq m(NET: N M: M REWM: RM REWN: RN REWS: RS) = M .
  op rewN : SpnStateTran -> Set{Rate{Net}} .
  eq rewN(NET: N M: M REWM: RM REWN: RN REWS: RS) = RN .
  op rewM : SpnStateTran -> Set{Rate{Pbag}} .
  eq rewM(NET: N M: M REWM: RM REWN: RN REWS: RS) = RM .
  op rewS : SpnStateTran -> Set{Rate{System}} .
  eq rewS(NET: N M: M REWM: RM REWN: RN REWS: RS) = RS .
  
  *** provides the usual description
  op toSystem : SpnStateTran -> System .
  eq toSystem(NET: N M: M REWM: RM REWN: RN REWS: RS) = N M .
endfm
