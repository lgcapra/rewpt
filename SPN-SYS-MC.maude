in SPN

*** rewrite rule encoding for deriving a CTMC


*** match for the firing rule
fmod FIREMATCH is
 pr SPN .
 sort Firematch .
 op <_,_,_> : Net Tran Pbag -> Firematch [ctor] .   
endfm


*** default view
view Firematch from TRIV to FIREMATCH is 
 sort Elt to Firematch . 
endv

*** match for the merge rule
fmod MERGEMATCH is
 pr SPN .
 sort Mergematch .
 op <_,_,_,_> : Net Tran Tran Pbag -> Mergematch [ctor] .   
endfm


*** default view
view Mergematch from TRIV to MERGEMATCH is 
 sort Elt to Mergematch . 
endv

mod SPN-SYS-MC is
 ***inc SPN . 
 inc SET+{Firematch} * (op emptyS to noMatch) .
 inc MAP+{Pbag,Float} * (op emptyM to  emptyMTR) .
 
  vars N  N' : Net .
  var S : System .
  var X : Set{Firematch} .
  vars M M' : Pbag .
  vars P P' : Place . 
  var L : Tlab .
  var Q : Tmatrix .
  vars T T' : Tran .
  vars K K' D : NzNat .
  var R : Float .
  var RS : Map{Pbag,Float} .
  
 *** firing rule matches: STESSA struttura per ogni regola
 op firing-matches : System -> Set{Firematch} [memo].
 eq firing-matches(S) = $firing-matches(S, noMatch) .
 op $firing-matches : System Set{Firematch} -> Set{Firematch} .
 ceq $firing-matches(S, X) = $firing-matches(S, < N,T,M > U X) if (T ; N) M := S /\ enabled(T, M) /\ < N,T,M > in X = false .
 eq $firing-matches(S, X) = X [owise] .
  *** rule application
 op firing-app : Firematch -> System .
 eq firing-app(< N,T,M >) = (T ; N) firing(T, M) .
 *** optimized
 op firing-app : Tran Pbag -> Pbag .
 eq firing-app(T, M) = firing(T, M) .
 *** state transitions due to the rule firing -- grouped by rate
  op firing-state-trans : System -> Map{Pbag,Float} [memo] .
  eq firing-state-trans (S) = $firing-state-trans (firing-matches(S),  emptyMTR) .
  op $firing-state-trans : Set{Firematch} Map{Pbag,Float} -> Map{Pbag,Float} .
  eq $firing-state-trans (noMatch, RS) = RS .
 ceq $firing-state-trans (< N,T,M > U X, M' |-> R ; RS) =  $firing-state-trans (X, M' |-> firing-rate(T, M) + R ; RS) if  M' := firing-app(T, M) .
  eq $firing-state-trans (< N,T,M > U X, RS) =  $firing-state-trans (X, firing-app(T,M) |-> firing-rate(T, M) ; RS) [owise] .

 sort SysState .
 *** description of a PT system pointing out the state-transitions, gathered by firing-rate
 op SYS:_ STRAN:_ : System Map{Pbag,Float} -> SysState [ctor format (n d n d d)] .
 *** translates a System term into a SysState
 op toSysState : System -> SysState .
 eq toSysState(S) = SYS: S STRAN: firing-state-trans (S) . 
*** firing rule encoded according to the new state representation
rl [firing] : SYS: N M STRAN: (M' |-> R ; RS)  => toSysState(N M') .
 
endm

*** NUOVO APPROCCIO (SIMILE AL PRECEDENTE MA IN GRADO DI CATTURARE MATCH "EQUIVALENTI"): 
**** UNA REGOLA E' CODIFICATA COME UNA COPPIA DI TERMINI (left-hand, right-hand)

*** dichiarare in un file separato
in SPN-SYS

mod SPN-SYS-TO-MC is
    inc SET+{Pair{Firematch,System}} * (op <_;_> : Firematch System -> Pair{Firematch,System} to _-->_, op emptyS to noFireMatchPair) .
    inc SET+{Pair{Mergematch,System}} * (op <_;_> : Mergematch System -> Pair{Mergematch,System} to _-->_, op emptyS to noMergeMatchPair) .
    inc MAP+{Pbag,Float} * (op emptyM to  emptyMTR) .
    vars N  N' : Net .
    vars S S' : System .
    var H : Firematch .
    var X : Set{Pair{Firematch,System}} .
    var Y : Set{Pair{Mergematch,System}} .
    vars M M' : Pbag .
    vars P P' : Place . 
    var L : Tlab .
    var Q : Tmatrix .
    vars T T' : Tran .
    vars K K' D : NzNat .
    var R : Float .
    var E : Nat .
    var W : String .
    **** var RS : Map{Pbag,Float} .
 
  *** firing rule matches: STESSA struttura per ogni regola
  op firing-matches : System -> Set{Pair{Firematch,System}} [memo].
  eq firing-matches(S) = $firing-matches(S, noFireMatchPair) .
  op $firing-matches : System Set{Pair{Firematch,System}} -> Set{Pair{Firematch,System}} .
  ceq $firing-matches(S, X) = $firing-matches(S, (< N,T,M > --> S')  U X) if (T ; N) M := S /\ enabled(T, M) /\ 
         S' := (T ; N) firing(T, M)  /\  (< N,T,M > --> S') in X = false /\ Rate:Float := firing-rate(T, M) .
  eq $firing-matches(S, X) = X [owise] .
 *** merge rule matches: 

  op merge-matches : System -> Set{Pair{Mergematch,System}} [memo].
  eq merge-matches(S) = $merge-matches(S, noMergeMatchPair) .
  op $merge-matches : System Set{Pair{Mergematch,System}} -> Set{Pair{Mergematch,System}} .
  ceq $merge-matches(S, Y) = $merge-matches(S, (< N,T,T',M > --> S')  U Y)  if (N ; T ; T') M := S /\ W := tag(T) /\ W = tag(T') /\ E := pol(T) /\
        E = pol(T') /\ enabled(T, M) = enabled(T', M) /\ S' := (N ; merge(T, T', t(W, rate(T) + rate(T'), E))) M  /\ (< N,T,T',M > --> S') in Y = false /\ Rate:Float := 0.02 .
  eq $merge-matches(S, Y) = Y [owise] .


endm

*** mod HET-LIST is 
***  inc SPN-SYS-TO-MC . 
 
***  sort List . 
***  op nil : -> List . 
***  op _,_ : Universal List -> List [ctor poly (1)] . 
***  var L : List .
***  eq L , nil = L .
***  eq nil , L = L .
*** endm

*** fmod MATCH-CLASS is
***     sort MatchClass .
*** endfm

*** view MatchClass from TRIV to MATCH-CLASS is 
***  sort Elt to MatchClass . 
*** endv

*** fmod MATCH{X :: TRIV} is
***     pr MATCH-CLASS .
***     pr SET+{X} * (op emptyS : -> Set{X} to emptyMatch) .
***     subsort Set{X} < MatchClass .
*** endfm

*** fmod MATCHES is
***     pr LIST{MatchClass} .
*** endfm

*** mod FIRING-MATCHES is  
***     inc MATCHES .
***     inc MATCH{System} .
***  endm
