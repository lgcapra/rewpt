*** def base, senza tutti gli operatori per gestire le etichette "strutturate" dellÃ¬approccio modulare 
in ./shared/BAG-AND-SET
in ./shared/MSET
in PLACE

fmod PBAG{L :: TRIV} is
  pr (BAG-AND-SET{Place{L}}) * ( sort Bag{Place{L}} to Pbag, sort NeBag{Place{L}} to NePbag, 
                           sort  ElBag{Place{L}} to ElPbag, op nil to nilP, 
                           sort  Set{Place{L}}  to Pset, sort NeSet{Place{L}} to NePset, op emptyS to emptyPset) .

    vars I H M : Pbag . vars S S' : Pset .
    vars K K' : NzNat . vars N N'  : Nat .
    var L : L$Elt . var p : Place .
    *** defined here for convenience
    op enabCond : Pbag Pbag Pbag -> Bool . 
    eq enabCond(I, H, M) = I <= M and-then H > M .
    *** checks if some place exceeds its capacity
    op overCap : Pbag -> Bool .
  ceq overCap(M + K . p(L, K')) = true if K > K' .
   eq overCap(M) = false [owise] .
  *** determines the places in a bag with lesser multiplicity among those in a given set that are non-saturated  
   op emin : Pbag NePset -> Pset .
 ceq emin(K . p(L, K') + M, p(L, K') U S) = emin(M, S) if K >= K' . *** filter out saturated places
  eq emin(M, emptyPset) = emptyPset .
  eq emin(M, S U p) = $emin(M, S, p, M[p]) [owise] . 
  op $emin : Pbag Pset Pset Nat -> Pset .
 ceq $emin(M, S, S', N) = S' if S == emptyPset or-else M == nilP .
 ceq $emin(M, p U S, S', N') = if N > N' then $emin(M, S, S', N') else 
                      if N < N' then $emin(M, S, p, N) else $emin(M, S, S' U p, N') fi fi if N := M[p] .

endfm


view Pbag{L :: TRIV} from TRIV to PBAG{L} is 
 sort Elt to Pbag .
endv

*** view as a set
view Pset{L :: TRIV} from TRIV to PBAG{L} is 
 sort Elt to Pset .
endv