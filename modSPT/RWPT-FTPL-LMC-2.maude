in FTPL

*** rewritable PL system model for LCTMC 
mod RWPT-FTPL-LMC is
 inc FTPL .
 inc GSPN-REWSET .
 inc SET+{System{SPTlab}} * (sort Set{System{SPTlab}} to Set{System}, sort NeSet{System{SPTlab}} to NeSet{System}, op emptyS to emptySS ) . *** NEW
 inc SET+{String} * (sort emptyS to emptyR) .
 inc SET+{Pair{System{SPTlab},Float}} * (sort Pair{System{SPTlab},Float} to Pair{System,Float},
                                         sort Set{Pair{System{SPTlab},Float}} to Set{Pair{System,Float}}, 
                                         sort NeSet{Pair{System{SPTlab},Float}} to NeSet{Pair{System,Float}}, sort emptyS to emptySR) .
 vars N N' N'' : Net .
 vars P0 P1 P2 P3 P4 P5 P6 P7 : Place .
 vars S S' S'' : Pbag .
 var K : NzNat .
 vars I Imin J : Nat .
 var W : String .
 vars L L' L0 L1 L2 L3 L4 L5 L6 L7 : Lab .
 var Sys Sys' : System .
 var Sp : Pset .
 var P : Place .
 var X : Pset .
 var RS : Rset .
 vars R F : Float .

*** 1st aproach (general) we compute the rewrite matches for each of the two rewrite rules of the PL system example
*** ops rate1 rate2 : -> Float [memo]. *** rew labs (including rates)
*** eq rate1 = 1.0  . 
*** eq rate2 = 2.0  .
*** 1st rule
*** op rule1-matches : System -> Pset [memo] . *** the different instances of (free) variable I used in the rule (we should consider also J and L, i.e., the place)
*** op $rule1-matches : Pbag Pset -> Pset .
*** eq rule1-matches(N S) = if dead(N S) then $rule1-matches(S, emptyPset) else emptyPset fi .  *** comment/uncomment if needed
*** eq $rule1-matches(nilP, X) = X .
*** ceq $rule1-matches(S + 1 . P, X) = $rule1-matches(S, P U X) if p(< "f" ; J > L < "PL" ; I >) := P .  *** comment/uncomment if needed
*** eq $rule1-matches(S + K . P, X) = $rule1-matches(S, X) [owise] . 
*** rule1 triggered by a local deadlock (comment to go back to the version triggered by a global deadlock)
*** eq rule1-matches(N S) = $rule1-matches(S, emptyPset)  .
*** ceq $rule1-matches(S + 1 . P, X) = $rule1-matches(S, P U X) if p(< "f" ; J > L < "PL" ; I >) := P /\ dead (nomPL(I) S + 1 . P) .

*** 2nd rule
*** op rule2-matches : System -> Pset [memo] . 
*** eq rule2-matches(N S) = $rule2-matches(N S, S, emptyPset)  .
*** op $rule2-matches : System Pbag Pset -> Pset .
*** eq $rule2-matches(Sys, nilP, X) = X .
*** ceq $rule2-matches(N S, S' + 1 . P, X) = $rule2-matches(N S, S', P U X) if p(< "f" ; J > L < "fPL" ; I >) := P  /\ dead(faultyPL(I) S) /\ detache(N, faultyPL(I)) =/= emptyN . 
*** eq $rule2-matches(Sys, S + K . P, X) = $rule2-matches(Sys, S, X) [owise] . 

*** rules' matches applications
*** ops rule1 rule2 : System Place -> [System] .
*** ceq rule1(N S, p(L < "PL" ; I >)) = join(detache(N, nomPL(I)) S - S', setMark(setMark(faultySys(minNotIn(N, "fPL")), "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |))   
***    if  S' := subag(S, < "PL" ; I >) .
*** ceq rule2(N S, p(L < "fPL" ; I >)) = detache(N, faultyPL(I)) set(S - S', p(< "s" ; 0 >), S[p(< "s" ; 0 >)] + (| S' | - 1))  if S' := subag(S, < "fPL" ; I >) .

*** given a PT system term and the set of instances of rule 1, calculates the set of groups of equivalent state transitions due to rule 1 
*** op r1exe : System Pset -> [Rset] .
*** eq r1exe(Sys, X) = $r1exe(Sys, X, emptyRset) .
*** op $r1exe : System Pset Rset -> [Rset] .
*** eq $r1exe(Sys, emptyPset, RS) = RS .
*** ceq $r1exe(Sys, P U X, RS ; Sys' <-| R ) = $r1exe(Sys, X, RS ; Sys' <-| R + rate1) if Sys' := normalize(rule1(Sys, P)) .
***  eq $r1exe(Sys, P U X, RS ) = $r1exe(Sys, X, RS ; normalize(rule1(Sys, P)) <-| rate1)  [owise] .
*** the same for rule 2
*** op r2exe : System Pset -> [Rset] .
*** eq r2exe(Sys, X) = $r2exe(Sys, X, emptyRset) .
*** op $r2exe : System Pset Rset -> [Rset] .
*** eq $r2exe(Sys, emptyPset, RS) = RS .
*** ceq $r2exe(Sys, P U X, RS ; Sys' <-| R ) = $r2exe(Sys, X, RS ; Sys' <-| R + rate2  ) if Sys' := normalize(rule2(Sys, P)) .
***  eq $r2exe(Sys, P U X, RS ) = $r2exe(Sys, X, RS ; normalize(rule2(Sys, P)) <-| rate2)  [owise] .
***eq allRew(Sys) = r1exe(Sys, rule1-matches(Sys)) ; r2exe(Sys, rule2-matches(Sys)) .
 

 *** 2nd approach: operators encoding rules
 *** works if encoded rules are "injective" (distinct matches result in different terms, disregarding normalization) 
 *** new: rules' rate (possibly state dependent) specification
op  rule-labs  : -> Set{String} [ memo ] .
eq  rule-labs = "R1" U "R2" . 
ops rule-rate : String System -> [Float] .
eq  rule-rate("R1", Sys) = 1.0 .
eq  rule-rate("R2", Sys) = 2.0 .
*** single application of a rule (partial operation, overloaded, without extra arg)
op rule : String System -> [System] . *** one equation for each rule
ceq rule("R1", N S) = join(Sys, setMark(setMark(Sys', "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |))   
    if  S'' + 1 . p(< "f" ; J > L < "PL" ; I >) := S /\ N' := nomPL(I) /\ dead (N' S) /\ S' := subag(S'', < "PL" ; I >) /\ Sys := detache(N, N') S'' - S' /\ Sys' := faultySys(minNotIn(N, "fPL"))  . 

ceq rule("R2", N S) = N'' set(S'' - S', p(< "s" ; 0 >), S[p(< "s" ; 0 >)] + | S' |)  if 
        S'' + 1 . p(< "f" ; J > L < "fPL" ; I >) :=  S /\ N' := faultyPL(I) /\  dead(N' S)  /\ N'' := detache(N, N') /\ N'' =/= emptyN  /\
        S' := subag(S'', < "fPL" ; I >) .

*** "global application of the rules (without normalization) "
var TL : String .
var SS : Set{System} .
var TS : [System] .
op ruleApp : String System -> Set{System} .
eq ruleApp(TL, Sys) =  $ruleApp(TL, Sys, emptySS) .
op $ruleApp : String System Set{System} -> Set{System} .
ceq $ruleApp(TL, Sys, SS) = $ruleApp(TL, Sys, SS U TS) if TS := rule(TL, Sys) /\ TS :: System  /\ not(TS in SS) . 
eq $ruleApp(TL, Sys, SS) = SS [owise] .

*** alternative: it may be more efficient computing the rule's rates during rule's application
op rule* : String System -> [Pair{System,Float}] .
ceq rule*("R1", N S) = < join(Sys, setMark(setMark(Sys', "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |)) ;  1.0 >    
    if  S'' + 1 . p(< "f" ; J > L < "PL" ; I >) := S /\ N' := nomPL(I) /\ dead (N' S) /\ S' := subag(S'', < "PL" ; I >) /\ Sys := detache(N, N') S'' - S' /\ Sys' := faultySys(minNotIn(N, "fPL"))  . 
ceq rule*("R2", N S) = < N'' set(S'' - S', p(< "s" ; 0 >), S[p(< "s" ; 0 >)] + | S' |) ; 2.0 >  if 
        S'' + 1 . p(< "f" ; J > L < "fPL" ; I >) :=  S /\ N' := faultyPL(I) /\  dead(N' S)  /\ N'' := detache(N, N') /\ N'' =/= emptyN  /\
        S' := subag(S'', < "fPL" ; I >) .
var SR : Set{Pair{System,Float}} . var psr : Pair{System,Float} .
op ruleApp* : String System -> Set{Pair{System,Float}} .
eq ruleApp*(TL, Sys) =  $ruleApp*(TL, Sys, emptySR) .
op $ruleApp* : String System Set{Pair{System,Float}} -> Set{Pair{System,Float}} .
ceq $ruleApp(TL, Sys, SR) = $ruleApp*(TL, Sys, SR U psr) if psr := rule*(TL, Sys) /\ 1st(psr) :: System  /\ not(psr in SR) . 
eq $ruleApp(TL, Sys, SR) = SR [owise] .


*** simplified version using ruleApp 
op rulexe : String System -> Rset .
eq rulexe(TL, Sys) = $rulexe(rule-rate(TL, Sys), ruleApp(TL, Sys), emptyRset) .
op $rulexe : Float Set{System} Rset -> Rset .
eq $rulexe(F, emptySS, RS) = RS .
ceq $rulexe(F, Sys U SS, RS ; Sys' <-| R) = $rulexe(F, SS, RS ; Sys' <-| R + F ) if Sys' := normalize(Sys) .
eq $rulexe(F, Sys U SS, RS) = $rulexe(F, SS, RS ; normalize(Sys) <-| F) [owise] .

 *** cumulative calculation of state transitions due to R1 and R2
 vars Z Y : Set{String} .
 op allRew : System -> Rset [memo] .
 *** eq allRew(Sys) = rulexe("R1", Sys) ; rulexe("R2", Sys) . 
 eq allRew(Sys) = $allRew(Sys, rule-labs, emptyRset) .
 op $allRew : System Set{String} Rset -> Rset .
 eq $allRew(Sys, emptyS, RS) = RS .
 eq $allRew(Sys, W U Z, RS) = $allRew(Sys, Z, rulexe(W, Sys) ; RS) .

endm  

view RewFtplLmc from GSPN-SYSREW-LMC to RWPT-FTPL-LMC is 
endv