in GSPN-EMU-LMC
in FTPL

*** rewritable PL system model for LCTMC 
mod RWPT-FTPL-SYM is
 pr  FTPL .
 *** inc GSPN-EMU-LMC .
 vars N N' N'' : Net .
 vars Tload Tfail Tfail1 Tfail2 Tass Tline Tline1 Tline2  : String .
 vars P0 P1 P2 P3 P4 P5 P6 P7 : Place .
 vars S S' S'' : Pbag .
 var K : NzNat .
 vars I Imin J : Nat .
 var W : String .
 vars L L' L0 L1 L2 L3 L4 L5 L6 L7 : Lab .
 var Sys Sys' : System .
 var Sp : Pset .

*** the rule syr1 replaces a nominal PL with a faulty one: is correct (symmetric) but doesn't match the normalization requirements
***crl [syr1] : N S + 1 . P7 => ( N' ; [2 . P1, 2 . P2, nilP] |-> Tload ;  [2 . P4, 2 . P1, nilP] |-> Tass  ) set(S, P3, 0) + S[P3] . P2 + 1 . P0 
***       if (N' ; [2 . P1, 1 . P2 + 1 . P3, nilP ] |-> Tload  ; [1 . P3, 1 . P5, 1 . P7] |-> Tline2 ; [1 . P4 + 1 . P5, 2 . P1, nilP ] |-> Tass  ;[1 . P0, 1 . P7, nilP] |-> Tfail2 ) := N /\ dead(N S + 1 . P7)  .
*** alternative rule coherent with normalization
 *** optimized version of nor1 exploiting the fact that the faulty PL do not need abstraction
*** crl [rew1] : N  S + 1 . p(< "f" ; J > L < "PL" ; I >) => normalize(join(detache(N, nomPL(I))  S - S', setMark(setMark(faultySys(minNotIn(N, "fPL")), "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |)),"fPL")
***     if dead (N S + 1 . p(< "f" ; J > L < "PL" ; I >)) /\  S' := subag(S, < "PL" ; I >) .
*** more readable
*** (different equivalent versions obtained using simple syntactical transformations)
*** crl [rew1.1] : N  S => normalize(join(Sys, setMark(setMark(faultySys(minNotIn(N, "fPL")), "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |)),"fPL")   
***   if  dead (N S) /\ S'' + 1 . p(< "f" ; J > L < "PL" ; I >) := S /\ S' := subag(S'', < "PL" ; I >) /\ Sys := detache(N, nomPL(I)) S'' - S' .
*** crl [rew1.1] : N  S + 1 . p(< "f" ; J > L < "PL" ; I >) => normalize(join(Sys, setMark(setMark(faultySys(minNotIn(N, "fPL")), "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |)),"fPL")   
***    if  dead (N S + 1 . p(< "f" ; J > L < "PL" ; I >)) /\ S' := subag(S, < "PL" ; I >) /\ Sys := detache(N, nomPL(I)) S - S' .
*** crl [rew1.1] : N  S + 1 . p(< "f" ; J > L < "PL" ; I >) => normalize(join(detache(N, nomPL(I)) S - S', setMark(setMark(faultySys(minNotIn(N, "fPL")), "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |)),"fPL")   
***    if  dead (N S + 1 . p(< "f" ; J > L < "PL" ; I >)) /\ S' := subag(S, < "PL" ; I >) .




*** triggered by a local deadlock
*** crl [rew1.2] : N  S => normalize(join(Sys, setMark(setMark(Sys', "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |)))   
***      if  S'' + 1 . p(< "f" ; J > L < "PL" ; I >) := S /\ N' := nomPL(I) /\ dead (N' S) /\ S' := subag(S'', < "PL" ; I >) /\ Sys := detache(N, N') S'' - S' /\ Sys' := faultySys(minNotIn(N, "fPL"))  .
*** paper's version
*** crl [rew1.1p] : N  S => normalize(setMark(setMark(attach(N', faultyPL, "fPL") S'' - S', "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |),"fPL")   
  *** if  dead (N S) /\ S'' + 1 . p(< "f" ; J > L < "PL" ; I >) := S /\ S' := subag(S'', < "PL" ; I >) /\ N' := detache(N, < "PL" ; I >)  .


*** syr2 removes a faulty PL after a 2nd fault occurrence (analogous considerations to syr1)
***crl [syr2] : N  S + 1 . P6  => N' (set(set(S, P1, S[P1] + S[P2] + S[P4]), P2, 0)) - 1 . P4 if (N' ; [1 . P0, 1 . P6, nilP] |-> Tfail1 ; [2 . P1, 2 . P2, nilP] |-> Tload  ; [1 . P2, 1 . P4, 1 . P6] |-> Tline1 ; [2 . P4, 2 . P1, nilP ] |-> Tass ) := N  /\ N' =/= emptyN /\
***  dead(([2 . P1, 2 . P2, nilP] |-> Tload ; [2 . P4, 2 . P1, nilP ] |-> Tass) S) .
*** version coherent with normalization
*** crl [rew2] : N  S + 1 . p(< "f" ; J > L < "fPL" ; I >) => normalize(N'' set(S - S', p(< "s" ; 0 >), S[p(< "s" ; 0 >)] + | S' |), "PL")  if 
***   N' := faultyPL(I) /\ N'' := detache(N, N') /\ N'' =/= emptyN /\
***   dead(N' S + 1 . p(< "f" ; J > L < "fPL" ; I >)) /\ S' := subag(S, < "fPL" ; I >) .
*** more readable
*** crl [rew2.1] : N S => normalize(N'' set(S'' - S', p(< "s" ; 0 >), S[p(< "s" ; 0 >)] + | S' |), "PL")  if 
***        S'' + 1 . p(< "f" ; J > L < "fPL" ; I >) :=  S /\ N' := faultyPL(I) /\  dead(N' S)  /\ N'' := detache(N, N') /\ N'' =/= emptyN  /\
***        S' := subag(S'', < "fPL" ; I >) .
*** paper's version
***crl [rew2p] : N S => normalize(setMark(N'' S'' - S', "s" , | match(S, "s") | + | S' | ), "PL")  if 
***   S'' + 1 . p(< "f" ; J > L < "fPL" ; I >) :=  S /\  dead(faultyPL(I) S)  /\ N'' := detache(N, < "fPL" ; I >) /\ N'' =/= emptyN  /\
***   S' := subag(S'', < "fPL" ; I >) . 

*** without normalization
*** crl [rew1.1] : N  S => join(Sys, setMark(setMark(Sys', "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |))   
***     if  dead (N S) /\ S'' + 1 . p(< "f" ; J > L < "PL" ; I >) := S /\ S' := subag(S'', < "PL" ; I >) /\ Sys := detache(N, nomPL(I)) S'' - S' /\ Sys' := faultySys(minNotIn(N, "fPL"))  .
*** triggered by a local deadlock
*** crl [rew1.2] : N  S => join(Sys, setMark(setMark(Sys', "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |))   
***      if  S'' + 1 . p(< "f" ; J > L < "PL" ; I >) := S /\ N' := nomPL(I) /\ dead (N' S) /\ S' := subag(S'', < "PL" ; I >) /\ Sys := detache(N, N') S'' - S' /\ Sys' := faultySys(minNotIn(N, "fPL"))  .


*** crl [rew2.1] : N S => N'' set(S'' - S', p(< "s" ; 0 >), S[p(< "s" ; 0 >)] + | S' |)  if 
***       S'' + 1 . p(< "f" ; J > L < "fPL" ; I >) :=  S /\ N' := faultyPL(I) /\  dead(N' S)  /\ N'' := detache(N, N') /\ N'' =/= emptyN  /\
***       S' := subag(S'', < "fPL" ; I >) .

*** marking abstractions (derived from readable versions)
*** crl [ar1] : N  nilP => normalize(joinAbs(Sys, Sys'))   
***    if  p(L < "PL" ; I >) U Sp := places(N) /\ Sys := detache(N, nomPL(I)) nilP /\ Sys' := faultySys(minNotIn(N, "fPL"))  .
*** crl [ar2] : N nilP =>  normalize(N'' nilP) if p(L < "fPL" ; I >)  U Sp := places(N) /\ N' := faultyPL(I) /\  N'' := detache(N, N') /\ N'' =/= emptyN .
*** (paper versions)
*** crl [ar1p] : N nilP => normalize(attach(N', faultyPL, "fPL") nilP)  if  p(L < "PL" ; I >) U Sp := places(N) /\ N' := detache(N, < "PL" ; I >)  .
*** crl [ar2p] : N nilP => normalize(N'' nilP)  if p(L < "fPL" ; I >)  U Sp := places(N) /\  N'' := detache(N, < "fPL" ; I >) /\ N'' =/= emptyN  . 

*** rules for state-transition based representation directly derived from ordinary rules (working)
vars ST ST' : StateTranSys .
*** crl [spnrew1-rate:2.0] : ST => toStateTranSPN(normalize(join(Sys, setMark(setMark( faultySys(minNotIn(N, "fPL")), "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |)),"fPL"))   
***     if  N S := toSystem(ST)  /\ dead (N S) /\ S'' + 1 . p(< "f" ; J > L < "PL" ; I >) := S /\ S' := subag(S'', < "PL" ; I >) /\ Sys := detache(N, nomPL(I)) S'' - S'   .

*** crl [spnrew2-rate:1.0] : ST  => toStateTranSPN(normalize(N'' set(S'' - S', p(< "s" ; 0 >), S[p(< "s" ; 0 >)] + | S' |), "PL"))  if 
***        N S := toSystem(ST)  /\ S'' + 1 . p(< "f" ; J > L < "fPL" ; I >) :=  S /\ N' := faultyPL(I) /\  dead(N' S)  /\ N'' := detache(N, N') /\ N'' =/= emptyN  /\
***        S' := subag(S'', < "fPL" ; I >) .


*** NEW we compute the rewrite instances for each of the above rules
*** le regole sono più semplici delle precedenti (compaiono meno variabili, ad es. non c'è S'')
var P : Place .
var X : Pset .
*** 1st rule
op rew1Instances : System -> Pset [memo] . *** the different instances of (free) variable I used in the rule (we should consider also J and L, i.e., the place)
eq rew1Instances(N S) = if dead(N S) then $rew1Instances(S, emptyPset) else emptyPset fi .
op $rew1Instances : Pbag Pset -> Pset .
eq $rew1Instances(nilP, X) = X .
ceq $rew1Instances(S + 1 . P, X) = $rew1Instances(S, P U X) if p(< "f" ; J > L < "PL" ; I >) := P .
eq $rew1Instances(S + K . P, X) = $rew1Instances(S, X) [owise] . 
*** alternatine rephrasing of rew1 based on instance pre-calculation
*** crl [rew1.1Alt] : N S => normalize(rule1(N S, P),"fPL") if P U X := rew1Instances(N S) .

*** 2nd rule
op rew2Instances : System -> Pset [memo] . 
eq rew2Instances(N S) = $rew2Instances(N S, S, emptyPset)  .
op $rew2Instances : System Pbag Pset -> Pset .
eq $rew2Instances(Sys, nilP, X) = X .
ceq $rew2Instances(N S, S' + 1 . P, X) = $rew2Instances(N S, S', P U X) if p(< "f" ; J > L < "fPL" ; I >) := P  /\ dead(faultyPL(I) S) /\ detache(N, faultyPL(I)) =/= emptyN . 
eq $rew2Instances(Sys, S + K . P, X) = $rew2Instances(Sys, S, X) [owise] . 
*** alternatine rephrasing of rew2 based on instance pre-calculation
*** crl [rew2.1Alt] : N S => normalize(rule2(N S, P), "PL")  if P U X := rew2Instances(N S) .

*** reproduce the execution of the two rules (first single instances then the entire set of instances)
op rule1 : System Place -> [System] .
ceq rule1(N S, p(L < "PL" ; I >)) = join(detache(N, nomPL(I)) S - S', setMark(setMark(faultySys(minNotIn(N, "fPL")), "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |))   
   if  S' := subag(S, < "PL" ; I >) .

op rule2 : System Place -> [System] .
ceq rule2(N S, p(L < "fPL" ; I >)) = detache(N, faultyPL(I)) set(S - S', p(< "s" ; 0 >), S[p(< "s" ; 0 >)] + (| S' | - 1))  if S' := subag(S, < "fPL" ; I >) .

***
var R  : RuleSet .
var RS : Rset .
*** given a PT system term and the set of instances of rule 1, calculates the set of groups of equivalent state transitions due to rule 1 
op r1exe : System Pset -> [Rset] .
eq r1exe(Sys, X) = $r1exe(Sys, X, emptyRset) .
op $r1exe : System Pset Rset -> [Rset] .
eq $r1exe(Sys, emptyPset, RS) = RS .
ceq $r1exe(Sys, P U X, (RS , R --> Sys') ) = $r1exe(Sys, X, (RS , R + 1 .  << "R1",0,2.0 >> --> Sys' )) if Sys' := normalize(rule1(Sys, P)) .
 eq $r1exe(Sys, P U X, RS ) = $r1exe(Sys, X, (RS , 1 .  << "R1",0,2.0 >> --> normalize(rule1(Sys, P))) ) [owise] .
*** the same for rule 2
op r2exe : System Pset -> [Rset] .
eq r2exe(Sys, X) = $r2exe(Sys, X, emptyRset) .
op $r2exe : System Pset Rset -> [Rset] .
eq $r2exe(Sys, emptyPset, RS) = RS .
ceq $r2exe(Sys, P U X, (RS , R --> Sys') ) = $r2exe(Sys, X, (RS , R + 1 .  << "R2",0,1.0 >> --> Sys' )) if Sys' := normalize(rule2(Sys, P)) .
 eq $r2exe(Sys, P U X, RS ) = $r2exe(Sys, X, (RS , 1 .  << "R2",0,1.0 >> --> normalize(rule2(Sys, P))) ) [owise] .
 *** cumulative calculation of state transitions due to R1 and R2
 op allRew : System -> Rset [memo] .
 eq allRew(Sys) = r1exe(Sys, rew1Instances(Sys)) , r2exe(Sys, rew2Instances(Sys)) .
 *** equivalent rewrites based on pre-calculation of rewrite instances
 *** crl [R1] : Sys => Sys' if  RS , R --> Sys' := r1exe(Sys, rew1Instances(Sys)) .
 *** crl [R2] : Sys => Sys' if  RS , R --> Sys' := r2exe(Sys, rew2Instances(Sys)) .
endm  
