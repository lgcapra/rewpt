*** this module defines the operators to bring a Net (System) to a minimal/canonical form
*** should be used in combination with NET-OP: i.e., assumes that models are built according
*** to the net-operators there defined
in PT-SYS-MOD
in MARK-NORM

fmod PT-NORM{L :: TRIV} is
 pr PT-SYS-MOD{L} .
 pr MARK-NORM .

 var I : Nat .
 var K : NzNat .
 var B  : Pbag .
 vars N N' : Net .
 var Sys Sys' : System .
 vars W W' : String .
 vars L L' : Lab .
 var NeL : NeLab .
 vars S S' : Pset .
 
 *** net/system versions of normalization
 *** op abstract : Net -> Net . *** needed?
 *** eq abstract(N) = net(abstract(N nilP)) .
 op abstract : System -> System .
ceq abstract(Sys) = abstract(replaceWith(Sys, < W ; K > L, K - 1)) if p(L' < W ; K > L) U S := places(n(Sys)) /\ exists(S, < W ; K - 1 > L) == false .

  eq abstract(Sys) = Sys [owise] .
*** version 2
***ceq abstract(Sys) = abstract(replaceWith(Sys, NeL, I)) if S := places(n(Sys)) /\ p(L' NeL) U S' := places(n(Sys)) /\ < W ; K > L := NeL /\ I := minNotIn(S', W, L) /\ I < K  /\ K = maxIn(S, W, L) .
*** eq abstract(Sys) = Sys [owise] .

*** excludes from index abstraction those places (components) matching a given suffix
 op abstractBut : System String -> System .
ceq abstractBut(Sys, W') = abstractBut(replaceWith(Sys, < W ; K > L, K - 1), W') if p(L' < W ; K > L) U S := places(n(Sys)) /\ 1st(last(L' < W ; K > L)) =/= W' /\ exists(S, < W ; K - 1 > L) == false .
 eq abstractBut(Sys, W) = Sys [owise] .

*** normalize a system assuming that its labelling is well-defined: for the net, only index abstraction applies 
 op normalize : System -> System .
ceq normalize(Sys) = net(Sys') normalize(marking(Sys')) if Sys' := abstract(Sys) .  

*** excludes from index abstraction those places (components) matching a given suffix
op normalize : System String -> System .
ceq normalize(Sys, W) = net(Sys') normalize(marking(Sys')) if Sys' := abstractBut(Sys, W) .  

*** extend the versions defined on Pbag
*** efficient if places is set as [memo] -- otherwise better to define from scratch
 op exists : Net NeLab  -> Bool .
 eq exists(N, NeL) = exists(places(N), NeL) .
 
*** overloading (defined for convenience)
 op minNotIn : Net String Lab -> Nat .
 eq minNotIn(N, W, L) = minNotIn(places(N), W, L) .
 *** default versions (with a null suffix last part)
 op minNotIn : Net String -> Nat .
 eq minNotIn(N, W) = minNotIn(N, W, emptyLab) .
 op minNotIn : Pbag String -> Nat .
 eq minNotIn(B, W) = minNotIn(B, W, emptyLab) .
  
endfm 

