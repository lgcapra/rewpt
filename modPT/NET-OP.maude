*** net-algebra operators pointing out symmetries
in PT-SYS

fmod NET-OP{X :: TRIV} is
 pr PT-SYS{X} .
 vars P P' P'' : Place .
 vars T T' T'' : Transition .
 vars N N' : Net .
 vars B B' B'' : Pbag .
 var Sys Sys' : System .
 vars I J Y : Nat .
 vars K K' : NzNat .
 vars W W1 W2 W3 W4 : String .
 vars Lw Lw' : List{String} .
 vars Q Q' : Tmatrix .
 vars S S' : Pset .
 vars L L' : X$Elt . *** tran. lab
 var Z : Set{X} .
 vars Lb Lb' : Lab . *** place lab 
*** verifies that two nets may be joined by preserving the symmetry hierarchy
 op joinable : Net Net -> Bool [comm] .  
ceq joinable(N, N') = false if p(Lb < W ; I > ) U S := places(N) /\ p(Lb' < W ; J > ) U S' := places(N')  /\ Lb < W ; I > =/= Lb' < W ; J > .
 eq joinable(N, N') = true [owise] .
 ***symmetry preserving net juxtaposition
 op _;;_ : Net Net -> [Net] [prec 70 ] .
ceq N ;; N' = N ; N' if joinable(N, N') . 
 *** "merges" identically labelled net transitions whose labels belong to the given set
 op merge : Net Set{X} -> Net .
ceq merge(N ; Q |-> L ; Q' |-> L, Z) = Q + Q' |->  L ; merge(N, Z) if L in Z .
 eq merge(N, Z) = N [owise] . 
 *** "forced" merge of identically labelled net transitions
 op merge! : Net  -> Net .
 eq merge!(N ; Q |-> L ; Q' |-> L) = Q + Q' |->  L ; merge!(N) .
 eq merge!(N) = N [owise] .
 *** join two systems by summing their markings (identical places are implicitly merged)
 op join : System System -> System [assoc comm] .
 eq join(N B, N' B') = (N ; N') B + B' .
 op joinAbs : System System -> System  . *** marking abstraction
 eq joinAbs(Sys, Sys') = net(join(Sys, Sys')) nilP . 
 *** join two systems and then merge transitions identically labelled whose labels belong to the given set
 op join : System System Set{X} -> System .
 eq join(N B, N' B', Z) = merge(N ; N', Z) B + B' . 
 *** forced join (builds on transitions'  merge!)
 op join! : System System  -> System .
 eq join(N B, N' B') = merge!(N ; N') B + B' . 
 *** merge permutable places by summing their markings -- to define
 op merge : System  List{String} -> System .
 op merge : Net List{String} -> Net .
 eq merge(N, Lw) = net(merge(N nilP, Lw)) .

 *** "symmetric" juxtaposition: creates K (disjoint) replica of a system each one with a suitably added label suffix (with index 0..K-1) denoting the "nesting" level
 ***  general version specifying elements to share among replicas
 op repl&share  : System NzNat String Pset Set{X} -> System .
 eq repl&share(Sys, K, W, S, Z) = $repl&share(Sys, K, W, emptySys, S, Z) .
 op $repl&share  : System Nat String System Pset Set{X} -> System .
 eq $repl&share(Sys, 0, W, Sys', S, Z) = Sys' .
 eq $repl&share(Sys, K, W, Sys', S, Z) = $repl&share(Sys, K - 1, W, join(Sys', addLab(Sys, < W ; K - 1 >, S), Z), S, Z) .
 *** overloaded version in which shared places are specified through a suffix in their labels
 op repl&share : System NzNat String List{String} Set{X} -> System .
 eq repl&share(Sys, K, W, Lw, Z) = repl&share(Sys, K, W, places(Sys, Lw), Z) .
 *** default version
 op replica  : System NzNat String -> System . 
 eq replica(Sys, K, W) =  repl&share(Sys, K, W, emptyPset, emptyStlab) .
 *** net versions (build on system replica)
 op repl&share : Net NzNat String Pset Set{X} -> Net .
 eq repl&share(N, K, W, S, Z) = net(repl&share(N nilP, K, W, S, Z)) .
 op repl&share : Net NzNat String List{String} Set{X} -> Net .
 eq repl&share(N, K, W, Lw, Z) = net(repl&share(N nilP, K, W, Lw, Z)) .
 op replica : Net NzNat String -> Net .
 eq replica(N, K, W) = net(replica(N nilP, K, W)) .
 
 *** elementary operators/operators acting on elementary nets (transitions)
 var TQ : Transition .
 var A : Atype .
 op newT : String Nat String Nat String Nat X$Elt -> Transition .
 eq newT(W, I, W1, J, W2, Y, L) = [$newEdge(W, I), $newEdge(W1, J), $newEdge(W2, Y)] |-> L .
 op $newEdge : String Nat -> Pbag .
 eq $newEdge(W, I) = if I == 0 then nilP else I . p(< W ; 0 >) fi .
 *** general version creating n copies of I/O/H places with specific tags -- to define
 op newT : String Nat Nat String Nat Nat String Nat Nat X$Elt -> Transition .

 
 *** set a marking for net places with label with a given suffix
 var NeL : NeList{String} .
 op setMark : Net NeList{String} Nat -> System .
 eq setMark(N, NeL, 0) = N nilP . 
 eq setMark(N, NeL, K) = setMark(N nilP, NeL, K) . 
 op setMark : System NeList{String} Nat -> System .
 eq setMark(N B, NeL, I) = N set(B, places(N B, NeL), I) . 
 
*** symmetric process algebra ops 
*** op synch  : System NzNat Atype String String String  -> System . 
*** ceq synch(Sys, K, A, W, W1, W2) = connect(Sys', W, W1, A, 1) if Sys' := replica(Sys, K, W2) .
 *** symmetric process-algebra ops -- to define
 op replAnd  : System NzNat List{String} List{String} X$Elt String X$Elt  String String -> System . *** 2nd and 3rd args: in/out places, 5th, 6th: tag of fork tran and its in place, 7th, 8th join tran and its out, 9th: new suffix
 op replOr  :  System NzNat List{String} List{String} String   -> System . *** the same as replAnd, but the fork-join parameters disappeared
 *** bisogna aggiungere 2 par String a And per in nomi dei nuovi posti di in/out ?
 *** net version
 op replAnd  : Net NzNat List{String} List{String} X$Elt String X$Elt String String   -> Net . 
 eq replAnd(N, K, Lw, Lw', L, W, L', W1, W2) = net(replAnd(N nilP, K, Lw, Lw', L, W, L', W1, W2)) .
 op replOr  : Net NzNat List{String} List{String} String  -> Net .
 eq replOr(N, K, Lw, Lw', W) = net(replOr(N nilP, K, Lw, Lw', W)) .
 
 *** classical binary version
 op and : System System List{String} List{String} X$Elt String X$Elt String -> System .
 op or  : System System List{String} List{String} -> System .
 op seq : System System List{String} List{String} -> System .
 *** net versions

 *** introspectio ops -- to define
 op get : Net NeList{String} -> Pset . *** places whose label suffix matches a pattern
 op subNet : Net Set{X} -> Net . *** sub-net built of transitions with labels in the specified set
 *** intercession ops  -- to define
 *** set net's connections of specific type and weight (0 means removing an edge) -- if the transition doesn't exist, it is created
 op set : Net X$Elt Atype NeList{String} Nat -> Net .
 *** set net's connections of specific type and weight from a transition to a set of k newly added places with elementary label and index 0 through  k -1 -- if the transition doesn't exist, it is created
 *** does nothing (i.e., returns the same Net) if Def.2 would be violated by the action
 op set : Net X$Elt Atype String NzNat NzNat -> Net .
 *** remove net's places matching a specified label suffix
 op remove : Net NeList{String} -> Net .
 *** remove net's transitions with a specific label
 op remove : Net  X$Elt -> Net .
 *** add a new component (sub-net, 2nd arg) to the specified net (1st arg) at the highest level of hierarchy (root),
 *** represented by a suffix tag; if isomorphic components do exist, then the the prefix header is associated a suitable index
 *** does nothing (i.e., returns the same Net) if Def.2 would be violated by the action
 op attach : Net Net String -> Net .

endfm