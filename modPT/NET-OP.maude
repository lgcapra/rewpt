*** net-algebra operators pointing out symmetries
in PT-SYS

fmod NET-OP{X :: TRIV} is
 pr PT-SYS{X} .
 vars P P' P'' : Place .
 vars T T' T'' : Transition .
 vars N N' : Net .
 vars B B' B'' : Pbag .
 var Sys Sys' : System .
 vars I J Y : Nat .
 vars K K' : NzNat .
 vars W W1 W2 W3 W4 : String .
 vars Lw Lw' : NeList{String} .
 vars Q Q' : Tmatrix .
 var S : Pset .
 var L : X$Elt . *** tran. lab
 var Z : Set{X} .
 
 *** "merges" identically labelled net transitions whose labels belong to the given set
 op merge : Net Set{X} -> Net .
ceq merge(N ; Q |-> L ; Q' |-> L, Z) = Q + Q' |->  L ; merge(N, Z) if L in Z .
 eq merge(N, Z) = N [owise] . 
 *** "forced" merge of identically labelled net transitions
 op merge! : Net  -> Net .
 eq merge!(N ; Q |-> L ; Q' |-> L) = Q + Q' |->  L ; merge!(N) .
 eq merge!(N) = N [owise] .
 *** join two systems by summing their markings (identical places are implicitly merged)
 op join : System System -> System [assoc comm] .
 eq join(N B, N' B') = (N ; N') B + B' .
 *** join two systems and then merge transitions identically labelled whose labels belong to the given set
 op join : System System Set{X} -> System .
 eq join(N B, N' B', Z) = merge(N ; N', Z) B + B' . 
 *** forced join (builds on transitions'  merge!)
 op join! : System System  -> System .
 eq join(N B, N' B') = merge!(N ; N') B + B' . 
 
 *** "symmetric" juxtaposition: creates K (disjoint) replica of a system each one with a suitably added label suffix (with index 0..K-1) denoting the "nesting" level
 ***  general version specifying elements to share among replicas
 op replica&share  : System NzNat String Pset Set{X} -> System .
 eq replica&share(Sys, K, W, S, Z) = $replica&share(Sys, K, W, emptySys, S, Z)  .
 op $replica&share  : System Nat String System Pset Set{X} -> System .
 eq $replica&share(Sys, 0, W, Sys', S, Z) = Sys' .
 eq $replica&share(Sys, K, W, Sys', S, Z) = $replica&share(Sys, K - 1, W, join(Sys', addLab(Sys, < W ; K - 1 >, S), Z), S, Z) .
 *** overloaded version in which shared places are specified through a suffix in their labels
 op replica&share : System NzNat String NeList{String} Set{X} -> System .
 eq replica&share(Sys, K, W, Lw, Z) = replica&share(Sys, K, W, places(Sys, Lw), Z) .
 *** default version
 op replica  : System NzNat String -> System . 
 eq replica(Sys, K, W) =  replica&share(Sys, K, W, emptyPset, emptyStlab) .
 *** net versions (build on system replica)
 op replica&share : Net NzNat String Pset Set{X} -> Net .
 eq replica&share(N, K, W, S, Z) = net(replica&share(N nilP, K, W, S, Z)) .
 op replica&share : Net NzNat String NeList{String} Set{X} -> Net .
 eq replica&share(N, K, W, Lw, Z) = net(replica&share(N nilP, K, W, Lw, Z)) .
 op replica : Net NzNat String -> Net .
 eq replica(N, K, W) = net(replica(N nilP, K, W)) .
 
 *** elementary operators/operators acting on elementary nets (transitions)
 var TQ : Transition .
 var A : Atype .
 op newT : String Nat String Nat String Nat X$Elt -> Transition .
 eq newT(W, I, W1, J, W2, Y, L) = [$newEdge(W, I), $newEdge(W1, J), $newEdge(W2, Y)] |-> L .
 op $newEdge : String Nat -> Pbag .
 eq $newEdge(W, I) = if I == 0 then nilP else I . p(< W ; 0 >) fi .

 
 *** set a marking for net places with label with a given suffix
 op setMark : Net NeList{String} Nat -> System .
 eq setMark(N, Lw, 0) = N nilP . 
 eq setMark(N, Lw, K) = setMark(N nilP, Lw, K) . 
 op setMark : System NeList{String} Nat -> System .
 eq setMark(N B, Lw, I) = N set(B, places(N B, Lw), I) . 
 
 *** DA RIVEDERE
 *** op synch  : System NzNat Atype String String String  -> System . 
*** ceq synch(Sys, K, A, W, W1, W2) = connect(Sys', W, W1, A, 1) if Sys' := replica(Sys, K, W2) .
 *** symmetric process-algebra ops 
 op replAnd  : System NzNat NeList{String} NeList{String} String String String  String String -> System . *** 2nd and 3rd args: in/out places, 4th, 5th: tag of fork, join tran, 6th: new suffix
 op replOr  :  System NzNat NeList{String} NeList{String} String   -> System . *** the same as replAnd, but the 4th and 5th args have disappeared
 *** bisogna aggiungere 2 par String a And per in nomi dei nuovi posti di in/out ?
 *** net version
 op replAnd  : Net NzNat NeList{String} NeList{String} String String String String String   -> Net . 
 eq replAnd(N, K, Lw, Lw', W, W1, W2, W3, W4) = net(replAnd(N nilP, K, Lw, Lw', W, W1, W2, W3, W4)) .
 op replOr  : Net NzNat NeList{String} NeList{String} String  -> Net .
 eq replOr(N, K, Lw, Lw', W) = net(replOr(N nilP, K, Lw, Lw', W)) .
 
 *** classical binary version
 op and : System System Place Place -> System .
 op or  : System System Place Place -> System .
 op seq : System System Place Place -> System .
 *** net versions

 *** set connections
 op set : Net X$Elt Atype NeList{String} Nat -> Net .
 *** remove places
 op removeP : Net NeList{String} -> Net .
 *** remove transitions
 op removeT : Net  X$Elt -> Net .

endfm