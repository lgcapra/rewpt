in PBAG-MOD
in PSET-MOD
in ../EMATRIX

fmod EMATRIX-MOD is
 pr PBAG-MOD .
 pr PSET-MOD .
 pr EMATRIX{Plab} .
 
 vars X Y Z X' Y' Z' : Pbag .
 vars P P' P'' : Place .
 vars N N' C1 C2 : Nat .
 vars K K' : NzNat .
 var Q : Ematrix . var Q' : Tmatrix .
 vars L L'  : Lab . var NeL  : NeLab .
 var Ws :  List{String} . var NWs : NeList{String} .
 var F : FlushArc . var FS FS' : FlushArcs .
 vars S S'  : Pset .
 
 *** add a new label to a matrix' elements (version specifying places to share)
 op addLab : Ematrix Lab Pset -> Ematrix . 
 eq addLab([X,Y,Z], L, S) = [addLab(X, L, S), addLab(Y, L, S), addLab(Z, L, S)] .
 eq addLab([X,Y], L, S) = [addLab(X, L, S), addLab(Y, L, S)] .
 eq addLab(Q' f: FS, L, S) = addLab(Q', L, S) f: addLab(FS, L, S) .
 op addLab : FlushArcs Lab Pset -> FlushArcs . 
 eq addLab(FS, L, S) = $addLab(FS, noFlushArc, L, S) .
 op $addLab : FlushArcs FlushArcs Lab Pset -> FlushArcs .
 eq $addLab(noFlushArc, FS, L, S) = FS .
 eq $addLab(P >> S' ; FS, FS', L, S) = $addLab(FS, addLabP(P, L, S) >> addLab(S', L, S) ; FS', L, S) .
 
 *** no elements to share
 op addLab : Ematrix Lab -> Tmatrix . *** overloaded
 eq addLab(Q, L) = addLab(Q, L, emptyPset) .

 ***
 op replaceWith : Ematrix NeLab Nat -> Tmatrix .
 eq replaceWith([X,Y,Z], NeL, N) = [replaceWith(X, NeL, N), replaceWith(Y, NeL, N), replaceWith(Z, NeL, N)] .
 eq replaceWith([X,Y], NeL, N) = [replaceWith(X, NeL, N), replaceWith(Y, NeL, N)] .
 eq replaceWith(Q' f: FS, NeL, N) = replaceWith(Q', NeL, N) f: replaceWith(FS, NeL, N) .
 op replaceWith : FlushArcs NeLab Nat -> FlushArcs .
 eq replaceWith(FS, NeL, N) = $replaceWith(FS, noFlushArc, NeL, N) .
 op $replaceWith : FlushArcs FlushArcs NeLab Nat -> FlushArcs .
 eq $replaceWith(noFlushArc, FS, NeL, N) = FS .
 eq $replaceWith(P >> S' ; FS, FS', NeL, N) = $replaceWith(FS, replaceWithP(P, NeL, N) >> replaceWith(S', NeL, N) ; FS', NeL, N) .

 *** derived definitions of places
 op places : Ematrix List{String}  -> Pset .
 eq places([X,Y,Z], Ws) = places(X, Ws) U places(Y, Ws) U places(Z, Ws) .
 eq places([X,Y], Ws) = places(X, Ws) U places(Y, Ws) .
 eq places(Q' f: FS, Ws) = places(Q', Ws) U places(FS, Ws) . 
 op places : FlushArcs List{String} -> Pset .
 eq places(FS, Ws) = $places(FS, emptyPset, Ws) .
 op $places : FlushArcs Pset NeList{String} -> Pset  .
 eq $places(noFlushArc, S, Ws) = S .
 eq $places(P >> S' ; FS, S, Ws) = $places(FS, places(P U S', Ws), Ws) .
 ***
 op places : Ematrix NeLab  -> Pset .
 eq places([X,Y,Z], NeL) = places(X, NeL) U places(Y, NeL) U places(Z, NeL) .
 eq places([X,Y], NeL) = places(X, NeL) U places(Y, NeL) .
 eq places(Q' f: FS, NeL) = places(Q', NeL) U places(FS, NeL) . 
 op places : FlushArcs NeLab -> Pset .
 eq places(FS, NeL) = $places(FS, emptyPset, NeL) .
 op $places : FlushArcs Pset NeLab -> Pset  .
 eq $places(noFlushArc, S, NeL) = S .
 eq $places(P >> S' ; FS, S, NeL) = $places(FS, places(P U S', NeL), NeL) .

 
 *** defined analogously (to do)
 *** op match : Tmatrix List{String} NeLab -> Tmatrix .
 *** eq match([X,Y,Z], Ws, NeL) = [match(X, Ws, NeL), match(Y, Ws, NeL), match(Z, Ws, NeL)] .
 *** eq match([X,Y], Ws, NeL) = [match(X, Ws, NeL), match(Y, Ws, NeL)] .
 *** sub-matrices based on the suffix
 *** op sumatrix : Tmatrix NeList{String} -> Tmatrix .
 *** eq sumatrix([X,Y,Z], NWs) = [subag(X, NWs), subag(Y, NWs), subag(Z, NWs)] .
 *** eq sumatrix([X,Y], NWs) = [subag(X, NWs), subag(Y, NWs)] .
 *** op sumatrix : Tmatrix List{String} NeLab -> Tmatrix .
 *** eq sumatrix([X,Y,Z], NWs, NeL) = [subag(X, NWs, NeL), subag(Y, NWs, NeL), subag(Z, NWs, NeL)] . *** optimization
 *** eq sumatrix([X,Y], NWs, NeL) = [subag(X, NWs, NeL), subag(Y, NWs, NeL)] . 
 *** eq sumatrix([X,Y,Z], emptyLs, NeL) = [subag(X, NeL), subag(Y, NeL), subag(Z, NeL)] .
 *** eq sumatrix([X,Y], emptyLs, NeL) = [subag(X, NeL), subag(Y, NeL)] .
 ***
  
endfm