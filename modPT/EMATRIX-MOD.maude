in PBAG-MOD
in ../EMATRIX

fmod EMATRIX-MOD is
 pr PBAG-MOD .
 pr PSET-MOD .
 pr EMATRIX{Plab} .
 
 vars X Y Z X' Y' Z' : Pbag .
 vars P P' P'' : Place .
 vars N N' C1 C2 : Nat .
 vars K K' : NzNat .
 var Q : Ematrix . var Q' : Tmatrix .
 vars L L'  : Lab . var NeL  : NeLab .
 var Ws :  List{String} . var NWs : NeList{String} .
 var F : FlushArc . var FS FS' : FlushArcs .
 vars S S'  : Pset .
 
 *** add a new label to a matrix' elements (version specifying places to share)
 op addLabM : Ematrix Lab Pset -> Ematrix . 
 eq addLabM([X,Y,Z], L, S) = [addLaB(X, L, S), addLaB(Y, L, S), addLaB(Z, L, S)] .
 eq addLabM([X,Y], L, S) = [addLaB(X, L, S), addLaB(Y, L, S)] .
 eq addLabM(Q' f: FS, L, S) = addLabM(Q', L, S) f: addLabF(FS, L, S) .
 op addLabF : FlushArcs Lab Pset -> FlushArcs . 
 eq addLabF(FS, L, S) = $addLabF(FS, noFlushArc, L, S) .
 op $addLabF : FlushArcs FlushArcs Lab Pset -> FlushArcs .
 eq $addLabF(noFlushArc, FS, L, S) = FS .
 eq $addLabF(p(L') >> S' ; FS, FS', L, S) = $addLabF(FS, if p(L') in S then p(L') else p(L' L) fi >> addLabS(S', L, S) ; FS', L, S) .
 *** no elements to share
 op addLabM : Ematrix Lab -> Tmatrix . *** overloaded
 eq addLabM(Q, L) = addLabM(Q, L, emptyPset) .
 

 ***
 op replaceWithM : Ematrix NeLab Nat -> Tmatrix .
 eq replaceWithM([X,Y,Z], NeL, N) = [replaceWithB(X, NeL, N), replaceWithB(Y, NeL, N), replaceWithB(Z, NeL, N)] .
 eq replaceWithM([X,Y], NeL, N) = [replaceWithB(X, NeL, N), replaceWithB(Y, NeL, N)] .
 eq replaceWithM(Q' f: FS, NeL, N) = replaceWithM(Q', NeL, N) f: replaceWithF(FS, NeL, N) .
 op replaceWithF : FlushArcs NeLab Nat -> FlushArcs .
 eq replaceWithF(FS, NeL, N) = $replaceWithF(FS, noFlushArc, NeL, N) .
 op $replaceWithF : FlushArcs FlushArcs NeLab Nat -> FlushArcs .
 eq $replaceWithF(noFlushArc, FS, NeL, N) = FS .
 eq $replaceWithF(p(L) >> S' ; FS, FS', NeL, N) = $replaceWithF(FS, p(replaceWith(L, NeL, N)) >> replaceWithS(S', NeL, N) ; FS', NeL, N) .
 
 *** derived definitions of placesM
 op placesM : Ematrix NeList{String}  -> Pset .
 eq placesM([X,Y,Z], NWs) = placesB(X, NWs) U placesB(Y, NWs) U placesB(Z, NWs) .
 eq placesM([X,Y], NWs) = placesB(X, NWs) U placesB(Y, NWs) .
 eq placesM(Q' f: FS, NWs) = placesM(Q', NWs) U placesF(FS, NWs) . 
 op placesF : FlushArcs NeList{String} -> Pset .
 eq placesF(FS, NWs) = $placesF(FS, emptyPset, NWs) .
 op $placesF : FlushArcs Pset NeList{String} -> Pset  .
 eq $placesF(noFlushArc, S, NWs) = S .
 eq $placesF(p(L) >> S' ; FS, S, NWs) = $placesF(FS, if hasSuffix(L, NWs) then p(L) else emptyPset fi U placeS(S', NWs), NWs) .
 
 *** defined analogously (to do)
 op placesM : Ematrix List{String} NeLab  -> Pset .
 
 *** op match : Tmatrix List{String} NeLab -> Tmatrix .
 *** eq match([X,Y,Z], Ws, NeL) = [match(X, Ws, NeL), match(Y, Ws, NeL), match(Z, Ws, NeL)] .
 *** eq match([X,Y], Ws, NeL) = [match(X, Ws, NeL), match(Y, Ws, NeL)] .
 *** sub-matrices based on the suffix
 *** op sumatrix : Tmatrix NeList{String} -> Tmatrix .
 *** eq sumatrix([X,Y,Z], NWs) = [subag(X, NWs), subag(Y, NWs), subag(Z, NWs)] .
 *** eq sumatrix([X,Y], NWs) = [subag(X, NWs), subag(Y, NWs)] .
 *** op sumatrix : Tmatrix List{String} NeLab -> Tmatrix .
 *** eq sumatrix([X,Y,Z], NWs, NeL) = [subag(X, NWs, NeL), subag(Y, NWs, NeL), subag(Z, NWs, NeL)] . *** optimization
 *** eq sumatrix([X,Y], NWs, NeL) = [subag(X, NWs, NeL), subag(Y, NWs, NeL)] . 
 *** eq sumatrix([X,Y,Z], emptyLs, NeL) = [subag(X, NeL), subag(Y, NeL), subag(Z, NeL)] .
 *** eq sumatrix([X,Y], emptyLs, NeL) = [subag(X, NeL), subag(Y, NeL)] .
 ***
  
endfm