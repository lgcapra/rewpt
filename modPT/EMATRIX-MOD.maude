in PBAG-MOD
in PSET-MOD
in ../EMATRIX

fmod EMATRIX-MOD is
 pr PBAG-MOD .
 pr PSET-MOD .
 pr EMATRIX{Plab} .
 
 vars X Y Z X' Y' Z' : Pbag .
 vars P P' P'' : Place .
 vars N N' C1 C2 : Nat .
 vars K K' : NzNat .
 var Q : Ematrix . var Q' : Tmatrix .
 vars L L'  : Lab . var NeL  : NeLab .
 var Ws :  List{String} . var NWs : NeList{String} .
 var F : FlushArc . var FS FS' : FlushArcs .
 vars S S'  : Pset .
 
 *** add a new label to a matrix' elements (version specifying places to share)
 op addLabM : Ematrix Lab Pset -> Ematrix . 
 eq addLabM([X,Y,Z], L, S) = [addLab(X, L, S), addLab(Y, L, S), addLab(Z, L, S)] .
 eq addLabM([X,Y], L, S) = [addLab(X, L, S), addLab(Y, L, S)] .
 eq addLabM(Q' f: FS, L, S) = addLabM(Q', L, S) f: addLabF(FS, L, S) .
 op addLabF : FlushArcs Lab Pset -> FlushArcs . 
 eq addLabF(FS, L, S) = $addLabF(FS, noFlushArc, L, S) .
 op $addLabF : FlushArcs FlushArcs Lab Pset -> FlushArcs .
 eq $addLabF(noFlushArc, FS, L, S) = FS .
 eq $addLabF(P >> S' ; FS, FS', L, S) = $addLabF(FS, addLabP(P, L, S) >> addLab(S', L, S) ; FS', L, S) .
 
 *** no elements to share
 op addLabM : Ematrix Lab -> Tmatrix . *** overloaded
 eq addLabM(Q, L) = addLabM(Q, L, emptyPset) .

 ***
 op replaceWithM : Ematrix NeLab Nat -> Tmatrix .
 eq replaceWithM([X,Y,Z], NeL, N) = [replaceWith(X, NeL, N), replaceWith(Y, NeL, N), replaceWith(Z, NeL, N)] .
 eq replaceWithM([X,Y], NeL, N) = [replaceWith(X, NeL, N), replaceWith(Y, NeL, N)] .
 eq replaceWithM(Q' f: FS, NeL, N) = replaceWithM(Q', NeL, N) f: replaceWithF(FS, NeL, N) .
 op replaceWithF : FlushArcs NeLab Nat -> FlushArcs .
 eq replaceWithF(FS, NeL, N) = $replaceWithF(FS, noFlushArc, NeL, N) .
 op $replaceWithF : FlushArcs FlushArcs NeLab Nat -> FlushArcs .
 eq $replaceWithF(noFlushArc, FS, NeL, N) = FS .
 eq $replaceWithF(P >> S' ; FS, FS', NeL, N) = $replaceWithF(FS, replaceWithP(P, NeL, N) >> replaceWith(S', NeL, N) ; FS', NeL, N) .
 
 *** derived definitions of placesM
 op placesM : Ematrix List{String}  -> Pset .
 eq placesM([X,Y,Z], Ws) = places(X, Ws) U places(Y, Ws) U places(Z, Ws) .
 eq placesM([X,Y], Ws) = places(X, Ws) U places(Y, Ws) .
 eq placesM(Q' f: FS, Ws) = placesM(Q', Ws) U placesF(FS, Ws) . 
 op placesF : FlushArcs List{String} -> Pset .
 eq placesF(FS, Ws) = $placesF(FS, emptyPset, Ws) .
 op $placesF : FlushArcs Pset NeList{String} -> Pset  .
 eq $placesF(noFlushArc, S, Ws) = S .
 eq $placesF(P >> S' ; FS, S, Ws) = $placesF(FS, places(P U S', Ws), Ws) .
 
 *** defined analogously (to do)
 *** op placesM : Ematrix List{String} NeLab  -> Pset .
 
 *** op match : Tmatrix List{String} NeLab -> Tmatrix .
 *** eq match([X,Y,Z], Ws, NeL) = [match(X, Ws, NeL), match(Y, Ws, NeL), match(Z, Ws, NeL)] .
 *** eq match([X,Y], Ws, NeL) = [match(X, Ws, NeL), match(Y, Ws, NeL)] .
 *** sub-matrices based on the suffix
 *** op sumatrix : Tmatrix NeList{String} -> Tmatrix .
 *** eq sumatrix([X,Y,Z], NWs) = [subag(X, NWs), subag(Y, NWs), subag(Z, NWs)] .
 *** eq sumatrix([X,Y], NWs) = [subag(X, NWs), subag(Y, NWs)] .
 *** op sumatrix : Tmatrix List{String} NeLab -> Tmatrix .
 *** eq sumatrix([X,Y,Z], NWs, NeL) = [subag(X, NWs, NeL), subag(Y, NWs, NeL), subag(Z, NWs, NeL)] . *** optimization
 *** eq sumatrix([X,Y], NWs, NeL) = [subag(X, NWs, NeL), subag(Y, NWs, NeL)] . 
 *** eq sumatrix([X,Y,Z], emptyLs, NeL) = [subag(X, NeL), subag(Y, NeL), subag(Z, NeL)] .
 *** eq sumatrix([X,Y], emptyLs, NeL) = [subag(X, NeL), subag(Y, NeL)] .
 ***
  
endfm