in PT-EMU

fmod PT-FMS is
 protecting NET-OP .
 ops sline sload sass sfault faultysload faultysass :  Nat -> Imatrix .
 ops line load ass fault faultyload faultyass : Nat -> ImatrixT . 
 ops cycle PL faultycycle faultyPL : Nat -> Net .
 op NPL : NzNat Nat  -> Net .
 op NPL : NzNat -> Net .
 eq NPL(N) = NPL(N, 0) .
 op NPLsys : NzNat -> System .
 ops M : -> NzNat [memo] . *** model's parameters: pieces worked at each cycle, number of replicated PLs
 eq M = 6  .
 var I : Nat . 
 var N : NzNat .
 eq sline(I) =  [1 . p(< "work" ; I >) , 1 . p(< "ass" ; I >), 1 . p(< "faulty" ; I >) ] .
 eq line(I) = t(< "line" ; I >) |-> sline(I) .
 eq sfault(I) =  [1 . p(< "focc" ; I >) , 1 . p(< "faulty" ; I >), nilP ] .
 eq fault(I) = t(< "fault" ; I >) |-> sfault(I) .
 eq sload(I) = [1 . p(< "start" ; I >) , 1 . p(< "work" ; I >) , nilP ] .
 eq load(I) = t(< "load" ; I >) |-> sload(I) .
 eq sass(I) =  [1 . p(< "ass" ; I >) , 1 . p(< "start" ; I >)  , nilP ] .
 eq ass(I)  = t(< "ass" ; I >) |-> sass(I) .
 eq cycle(I) = load(I) ; line(I) ; ass(I) ; fault(I) .
 eq PL(I) = replica&share(cycle(I), 2, "L", p (< "focc" ; I >) U p(< "start" ; I >), t(< "ass" ; I >) U t(< "load" ; I >)) . *** a PL is built of two symmetric lines 
 eq NPL(N, I) = replica&share(PL(I), N, "PL", p(< "start" ; I >), emptyTset) .
 eq NPLsys(N) = setMark(setMark(NPL(N), "focc" "PL", 1), "start", M) .
 *** faulty PL
 eq faultysload(I) =  [2 . p(< "start" ; I >) , 2 . p(< "work" ; I >) , nilP ] .
 eq faultysass(I)  =  [2 . p(< "ass" ; I >) , 2 . p(< "start" ; I >)  , nilP ] .
 eq faultyload(I) = t(< "load" ; I >) |-> faultysload(I) . 
 eq faultyass(I)  = t(< "ass" ; I >) |-> faultysass(I) .
 eq faultycycle(I) = faultyload(I) ; line(I) ; faultyass(I) ; fault(I) .
 eq faultyPL(I) = replica&share(faultycycle(I), 1, "fPL", "start",  emptyStr) . *** a faulty PL is built of 1 line
endfm

mod RWPT-FMS is
 pr  PT-FMS .
 inc PT-EMU .
 vars N N' : Net .
 vars Tload Tfail Tfail1 Tfail2 Tass Tline Tline1 Tline2  : Tran .
 vars P0 P1 P2 P3 P4 P5 P6 P7 : Place .
 var S : Pbag .
 var K : NzNat .
 var I : Nat .
 var W : String .
 vars L L0 L1 L2 L3 L4 L5 L6 L7 : Lab .
 
 *** crl [syr1] : N S + 1 . P7 => ( N' ; Tload |-> [2 . P1, 2 . P2, nilP] ;  Tass |-> [2 . P4, 2 . P1, nilP]) set(S, P3, 0) + S[P3] . P2 + 1 . P0 
 ***           if (N' ; Tload |-> [2 . P1, 1 . P2 + 1 . P3, nilP ] ; Tline2 |-> [1 . P3, 1 . P5, 1 . P7] ; Tass |-> [1 . P4 + 1 . P5, 2 . P1, nilP ] ; Tfail2 |-> [1 . P0, 1 . P7, nilP]) := N /\ dead(N S + 1 . P7)  .
*** crl [syr1new] : N S + 1 . p(L7 < "faulty" ; I >) => ( N' ; Tload |-> [2 . P1, 2 . P2, nilP] ;  Tass |-> [2 . P4, 2 . P1, nilP]) set(S, P3, 0) + S[P3] . P2 + 1 . P0 
***          if (N' ; NPL(1, I)) := N /\ dead(N S + 1 . P7)  .
 *** crl [syr2] : N  S + 1 . P6  => N' (set(set(S, P1, S[P1] + S[P2] + S[P4]), P2, 0)) - 1 . P4 if (N' ; Tfail1 |-> [1 . P0, 1 . P6, nilP] ; Tload |-> [2 . P1, 2 . P2, nilP] ; Tline1 |-> [1 . P2, 1 . P4, 1 . P6] ; Tass |-> [2 . P4, 2 . P1, nilP ]) := N  /\ N' =/= emptyN /\
 ***             dead((Tload |-> [2 . P1, 2 . P2, nilP] ;  Tass |-> [2 . P4, 2 . P1, nilP ]) S) .
*** including minimization

endm