in BAGP
in ATYPE

fmod IMATRIX is
 pr BAGP .
 pr ATYPE .
 sort Imatrix .
 op [_,_,_] : Pbag Pbag Pbag -> Imatrix [ctor] .
 
 vars X Y Z X' Y' Z' : Pbag .
 vars P P' P'' : Place .
 vars N N' C1 C2 : Nat .
 vars K K' : NzNat .
 vars Q Q' : Imatrix .
 var L   : Lab .
 var NeL  : NeLab .
 var S  : Pset .
 var Ws :  List{String} .
 var NWs : NeList{String} .
 
 ops I O H : Imatrix -> Pbag .
 eq I([X,Y,Z]) = X .
 eq O([X,Y,Z]) = Y .
 eq H([X,Y,Z]) = Z .

 op enabled : Imatrix Pbag -> Bool .
 eq enabled([X,Y,Z], X') = X <= X' and-then Z >' X' .

 op _(_) : Imatrix Atype -> Pbag [prec 23] . *** introduced for convenience
 var a : Atype .
 eq Q(i) = I(Q) .
 eq Q(o) = O(Q) . 
 eq Q(h) = H(Q) .

 op in :  Imatrix Place -> Bool . *** test the existence of a place
 eq in([X + K . P, Y, Z], P) = true .
 eq in([X, Y + K . P, Z], P) = true .
 eq in([X, Y, Z + K . P], P) = true .
 eq in(Q, P) = false [owise] .

 op dead : Imatrix -> Bool .  *** checks for structurally dead transitions 
 eq dead([K . P + X, Y, K' . P + Z]) = K >= K' [metadata "dead tq"] .
 eq dead(Q) = false [owise] .

 op places : Imatrix -> Pset .
 eq places([X,Y,Z]) = support(X) U support(Y) U support(Z) .
 
 *** pair-wise sum
 op _+_  : Imatrix Imatrix -> Imatrix [prec 41 assoc comm] .
 eq [X,Y,Z] + [X',Y',Z'] = [X' + X, Y' + Y, Z' + Z] .
 *** set a given place's arc type
 op set : Imatrix Atype Place Nat -> Imatrix .
 eq set([X,Y,Z], i, P, N) = [set(X,P,N), Y, Z] .
 eq set([X,Y,Z], o, P, N) = [X, set(Y,P,N), Z] .
 eq set([X,Y,Z], h, P, N) = [X, Y, set(Z,P,N)] .
 
 *** net-algebra ops: add a new label to a matrix' elements
 *** removes all places from a local matrix
 op remove :  Imatrix Pset -> Imatrix .
 eq remove([X,Y,Z], S) = [remove(X, S),remove(Y, S),remove(Z, S)] .
 *** add a new label to a matrix' elements
 op addLab : Imatrix Lab -> Imatrix . *** overloaded
 eq addLab([X,Y,Z], L) = [addLab(X, L), addLab(Y, L), addLab(Z, L)] .
 *** version specifying elements to share
 op addLab : Imatrix Lab Pset -> Imatrix . 
 eq addLab([X,Y,Z], L, S) = [addLab(X, L, S), addLab(Y, L, S), addLab(Z, L, S)] .
 
 *** sub-matrices based on the suffix
 op sumatrix : Imatrix NeList{String} -> Imatrix .
 eq sumatrix([X,Y,Z], NWs) = [subag(X, NWs), subag(Y, NWs), subag(Z, NWs)] .
 op sumatrix : Imatrix List{String} NeLab -> Imatrix .
 eq sumatrix([X,Y,Z], Ws, NeL) = [subag(X, Ws, NeL), subag(Y, Ws, NeL), subag(Z, Ws, NeL)] .
 op match : Imatrix List{String} NeLab -> Imatrix .
 eq match([X,Y,Z], Ws, NeL) = [match(X, Ws, NeL), match(Y, Ws, NeL), match(Z, Ws, NeL)] .

 *** derived definitions of places
 op places : Imatrix NeList{String}  -> Pset .
 eq places(Q, NWs) = places(sumatrix(Q, NWs)) .
 op places : Imatrix List{String} NeLab  -> Pset .
 eq places(Q, Ws, NeL) = places(sumatrix(Q, Ws, NeL)) .
 op matchplaces : Imatrix List{String} NeLab  -> Pset .
 eq matchplaces(Q, Ws, NeL) = places(match(Q, Ws, NeL)) .
 
 op replaceWith : Imatrix NeLab Nat -> Imatrix .
 eq replaceWith([X,Y,Z], NeL, N) = [replaceWith(X, NeL, N), replaceWith(Y, NeL, N), replaceWith(Z, NeL, N)] .
  
endfm

view Imatrix from TRIV to IMATRIX is 
 sort Elt to Imatrix . 
endv
