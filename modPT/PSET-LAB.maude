in ../PSET
in PLAB

*** new: we must consider place capacity
fmod PSET-LAB is 
   pr PSET{Plab} .
   var J  : Nat . vars K K' : NzNat . var S : Pset . vars P P' : Place .
   vars L L' : Lab . var NeL : NeLab . var WL : List{String} .
   op replaceWithP : Place NeLab Nat -> Place .
   eq replaceWithP(p(L), NeL, J) = p(replaceWithL(L, NeL, J)) .
   eq replaceWithP(p(L, K), NeL, J) = p(replaceWithL(L, NeL, J), K) .
  
   op addLabP : Place Lab Pset -> Place . 
   eq addLabP(p(L'), L, S) = if p(L') in S then p(L') else p(L' L) fi   .
   eq addLabP(p(L', K), L, S) = if p(L', K) in S then p(L', K) else p(L' L, K) fi   .
   
   op placesP : Place List{String} -> Pset .
   eq placesP(P, WL) = if hasSuffix(lab(P), WL) then P else emptyPset fi .
   op placesP : Place NeLab -> Pset .
   eq placesP(p(L' NeL), NeL) = p(L' NeL) .
   eq placesP(P, NeL) = emptyPset [owise] .
   op placesP : Place -> Pset .
   eq placesP(P) = P . *** trivial
   

   *** checks for the existence in a set of a place whose label matches the given suffix -- used in the example( RWLPT)
   *** op exists : Pset NeLab  -> Bool .
  *** ceq exists(P U S, NeL) = true if L' NeL := lab(P)  .
   *** eq exists(S, NeL) = false [owise] .

   *** new! (takes place capacity into account, used in PBAG-LAB to define a total order between multisets)
   op cmp : Place Place -> Nat .
   eq cmp(p(L), p(L', K)) = 1 . *** unbounded places are "less" than bounded places
   eq cmp(p(L, K), p(L')) = 2 .
  ceq cmp(p(L, K), p(L', K')) = if K < K' then 1 else 2 fi if K =/= K' . 
   eq cmp(P, P') = cmp(lab(P), lab(P')) [owise] . *** current version
endfm

