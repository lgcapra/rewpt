in IMATRIX
*** in ../shared/MAP+
in ../shared/MAP-SET

*** signature of a PT net -- includes a simple(r) net-representation in which transitions are implicitly represented
fmod PT-NET is
 pr MAP-SET{Tran,Imatrix} * (sort Map{Tran,Imatrix} to Net, sort Entry{Tran,Imatrix} to ImatrixT, op emptyM to emptyN,
                             sort Set{Tran} to Tset, sort NeSet{Tran} to NeTset, op emptyS to emptyTset) . *** ImatrixM is a view on IMATRIX-MOD (like Imatrix on IMATRIX)
 pr SORTABLE-LIST{Tran<}  * (sort List{Tran<} to Tlist, sort NeList{Tran<} to NeTlist, op nil to emptyTlist ) .
 pr SORTABLE-LIST{Place<} * (sort List{Place<} to Plist, sort NeList{Place<} to NePlist, op nil to emptyPlist ) .
 pr PAIR{Pset, Nat} . *** multiple return value (defined for convenience)
 pr SET+{Imatrix} * (sort Set{Imatrix} to Snet, sort NeSet{Imatrix} to NeSnet, op emptyS to emptySn) . *** simple net-representation as a set of local inc. matrices
 pr SET+{String}  * (op emptyS to emptyStr) .
 vars  N N'  : Net .
 vars T T' : Tran .
 vars P P' P'' : Place .
 vars Y J  : Nat .
 vars K K' : NzNat .
 vars I O H B : Pbag .
 vars Q Q' : Imatrix . 
 vars S S' PS : Pset .
 var TS TS' : Tset .  
 vars L L1 : Plist .
 var W : String .
 var WL :  List{String} .
 var WS :  Set{String} .
 var F :  Bool .
 
 op welldef : Net -> Bool .
 eq welldef(N) = repeatedKeys?(N) == false . ***  and-then N =/= emptyN  . leaves the comment to consider empty nets as invalid 
 
 op welldef : Snet -> Bool .
 eq welldef(Sn) = true . ***  and Sn =/= emptySn  . *** leaves the comment to consider empty nets as invalid 

 ops In Out Inh : Net Tran -> [Pbag] . 
 eq In(T |-> Q ; N, T)  = I(Q) .
 eq Out(T |-> Q ; N, T) = O(Q) .
 eq Inh(T |-> Q ; N, T) = H(Q) .
 *** checks for structurally dead transitions
 op dead : ImatrixT -> Bool .   
 eq dead(T |-> Q) = dead(Q) .
 *** test the existence of a place
 op in :  Net Place -> Bool . 
ceq in(T |-> Q ; N, P) = true if in (Q, P) .
 eq in(N, P) = false [owise] .
 *** test the existence of a transition
 op in :  Net Tran -> Bool . 
 eq in(N, T) = $hasMapping(N, T) .
 *** gets out the places of the net
 op places : Net -> Pset .
 eq places(N) = places(toSimpleNet(N)) .
 *** gets out the places whose labels match the given prefix 
 op places : Net List{String} -> Pset .
 eq places(N, WL) = places(toSimpleNet(N), WL) .
 *** gets out the places whose labels match the given prefix (first elements) set 
 op places : Net Set{String} -> Pset .
 eq places(N, WS) = places(toSimpleNet(N), WS) .
 *** returns the sorted list of places of a netop placeList : Net -> Plist .
 op placeList : Net -> Plist . 
 eq placeList(N) = $makePlist(places(N), emptyPlist) .
 op $makePlist : Pset Plist -> Plist . 
 eq $makePlist(emptyPset, L) = sort(L) . 
 eq $makePlist(P U S, L) = $makePlist(S, P L) . 
 *** returns the sorted list of transitions
 var TL : Tlist .
 op tranList : Net -> Tlist .  
 eq tranList(N) = $makeTlist(N,emptyTlist) .
 op $makeTlist : Net Tlist -> Tlist . 
 eq $makeTlist(emptyN, TL) = sort(TL) . 
 eq $makeTlist(T |-> Q ; N, TL) = $makeTlist(N, T TL) .
 *** defined for convenience (just a renaming) 
 op transitions : Net -> Tset . 
 eq transitions(N) = keySet(N) .
 *** transitions with a given suffix in their labels
 op transitions : Net List{String} -> Tset . 
 eq transitions(N, WL) = $transitions(keySet(N), WL, emptyTset) .  
 op $transitions : Tset List{String} Tset -> Tset . 
ceq $transitions(T U TS, WL, TS') = $transitions(TS, WL, T U TS') if hasPrefix(T, WL) .
 eq $transitions(TS, WL, TS') = TS' [owise] .
 *** gets out the transitions whose labels match the given prefix (first elements) set - NOTE reuse $transitions
 op transitions : Net Set{String} -> Tset .
 eq transitions(N, W) = $transitions(keySet(N), W, emptyTset) . *** avoid recursion (W is both a set and a list)
 eq transitions(N, WS) = $$transitions(keySet(N), WS, emptyTset) [owise] .
 op $$transitions : Tset Set{String} Tset -> Tset .
 eq $$transitions(TS', emptyStr, TS) = TS .
 eq $$transitions(TS', W U WS, TS) = $$transitions(TS', WS, TS U $transitions(TS', W, emptyTset)) .
 
 var X : NePset .
 *** remove places
 op remove :  Net Pset -> Net .
 eq remove(N, emptyPset) = N .
 eq remove(N, X) = $remove(N, emptyN, X) .
 op $remove : Net Net NePset -> Net .
 eq $remove(emptyN, N, X) = N .
 eq $remove(T |-> Q ; N', N, X) = $remove(N', T |-> remove(Q, X) ; N, X).
 *** add a new label to the net's places (and transitions, only to avoid "duplicated" transitions)
 *** version including elements to share (i.e., to which not to add the label)
 var Lab : ModLab .
 op addLab : Net ModLab Pset Tset -> Net . 
 eq addLab(N, Lab, S, TS) = $addLab(N, emptyN, Lab, S, TS) .
 op $addLab : Net Net ModLab Pset Tset -> Net .
 eq $addLab(emptyN, N, Lab, S, TS) = N .
 eq $addLab(T |-> Q ; N', N, Lab, S, TS) = $addLab(N', (if T in TS then T else addLab(T, Lab) fi) |-> addLab(Q, Lab, S) ; N, Lab, S, TS) .
 *** simple (default) version
 op addLab : Net ModLab -> Net . 
 eq addLab(N, Lab) = addLab(N, Lab, emptyPset, emptyTset) .
 *** rename a place (build on Imatrix.rename)
 op rename : Net Place Place -> [Net] .
 eq rename(N, P, P') = $rename(N, emptyN, P, P') .
 op $rename : Net Net Place Place -> [Net] .
 eq $rename(emptyN, N, P, P') = N .
 eq $rename(T |-> Q ; N', N, P, P') = $rename(N',  T |-> rename(Q, P, P') ; N, P, P') .
 
 *** rename a transition (helpful?) -- same semantics as place rename 
 op rename : Net Tran Tran -> [Net] . *** partial op
ceq rename(T |-> Q ; N, T, T') = T' |-> Q ; N if N[T'] == undefined .
ceq rename(N, T, T') = N if N[T] == undefined .  
  
 *** simple net representation uniquely based on local inc. matrices (these operators are duplicates)
 vars Sn Sn' : Snet .
 op toSimpleNet : Net -> Snet .
 eq toSimpleNet(N) = $toSimpleNet(N, emptySn) .
 op $toSimpleNet : Net Snet -> Snet .
 eq $toSimpleNet(emptyN, Sn) = Sn .
 eq $toSimpleNet(T |-> Q ; N, Sn) = $toSimpleNet(N, Q U Sn) .
 *** same operators defined for Net
 op dead : Imatrix -> Bool .  *** checks for structurally dead transitions 
 eq dead([K . P + I, O, K' . P + H]) = K >= K' [metadata "dead tq"] .
 eq dead(Q) = false [owise] .
 *** set of places of the (simple) net
 op places : Snet -> Pset .
 eq places(Sn) = $places(Sn, emptyPset) .  
 op $places : Snet Pset -> Pset . 
 eq $places(emptySn, S) = S . 
 eq $places(Q U Sn, S) = $places(Sn, S U places(Q)) .
 *** set of places whose label's suffix matches the given one
 op places : Snet List{String} -> Pset .
 eq places(Sn, WL) = $places(Sn, WL, emptyPset) .  
 op $places : Snet List{String} Pset -> Pset . 
 eq $places(emptySn, WL, S) = S . 
 eq $places(Q U Sn, WL, S) = $places(Sn, WL, S U places(WL, Q)) . *** places in Imatrix has the args in reverse order to avoid looping
 *** gets out the places whose labels match the given set of prefixes (first elements) -- NOTE reuse $places (recall that W is both a list and a set)
 op places : Snet Set{String} -> Pset .
 eq places(Sn, W) = $places(Sn, W, emptyPset) .
 eq places(Sn, WS) = $$places(Sn, WS, emptyPset) [owise] .
 op $$places : Snet Set{String} Pset -> Pset .
 eq $$places(Sn, emptyStr, S) = S .
 eq $$places(Sn, W U WS, S) = $$places(Sn, WS, S U $places(Sn, W, emptyPset)) .
 
 *** list of places of the (simple) net
 op placeList : Snet -> Plist . 
 eq placeList(Sn) = $makePlist(places(Sn),emptyPlist) .
 
 *** add a new label to a simple-net's places (specifies places in which not to apply)
 op addLab : Snet ModLab Pset -> Snet . 
 eq addLab(Sn, Lab, S) = $addLab(Sn, emptySn, Lab, S) .
 op $addLab : Snet Snet ModLab Pset -> Snet .
 eq $addLab(emptySn, Sn, Lab, S) = Sn .
 eq $addLab(Q U Sn', Sn, Lab, S) = $addLab(Sn', addLab(Q, Lab, S) U Sn, Lab, S) .
 *** simple version
 op addLab : Snet ModLab Pset -> Snet . 
 eq addLab(Sn, Lab, S) = addLab(Sn, Lab, emptyPset) .
 
 *** rename a place (build on Imatrix.rename)
 op rename : Snet Place Place -> [Snet] .
 eq rename(Sn, P, P') = $rename(Sn, emptySn, P, P') .
 op $rename : Snet Snet Place Place -> [Snet] .
 eq $rename(emptySn, Sn, P, P') = Sn .
 eq $rename(Q U Sn', Sn, P, P') = $rename(Sn',  rename(Q, P, P') U Sn, P, P') .

endfm

*** trivial view to a PT-NET
view PTnet from TRIV to PT-NET is 
 sort Elt to Net .
endv