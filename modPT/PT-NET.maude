in IMATRIX
in ../shared/MAP+

*** signature of a PT net -- includes a simple(r) net-representation in which transitions are implicitly represented
fmod PT-NET is
 pr MAP+{Tran,Imatrix} * (sort Map{Tran,Imatrix} to Net, sort Entry{Tran,Imatrix} to ImatrixT, op emptyM to emptyN) . *** ImatrixM is a view on IMATRIX-MOD (like Imatrix on IMATRIX)
 pr SORTABLE-LIST{Tran<}  * (sort List{Tran<} to Tlist, sort NeList{Tran<} to NeTlist, op nil to emptyTlist ) .
 pr SORTABLE-LIST{Place<} * (sort List{Place<} to Plist, sort NeList{Place<} to NePlist, op nil to emptyPlist ) .
 pr PAIR{Pset, Nat} . *** multiple return value (defined for convenience)
 pr SET+{Imatrix} * (sort Set{Imatrix} to Snet, sort NeSet{Imatrix} to neSnet, op emptyS to emptySn) . *** simple net-representation as a set of local inc. matrices

 vars  N N'  : Net .
 vars T T' : Tran .
 vars P P' P'' : Place .
 vars Y J  : Nat .
 vars K K' : NzNat .
 vars I O H B : Pbag .
 vars Q Q' : Imatrix .
 
 vars S S' SP : Pset . 
 vars L L1 : Plist .
 vars W :  List{String} .
 var F :  Bool .
 
 op welldef : Net -> Bool .
 eq welldef(N) = repeatedKeys?(N) == false . ***  and-then N =/= emptyN  . leaves the comment to consider empty nets as invalid 
 
 op welldef : Snet -> Bool .
 eq welldef(Sn) = true . ***  and Sn =/= emptySn  . *** leaves the comment to consider empty nets as invalid 

 ops In Out Inh : Net Tran -> [Pbag] . 
 eq In(T |-> Q ; N, T)  = I(Q) .
 eq Out(T |-> Q ; N, T) = O(Q) .
 eq Inh(T |-> Q ; N, T) = H(Q) .
 *** checks for structurally dead transitions
 op dead : ImatrixT -> Bool .   
 eq dead(T |-> Q) = dead(Q) .
 *** test the existence of a place
 op in :  Net Place -> Bool . 
ceq in(T |-> Q ; N, P) = true if in (Q, P) .
 eq in(N, P) = false [owise] .
 *** test the existence of a transition
 op in :  Net Tran -> Bool . 
 eq in(N, T) = $hasMapping(N, T) .
 *** gets out the places of the net
 op places : Net -> Pset .
 eq places(N) = places(toSimpleNet(N)) .
 *** gets out the places whose labels match the given prefix 
 op places : Net List{String} -> Pset .
 eq places(N, W) = places(toSimpleNet(N), W) .
 *** returns the sorted list of places of a netop placeList : Net -> Plist .
 op placeList : Net -> Plist . 
 eq placeList(N) = $makePlist(places(N), emptyPlist) .
 op $makePlist : Pset Plist -> Plist . 
 eq $makePlist(emptyPset, L) = sort(L) . 
 eq $makePlist(P U S, L) = $makePlist(S, P L) . 
 *** returns the sorted list of transitions
 var TL : Tlist .
 op tranList : Net -> Tlist .  
 eq tranList(N) = $makeTlist(N,emptyTlist) .
 op $makeTlist : Net Tlist -> Tlist . 
 eq $makeTlist(emptyN, TL) = sort(TL) . 
 eq $makeTlist(T |-> Q ; N, TL) = $makeTlist(N, T TL) . 
 *** rename a place as another
 op rename : Net Place Place -> Net . 
 eq rename(N, P, P') = $rename(N, emptyN, P, P') .
 op $rename : Net Net Place Place  -> Net .
 eq $rename(emptyN, N, P, P') = N .
 eq $rename((T |-> Q ; N'), N, P, P') = $rename(N', (T |-> rename(Q, P, P') ; N), P, P') .
 *** merge two places 
 op merge : Net Place Place Place -> Net . 
 eq merge(N, P, P',P'') = $merge(N, emptyN, P, P',P'') .
 op $merge : Net Net Place Place Place  -> Net .
 eq $merge(emptyN, N, P, P',P'') = N .
 eq $merge((T |-> Q ; N'), N, P, P',P'') = $merge(N', (T |-> merge(Q, P, P',P'') ; N), P, P',P'') .
 
 *** rename a transition
 op rename : Net Tran Tran -> Net .
 eq rename((T |-> Q ; N), T, T') = T' |-> Q ; N .
 eq rename(N, T, T') = N [owise] .  

 *** add a new label to the net's places (and transitions, only to avoid "duplicated" transitions)
 var Lab : ModLab .
 op addLab : Net ModLab -> Net . 
 eq addLab(N, Lab) = $addLab(N, emptyN, Lab) .
 op $addLab : Net Net ModLab -> Net .
 eq $addLab(emptyN, N, Lab) = N .
 eq $addLab((T |-> Q ; N'), N, Lab) = $addLab(N', (addLab(T, Lab) |-> addLab(Q, Lab) ; N), Lab) .
 *** remove some places
 var X : NePset .
 op remove :  Net Pset -> Net .
 eq remove(N, emptyPset) = N .
 eq remove(N, X) = $remove(N, emptyN, X) .
 op $remove : Net Net NePset -> Net .
 eq $remove(emptyN, N, X) = N .
 eq $remove(T |-> Q ; N', N, X) = $remove(N', T |-> remove(Q, X) ; N, X).
  
 *** simple net representation uniquely based on local inc. matrices (these operators are duplicates)
 vars Sn Sn' : Snet .
 op toSimpleNet : Net -> Snet .
 eq toSimpleNet(N) = $toSimpleNet(N, emptySn) .
 op $toSimpleNet : Net Snet -> Snet .
 eq $toSimpleNet(emptyN, Sn) = Sn .
 eq $toSimpleNet(T |-> Q ; N, Sn) = $toSimpleNet(N, Q U Sn) .
 *** same operators defined for Net
 op dead : Imatrix -> Bool .  *** checks for structurally dead transitions 
 eq dead([K . P + I, O, K' . P + H]) = K >= K' [metadata "dead tq"] .
 eq dead(Q) = false [owise] .
 *** set of places of the (simple) net
 op places : Snet -> Pset .
 eq places(Sn) = $places(Sn, emptyPset) .  
 op $places : Snet Pset -> Pset . 
 eq $places(emptySn, S) = S . 
 eq $places(Q U Sn, S) = $places(Sn, S U places(Q)) .
 *** set of places whose label's suffix matches the given one
 op places : Snet List{String} -> Pset .
 eq places(Sn, W) = $places(Sn, W, emptyPset) .  
 op $places : Snet List{String} Pset -> Pset . 
 eq $places(emptySn, W, S) = S . 
 eq $places(Q U Sn, W, S) = $places(Sn, W, S U places(W, Q)) . *** places in Imatrix has the args in reverse order to avoid looping
 *** list of places of the (simple) net
 op placeList : Snet -> Plist . 
 eq placeList(Sn) = $makePlist(places(Sn),emptyPlist) .
 *** rename a place as another one in a net
 op rename : Snet Place Place -> Snet . 
 eq rename(Sn, P, P') = $rename(Sn, emptySn, P, P') .
 op $rename : Snet Snet Place Place  -> Snet .
 eq $rename(emptySn, Sn, P, P') = Sn .
 eq $rename(Q U Sn', Sn, P, P') = $rename(Sn', rename(Q, P, P') U Sn, P, P') .
 *** rename a transition with another in a net

 *** add a new label to a simple-net's places
 op addLab : Snet ModLab -> Snet . 
 eq addLab(Sn, Lab) = $addLab(Sn, emptySn, Lab) .
 op $addLab : Snet Snet ModLab -> Snet .
 eq $addLab(emptySn, Sn, Lab) = Sn .
 eq $addLab(Q U Sn', Sn, Lab) = $addLab(Sn', addLab(Q, Lab) U Sn, Lab) .
endfm

*** trivial view to a PT-NET
view PTnet from TRIV to PT-NET is 
 sort Elt to Net .
endv