*** qui e altrove usiamo il preludio modificato anche se si potrebbe usare quello originale (nuova versione)
in ../PBAG
in PLAB

fmod PBAG-MOD is
 pr PBAG{Plab} .
 vars P P' P'' P''' : Place . 
 vars K K' : NzNat . vars I J : Nat .
 vars B B' B'' : Pbag . vars NeB NeB' : NePbag .
 vars EB EB' : ElPbag .
 vars L L' L'' : Lab . var E : Elab . vars NeL NeL' : NeLab .
 vars S S' S'' : Pset .
 vars W W' : String .
 var Ws : List{String} .
 var NeWs : NeList{String} .

 *** base ops (could be defined at label level)
 *** gets the text out of a Place's lab
 op strPlab : Place -> NeList{String} .
 eq strPlab(p(NeL)) = strLab(NeL) .
 *** append a new sub-label
 op addLabP : Place Lab -> Place . 
 eq addLabP(p(NeL), L) = p(NeL L) .
*** replaces in a place whose label match the given suffix the suffix header's index with the specified value (if different)
 op replaceWithP : Place NeLab Nat -> Place .
ceq replaceWithP(p(L' NeL), NeL, I) = p(L' < W ; I > L) if < W ; J > L := NeL /\ I =/= J .
 eq replaceWithP(P, NeL, I) = P [owise] .
 
 *** order relations
 op _<_ : Place Place -> Bool . *** strict total order
 eq p(NeL) < p(NeL') = lex(NeL, NeL') .
 op _<=_ : Place Place -> Bool . *** total order
 eq P <= P' = P == P' or-else P < P' . 
 op min :  Place Place ->  Place .
 eq min(P, P') = if P <=  P' then P else P' fi .
 
 **** derived definitions
 op hasSuffix : Place NeList{String} -> Bool .
 eq hasSuffix(p(NeL), NeWs) = hasSuffix(NeL, NeWs) .
 op hasSuffix : Place List{String} NeLab -> Bool . 
 eq hasSuffix(p(NeL), Ws, NeL') = hasSuffix(NeL, Ws, NeL') .
 op hasSuffix : Place NeLab -> Bool .
 eq hasSuffix(p(NeL), NeL') = hasSuffix(NeL, NeL') .
 *** match
 op match : Place List{String} NeLab -> Bool .
 eq match(p(NeL), Ws, NeL') = match(NeL, Ws, NeL') .
 op match : Place NeList{String} -> Bool .
 eq match(p(NeL), NeWs) = match(NeL, NeWs) .

 *** gives the sub-bag of places whose labes have (match) a given suffix (NOTE a String is also a NeList{String})
 op placesB : Pbag NeList{String} -> Pset .
 eq placesB(B, NeWs) = $placesB(B, NeWs, emptyPset) . 
 op $placesB : Pbag NeList{String} Pset -> Pset .
 eq $placesB(K . P + B, NeWs, S) = $placesB(B, NeWs, if hasSuffix(P, NeWs) then S U P else S fi)  .
 eq $placesB(nilP, NeWs, S) = S  .
 *** analogous, using match instead of hasSuffix (to define)
 op placesB : Pbag NeList{String} NeLab -> Pset .
 *** overloading on sets
 op placeS : Pset NeList{String} -> Pset .
 eq placeS(S, NeWs) = $placeS(S, NeWs, emptyPset) . 
 op $placeS : Pset NeList{String} Pset -> Pset .
 eq $placeS(P U S', NeWs, S) = $placeS(S', NeWs, if hasSuffix(P, NeWs) then S U P else S fi)  .
 eq $placeS(emptyPset, NeWs, S) = S  .
 *** analogous, using match instead of hasSuffix (to define)
 op placeS : Pset NeList{String} NeLab -> Pset .

 *** le: strict TO on bags obtained by permuting a bag's elements -- defined without passing through lists
 op cmp : ElPbag ElPbag -> Nat .   *** compare method between el. bags  -- results in {0,1,2}
 eq cmp(K . p(NeL), K . p(NeL')) = cmp(NeL, NeL') .
 eq cmp(K . P, K' . P') = if K < K' then 1 else 2 fi [owise] .
 op le  : Pbag Pbag -> Bool . *** to avoid any confusion with < , <= bag operators etc.
 eq le(B, B) = false .
 eq le(nilP, NeB) = true .
 eq le(NeB, nilP) = false .
 eq le(NeB + B', NeB + B'') = le(B', B'') . 
 eq le(NeB, NeB') = cmp(min(NeB), min(NeB')) == 1 [owise] .

 *** finds the min elementary bag, based on le
 op min : NePbag -> ElPbag .
 eq min(EB) = EB . *** optimization
 eq min(K . P + NeB) = min(NeB, K . P) . 
 op min : NePbag ElPbag -> ElPbag . 
 eq min(EB + NeB, EB') =  min(NeB, min(EB, EB')) .
 eq min(EB, EB) = EB .
 eq min(EB, EB') = if cmp(EB, EB') == 1 then EB else EB' fi [owise] .
 
 *** non-strict TO (based on lex)
 op leq : Pbag Pbag -> Bool .
 eq leq(B, B) = true .
 eq leq(B, B') = le(B, B') [owise] .
 
 *** -- operators used for net algebra -- 
 *** add a new label to bag's elements -- version specifying elements to share (i.e., to which not to add the label)
 op addLaB : Pbag Lab Pset -> Pbag . 
 eq addLaB(B, L, S) = $addLaB(B, nilP, L, S) .
 op $addLaB : Pbag Pbag Lab Pset -> Pbag .
 eq $addLaB(nilP, B, L, S) = B .
 eq $addLaB(K . P + B', B, L, S) = $addLaB(B', B + if P in S then K . P  else K . addLabP(P, L) fi, L, S)  .
 *** default
 op addLaB : Pbag Lab -> Pbag .
 eq addLaB(B, L) = addLaB(B, L, emptyPset) .

 *** overloading on sets
 op addLabS : Pset Lab Pset -> Pset . 
 eq addLabS(S, L, S') = $addLabS(S, emptyPset, L, S') .
 op $addLabS : Pset Pset Lab Pset -> Pset .
 eq $addLabS(emptyPset, S, L, S') = S .
 eq $addLabS(P U S', S'', L, S) = $addLabS(S', S'' U if P in S then P else addLabP(P, L) fi, L, S) .
 *** default
 op addLabS : Pset Lab -> Pset .
 eq addLabS(S, L) = addLabS(S, L, emptyPset) .

 
  *** replaces in all places whose label match the given suffix with a corresponding suffix having as header's index the specified value
 op replaceWithB : Pbag NeLab Nat -> Pbag . 
 eq replaceWithB(B, NeL, I) = $replaceWithB(B, nilP, NeL, I) .
 op $replaceWithB : Pbag Pbag NeLab Nat -> Pbag .
 eq $replaceWithB(K . P + B', B, NeL, I) = $replaceWithB(B', K . replaceWithP(P, NeL, I) + B, NeL, I) .
 eq $replaceWithB(nilP, B, NeL, I) = B .
 *** overloading on sets
 op replaceWithS : Pset NeLab Nat -> Pset . 
 eq replaceWithS(S, NeL, I) = $replaceWithS(S, emptyPset, NeL, I) .
 op $replaceWithS : Pset Pset NeLab Nat -> Pset .
 eq $replaceWithS(P U S', S, NeL, I) = $replaceWithS(S', replaceWithP(P, NeL, I) U S, NeL, I) .
 eq $replaceWithS(emptyPset, S, NeL, I) = S .

 *** set a weight for a set of places -- builds on set(B, P, I) defined in BAG module (note: P is a Set)
 op set : Pbag Pset Nat -> Pbag .
ceq set(B, S, I) = $set(B, S, I) if S :: Place == false . *** S is not a singleton (we avoid recursion)
 op $set : Pbag Pset Nat -> Pbag . 
 eq $set(B, emptyPset, I) = B .  
 eq $set(B, S U P , I) = $set(set(B, P, I), S , I) .

 *** checks for the existence in a set of a place whose label matches the given suffix 
 op existS : Pset NeLab  -> Bool .
 eq existS(p(L' NeL) U S, NeL) = true  .
 eq existS(S, NeL) = false [owise] .

*** bag version 
 op existsB : Pbag NeLab -> Bool .
 eq existsB(K . p(L' NeL) + B, NeL) = true  .
 eq existsB(B, NeL) = false [owise] .
 *** set version
 op existsgrS : Pset NeLab  -> Bool .
ceq existsgrS(p(L' < W ; J > L) U S, < W ; I > L) = true  if J > I .
 eq existsgrS(S, NeL) = false [owise] .
 *** bag version
 op existsgrB : Pbag NeLab  -> Bool .
ceq existsgrB(K . p(L' < W ; J > L) + B, < W ; I > L) = true  if J > I .
 eq existsgrB(B, NeL) = false [owise] .

 *** find the min suffix header's index non present in the set of places
 op minNotInS : Pset String Lab -> Nat .
 eq minNotInS(S, W, L) = $minNotInS(S, W, L, 0) .
 op $minNotInS : Pset String Lab Nat -> Nat . 
 eq $minNotInS(S, W, L, I) = if existS(S, < W ; I > L) then $minNotInS(S, W, L, I + 1) else I fi .  

 *** bag version (defined for efficiency)
 op minNotInB : Pbag String Lab -> Nat .
 eq minNotInB(B, W, L) = $minNotInB(B, W, L, 0) .
 op $minNotInB : Pbag String Lab Nat -> Nat . 
 eq $minNotInB(B, W, L, I) = if existsB(B, < W ; I > L) then $minNotInB(B, W, L, I + 1) else I fi .  

 *** returns the biggest suffix header's index in the specified set of places (-1 if no place with a matching suffix does exist)
 op maxInS : Pset String Lab -> Int .
ceq maxInS(p(L' NeL) U S, W, L) = J if < W ; J > L := NeL /\ existsgrS(S, NeL) == false .  
 eq maxInS(S, W, L) = -1 [owise] .
 *** bag version
 op maxInB : Pbag String Lab -> Int .
ceq maxInB(K . p(L' NeL) + B, W, L) = J if < W ; J > L := NeL /\ existsgrB(B, NeL) == false .  
 eq maxInB(B, W, L) = -1 [owise] .

*** gives the sub-bag of places whose labes have (match) a given suffix (NOTE a String is also a NeList{String})
 *** op subag : Pbag NeList{String} -> Pbag . 
 *** eq subag(B, NeWs) = $subag(B, NeWs, nilP) .  
 *** op $subag : Pbag NeList{String} Pbag -> Pbag . 
*** ceq $subag(K . P + B, NeWs, B') = $subag(B, NeWs, B' + K . P) if hasSuffix(P, NeWs) .
 *** eq $subag(B, NeWs, B') = B' [owise] .
 *** op subag : Pbag List{String} NeLab  -> Pbag . 
 *** eq subag(B, Ws, NeL) = $subag(B, Ws, NeL, nilP) .  
 *** op $subag : Pbag List{String} NeLab Pbag -> Pbag . 
*** ceq $subag(K . P + B, Ws, NeL, B') = $subag(B, Ws, NeL, B' + K . P) if hasSuffix(P, Ws, NeL) .
 *** eq $subag(B, Ws, NeL, B') = B' [owise] .
 *** might be defined in terms of a previous one
 op subag : Pbag  NeLab  -> Pbag . 
 eq subag(B, NeL) = $subag(B, NeL, nilP) .  
 op $subag : Pbag NeLab Pbag -> Pbag . 
ceq $subag(K . P + B, NeL, B') = $subag(B, NeL, B' + K . P) if hasSuffix(P, NeL) .
 eq $subag(B, NeL, B') = B' [owise] .

  *** gives the sub-bag of places whose labes match a given pref-suffix
 *** op match : Pbag List{String} NeLab  -> Pbag . 
 *** eq match(B, Ws, NeL) = $match(B, Ws, NeL, nilP) .  
 *** op $match : Pbag List{String} NeLab Pbag -> Pbag . 
*** ceq $match(K . P + B, Ws, NeL, B') = $match(B, Ws, NeL, B' + K . P) if match(P, Ws, NeL) .
 *** eq $match(B, Ws, NeL, B') = B' [owise] .
 *** match the prefix
 op match : Pbag NeList{String} -> Pbag . 
 eq match(B, NeWs) = $match(B, NeWs, nilP) .  
 op $match : Pbag List{String} Pbag -> Pbag . 
ceq $match(K . P + B, NeWs, B') = $match(B, NeWs, B' + K . P) if match(P, NeWs) .
 eq $match(B, NeWs, B') = B' [owise] .

endfm



*** strict TO view
view Pbag< from STRICT-TOTAL-ORDER to PBAG-MOD is 
  sort Elt to Pbag .
  op _<_ to le . 
endv