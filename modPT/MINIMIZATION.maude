*** this module defines the operators to bring a Net (System) to a minimal/canonical form
*** should be used in combination with NET-OP: i.e., assumes that models are built according
*** to the net-operators there dfined

fmod MINIMIZATION is
 pr PT-SYS .
 pr SET+{Nat} * (op emptyS to emptyNat) .
 vars P P' P'' : Place .
 vars T T' T'' : Tran .
 vars N N' : Net .
 vars B B' B'' B0 B1 B2 : Pbag .
 var Sys Sys' : System .
 var Ssys Ssys' : SimpleSys .
 vars Sn Sn' : Snet .
 vars I J : Nat .
 vars K K' : NzNat .
 vars W W' W'' W''' : String .
 vars L L' L'' : Lab .
 var NeL : NeLab .
 vars Ls Ls' : List{String} .
 *** minimization plus name abstraction
 op normalize : Pbag -> Pbag .
 eq normalize(B) = abstract(minimize(B)) .
 *** simple extension to systems
 op normalize : System -> System .
 eq normalize(N B) = N normalize(B) .
 *** brings a marking (of a symmetric net) to a minimal form
 op minimize : Pbag -> Pbag .
 *** simple version
 *** ceq minimize(B) = minimize(B'') if K . p(L' < W ; I > L) + K' . p(L'' < W ; J > L) + B' := B /\ J =/= I
 ***                        /\ (K =/= K' or-else L' =/= L'') /\ B'' := swapLab(B, W, L, I, J) /\ B'' < B .              
 ceq minimize(B) = minimize(B'' + (B' - B2 )) if K . p(L' < W ; I > L) + K' . p(L'' < W ; J > L)  + B' := B  /\ J =/= I /\ 
                        (K =/= K' or-else L' =/= L'') /\  B0 := K . p(L' < W ; I > L) + K' . p(L'' < W ; J > L) /\ 
                        B1 := extract(B', W, I U J, L)  /\ B2 := B1 + B0 /\ B'' := swapLab(B2, W, L, I, J) /\ B'' < B2 .            
 
 eq minimize(B) = B [owise] .
 op minimize : System -> System .
 eq minimize(N B) = N minimize(B) .
 *** given a marking, a label suffix with an header element and two indices, rewrites the marking by swapping the suffix's header indices
 op swapLab : Pbag String Lab Nat Nat -> Pbag .
 eq swapLab(B, W, L, I, I) = B .
ceq swapLab(B, W, L, I, J) = $swapLab(B, nilP, W, L, I, J) if I =/= J . 
 op $swapLab : Pbag Pbag String Lab Nat Nat -> Pbag .
 eq $swapLab(nilP, B, W, L, I, J) = B .
 eq $swapLab(K . p(L' < W ; I > L) + B, B', W, L, I, J) = $swapLab(B, K . p(L' < W ; J > L) + B', W, L, I, J) .
 eq $swapLab(K . p(L' < W ; J > L) + B, B', W, L, I, J) = $swapLab(B, K . p(L' < W ; I > L) + B', W, L, I, J) .
 eq $swapLab(K . P + B, B', W, L, I, J) = $swapLab(B, K . P + B', W, L, I, J) [owise] .
*** makes the name (index) abstraction in a marking
 op abstract : Pbag -> Pbag .
 *** this version consider the suffix exactly as it is 
ceq abstract(B) = abstract(replaceWithPrec(B, < W ; K' > L)) if K . p(L' < W ; K' > L) + B' := B /\ exists(B', < W ; K' - 1 > L) == false .
 eq abstract(B) = B [owise] .
 
 *** replaces in a bag all the occurrences of places whose label matches the given prefix (whose last element's index K' is given) and suffix using K' - 1 in place of K' 
 op replaceWithPrec : Pbag NeLab -> Pbag . 
 eq replaceWithPrec(B, NeL) = $replaceWithPrec(B, nilP, NeL) .
 op $replaceWithPrec : Pbag Pbag NeLab -> Pbag .
ceq $replaceWithPrec(K . p(L' NeL) + B, B', NeL) = $replaceWithPrec(B, K . p(L' < W ; K' - 1 > L) + B', NeL) if < W ; K' > L := NeL .
 eq $replaceWithPrec(nilP, B, NeL) = B .
 eq $replaceWithPrec(K . P + B', B, NeL) = $replaceWithPrec(B', K . P + B, NeL) [owise] .
 
 *** checks for the existence in bag of a place whose label matches the given suffix (whose last element's index is given)
 op exists : Pbag NeLab -> Bool .
 eq exists(K . p(L' NeL) + B, NeL) = true  .
 eq exists(B, NeL) = false [owise] .
 *** slightly different version checking for a suffix with a given header label
 *** op exists : Pbag String Lab -> Bool .
 *** eq exists(K . p(L' < W ; I > L) + B, W, L) = true .
 *** eq exists(B, W, L) = false [owise] .
 *** extracts the elements with a given suffix
 op extract : Pbag String Lab ->  Pbag .
 eq extract(B, W, L) = $extract(B, nilP, W, L) .
 op $extract : Pbag Pbag String Lab ->  Pbag .
 eq $extract(nilP, B, W, L) = B .
 eq $extract(K . p(L' < W ; I > L) + B, B', W, L) = $extract(B, B' + K . p(L' < W ; I > L) , W, L) . 
 eq $extract(K . P + B, B', W, L) = $extract(B, B' , W, L) [owise] . 
 *** extracts the elements with a given suffix and the suffix header's index in a set
 var A : Set{Nat} .
 op extract : Pbag String Set{Nat} Lab ->  Pbag .
 eq extract(B, W, A, L) = $extract(B, nilP, W, A, L) .
 op $extract : Pbag Pbag String Set{Nat} Lab ->  Pbag .
 eq $extract(nilP, B, W, A, L) = B .
ceq $extract(K . p(L' < W ; I > L) + B, B', W, A, L) = $extract(B, B' + K . p(L' < W ; I > L) , W, A, L) if I in A . 
 eq $extract(K . P + B, B', W, A, L) = $extract(B, B' , W, A, L) [owise] . 
endfm 