*** theories and modules helpful to implement symmetric algebraic operators for monoid structures
*** (originally defined for modular PT nets and SPN)
in ../../lambda/MONOID
in PSET-MOD

*** a network (of nodes) seen as monoid
fth MO-NET is
  including MONOID+ .
  including PSET-MOD .
  op replaceWithEl : El NeLab Nat -> El . *** defined for a single element of a network
  op addLabEl : El Lab Pset -> El . 
  op placesEl : El -> Pset .
  op placesEl : El NeList{String} -> Pset .
  op inEl : El Place -> Bool .
endfth

*** defines some general operators necessary for manipulation and normalization of a network seen as a monoid, based on structured node labels
fmod MO-NET-OP{N :: MO-NET} is
  var J   : Nat .  var K : NzNat . vars N N' : N$Elt . var E : N$El .
  vars L L' : Lab . var NeL : NeLab .
  vars W W' : String . var P : Place .
  vars S S' : Pset . var WL : List{String} .  var NeWL : NeList{String} .
  *** replace the index of the header of a structured lab
  op replaceWith : N$Elt NeLab Nat -> N$Elt .
  eq replaceWith(N, NeL, J) = $replaceWith(N, NeL, J, nil) .  
  op $replaceWith : N$Elt NeLab Nat N$Elt -> N$El . 
  eq $replaceWith(nil, NeL, J, N) = N . 
  eq $replaceWith(E ; N, NeL, J, N') = $replaceWith(N, NeL, J, N' ; replaceWithEl(E, NeL, J)) . 
  *** append a new tag to the net's places, but those to share (i.e., to which not to add the tag)
  op addLab : N$Elt Lab Pset -> N$Elt . 
  eq addLab(N, L, S) = $addLab(N, nil, L, S) .
  op $addLab : N$Elt N$Elt Lab Pset -> N$Elt .
  eq $addLab(nil, N, L, S) = N .
  eq $addLab(E ; N', N, L, S) = $addLab(N', addLabEl(E, L, S) ; N, L, S) .
  *** simple (default) version
  op addLab : N$Elt Lab -> N$Elt . 
  eq addLab(N, L) = addLab(N, L, emptyPset) .
  *** defined for convenience (maps to the previous version)
  op addLab : N$Elt Lab List{String} -> N$Elt .
  eq addLab(N, L, WL) = addLab(N, L, places(N, WL)) . 
  *** set of places
  op places : N$Elt -> Pset [memo] .
  eq places(N) = $places (N, emptyPset) .
  op $places : N$Elt Pset -> Pset .
  eq $places(nil, S) = S .
  eq $places(E ; N, S) = $places (N, S U placesEl(E)) .
  *** places matching a suffix (derived definitions) 
  op places : N$Elt List{String} -> Pset .
  eq places(N, emptyLs) = places(N) .
  eq places(N, NeWL) = $places(N, NeWL, emptyPset) .
  op $places : N$Elt NeList{String} Pset -> Pset .
  eq $places(nil, NeWL, S) = S .
  eq $places(E ; N, NeWL, S) = $places (N, NeWL, S U placesEl(E, NeWL)) .
  *** efficient implementation
  op in : N$Elt Place -> Bool . 
ceq in(E ; N, P) = true if inEl(E, P) .
  eq in(N, P) = false [owise] .
 
  *** extend the versions defined on Pbag: efficient if places is set as [memo] -- otherwise better to define from scratch
  op exists : N$Elt NeLab  -> Bool .
  eq exists(N, NeL) = existS(places(N), NeL) .
  **** normalization (name abstraction)
  op abstract : N$Elt -> N$Elt .
 ceq abstract(N) = abstract(replaceWith(N, < W ; K > L, K - 1)) if p(L' < W ; K > L) U S := places(N) /\ existS(S, < W ; K - 1 > L) == false .
  eq abstract(N) = N [owise] .
 *** excludes from index abstraction those places (components) matching a given suffix
  op abstractBut : N$Elt String -> N$Elt .
 ceq abstractBut(N, W') = abstractBut(replaceWith(N, < W ; K > L, K - 1), W') if p(L' < W ; K > L) U S := places(N) /\ 1st(last(L' < W ; K > L)) =/= W' /\ existS(S, < W ; K - 1 > L) == false .
  eq abstractBut(N, W) = N [owise] .

  *** "symmetric" juxtaposition: creates K (disjoint) replica of a node's structure each one with a suitably added label suffix (index 0..K-1) denoting the "nesting" level
  op repl&share : N$Elt NzNat String Pset -> N$Elt .
 eq repl&share(N, K, W, S) = $repl&share(N, K, W, nil, S) .
 op $repl&share : N$Elt Nat String N$Elt Pset -> N$Elt .
 eq $repl&share(N, 0, W, N', S) = N' .
 eq $repl&share(N, K, W, N', S) = $repl&share(N, K - 1, W, (N' ; addLab(N, < W ; K - 1 >, S)), S) .
  *** derived  versionss
 op replica : N$Elt NzNat String -> N$Elt . *** default
 eq replica(N, K, W) = repl&share(N, K, W, emptyPset) .
endfm 

in PBAG-MOD
*** a node (seen as monoid) with associated distributed shared state
fth MO-NET-SYS is
  including MO-NET .
  including PBAG-MOD .
  sort SysNode . *** network structure plus shared state
  op _:_ : Elt Pbag -> SysNode .
endfth

*** necessary to import MO-NET-OP from inside MO-NET-SYS-OP
view MO-NET-SYS from MO-NET to MO-NET-SYS is
endv

*** defines some general operators necessary for manipulation and normalization of a network seen as a monoid, with an associated state, based on structured node labels
fmod MO-NET-SYS-OP{N :: MO-NET-SYS} is
  pr MO-NET-OP{MO-NET-SYS}{N} .
  vars J I X  : Nat .  vars K K' : NzNat .
  vars Sys Sys' : N$SysNode . vars N N' : N$Elt . vars M M' M'' : Pbag . vars P P' : Place . 
  vars W W' : String . var WL : List{String} . var NeWL : NeList{String} . 
  vars L L' L'' : Lab . var NeL : NeLab . vars S S' : Pset .
  *** getters
  op nd : N$SysNode -> N$Elt . *** inner structure of the node
  op st : N$SysNode -> Pbag .  *** shared state of the node
  eq nd(N : M) = N .
  eq st(N : M) = M .
  
 *** clears the system's marking by removing non encoded places
 op clearupM : N$SysNode -> N$SysNode .
ceq clearupM(N : K . P + M) = clearupM(N : M) if in(N, P) == false .
 eq clearupM(Sys) = Sys [owise] .

  *** derived version 
 op replaceWith : N$SysNode NeLab Nat -> N$SysNode .
 eq replaceWith(N : M, NeL, J) = replaceWith(N, NeL, J) : replaceWithB(M, NeL, J) .

*** removes isolated places
*** ceq N K . P + M = N : M if in(N, P) = false . *** removes isolated places from the marking
 
 *** normalization (name abstraction) 
 op abstract : N$SysNode -> N$SysNode .
ceq abstract(Sys) = abstract(replaceWith(Sys, < W ; K > L, K - 1)) if p(L' < W ; K > L) U S := places(nd(Sys)) /\ existS(S, < W ; K - 1 > L) == false .
 eq abstract(Sys) = Sys [owise] .
 *** excludes from index abstraction those places (components) matching a given suffix
 op abstractBut : N$SysNode String -> N$SysNode .
ceq abstractBut(Sys, W') = abstractBut(replaceWith(Sys, < W ; K > L, K - 1), W') if p(L' < W ; K > L) U S := places(nd(Sys)) /\ 1st(last(L' < W ; K > L)) =/= W' /\ existS(S, < W ; K - 1 > L) == false .
 eq abstractBut(Sys, W) = Sys [owise] .
 *** normalize a system assuming that its labelling is well-defined: for the "net", only index abstraction applies 
 op normalize : N$SysNode -> N$SysNode .
ceq normalize(Sys) = nd(Sys') : minimize(st(Sys')) if Sys' := abstract(Sys) .  
*** excludes from index abstraction those places (components) matching a given suffix
 op normalize : N$SysNode String -> N$SysNode .
ceq normalize(Sys, W) = nd(Sys') : normalizeB(st(Sys')) if Sys' := abstractBut(Sys, W) .  

 *** set a marking for net places with label with a given suffix
 op setMark : N$Elt NeList{String} Nat -> N$SysNode .
 eq setMark(N, NeWL, 0) = N : nilP . 
 eq setMark(N, NeWL, K) = setMark(N : nilP, NeWL, K) . 
 op setMark : N$SysNode NeList{String} Nat -> N$SysNode .
 eq setMark(N : M, NeWL, J) = N : set(M, places(N, NeWL), J) . 
 
 *** join two systems by summing their markings (identical places are implicitly merged)
 op join : N$SysNode N$SysNode -> N$SysNode [assoc comm] .
 eq join(N : M, N' : M') = (N ; N') : M + M' .
 
 

endfm 


