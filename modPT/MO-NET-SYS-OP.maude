in MO-NET-OP
in PBAG-MOD

*** a node (seen as monoid) with associated distributed shared state
fth MO-NET-SYS is
  including MO-NET .
  including PBAG-MOD .
  sort SysNode . *** network structure plus shared state
  op _:_ : Elt Pbag -> SysNode .
endfth

*** necessary to import MO-NET-OP from inside MO-NET-SYS-OP
view MO-NET-SYS from MO-NET to MO-NET-SYS is
endv

*** defines some general operators necessary for manipulation and normalization of a network seen as a monoid, with an associated state, based on structured node labels
fmod MO-NET-SYS-OP{N :: MO-NET-SYS} is
  pr MO-NET-OP{MO-NET-SYS}{N} .
  vars J I X  : Nat .  vars K K' : NzNat .
  vars Sys Sys' : N$SysNode . vars N N' : N$Elt . vars M M' M'' : Pbag . vars P P' : Place . 
  vars W W' : String . var WL : List{String} . var NeWL : NeList{String} . 
  vars L L' L'' : Lab . var NeL : NeLab . vars S S' : Pset .
  *** getters
  op nd : N$SysNode -> N$Elt . *** inner structure of the node
  op st : N$SysNode -> Pbag .  *** shared state of the node
  eq nd(N : M) = N .
  eq st(N : M) = M .
  
 *** clears the system's marking by removing non encoded places
 op clearUp : N$SysNode -> N$SysNode .
ceq clearUp(N : K . P + M) = clearUp(N : M) if in(N, P) == false .
 eq clearUp(Sys) = Sys [owise] .

  *** derived version 
 op replaceWith : N$SysNode NeLab Nat -> N$SysNode .
 eq replaceWith(N : M, NeL, J) = replaceWith(N, NeL, J) : replaceWith(M, NeL, J) .
 op places : N$SysNode List{String} -> Pset .
 eq places(N : M, WL) = places(N, WL) . 
 op places : N$SysNode -> Pset  .
 eq places(N : M) = places(N) . 

 *** normalization (name abstraction) 
 op abstract : N$SysNode -> N$SysNode .
ceq abstract(Sys) = abstract(replaceWith(Sys, < W ; K > L, J)) if p(L' < W ; K > L) U S := places(Sys) /\ J := sd(K,1) /\ exists(S, < W ; J > L) == false .
 eq abstract(Sys) = Sys [owise] .
 *** excludes from index abstraction those places (components) matching a given suffix
 op abstractBut : N$SysNode String -> N$SysNode .
ceq abstractBut(Sys, W') = abstractBut(replaceWith(Sys, < W ; K > L, J), W') if p(L' < W ; K > L) U S := places(Sys)  /\ 1st(last(L' < W ; K > L)) =/= W' /\ J := sd(K,1) /\ exists(S, < W ; J > L) == false .
 eq abstractBut(Sys, W) = Sys [owise] .
 *** normalize a system assuming that its labelling is well-defined: for the "net", only index abstraction applies 
 op normalize : N$SysNode -> N$SysNode .
ceq normalize(Sys) = nd(Sys') : minimize(st(Sys')) if Sys' := abstract(Sys) .  

*** excludes from index abstraction those places (components) matching a given suffix
 op normalize : N$SysNode String -> N$SysNode .
ceq normalize(Sys, W) = nd(Sys') : minimize(st(Sys')) if Sys' := abstractBut(Sys, W) .  

 *** set a marking for net places with label with a given suffix
 op setMark : N$Elt NeList{String} Nat -> N$SysNode .
 eq setMark(N, NeWL, 0) = N : nilP . 
 eq setMark(N, NeWL, K) = setMark(N : nilP, NeWL, K) . 
 op setMark : N$SysNode NeList{String} Nat -> N$SysNode .
 eq setMark(N : M, NeWL, J) = N : set(M, places(N, NeWL), J) . 
 
 *** join two systems by summing their markings (identical places are implicitly merged)
 op join : N$SysNode N$SysNode -> N$SysNode [assoc comm] .
 eq join(N : M, N' : M') = (N ; N') : M + M' .
 
endfm 


