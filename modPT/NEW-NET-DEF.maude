*** a new, more effective net representation
in IMATRIX
*** in ../shared/MAP+
in ../shared/MAP-SET

*** signature of a PT net : a PT net is a map Imatrix -> String
fmod PT-NET is
 pr MAP-SET{Imatrix,String} * (sort Map{Imatrix,String} to Net, sort Entry{Imatrix,String} to Tmatrix, op emptyM to emptyN,
                              sort Set{Imatrix} to Iset, sort NeSet{Imatrix} to NeIset, op emptyS to emptyTset) .
 pr SORTABLE-LIST{Place<} * (sort List{Place<} to Plist, sort NeList{Place<} to NePlist, op nil to emptyPlist ) .
 pr SET+{String} * (op emptyS to emptyStr) .

 vars N N'  : Net .
 vars T T' : Tmatrix .
 vars P P' P'' : Place .
 vars Y J  : Nat .
 vars K K' : NzNat .
 vars I O H B : Pbag .
 vars Q Q' : Imatrix . 
 vars S S' PS : Pset .
 vars L L1 : Plist .
 var W :  String .
 var WL : List{String} .
 var Z  : Set{String} .  
 var Lab : Lab .

 op lab : Tmatrix -> String .
 eq lab(Q |-> W) = W .

 *** dead transition
 op dead : Tmatrix -> Bool .   
 eq dead(Q |-> W) = dead(Q) .
 
 *** test the existence of a place
 op in :  Net Place -> Bool . 
ceq in(Q |-> W ; N, P) = true if in (Q, P) .
 eq in(N, P) = false [owise] .

 *** test the existence of a transition
 op in :  Net Imatrix -> Bool . 
 eq in(N, Q) = $hasMapping(N, Q) .

 *** gets out the places of the net
 op places : Net -> Pset .
 eq places(N) = $places(N, emptyPset) .  
 op $places : Net Pset -> Pset . 
 eq $places(emptyN, S) = S . 
 eq $places(Q |-> W ; N, S) = $places(N, S U places(Q)) .
 
 op places : Net List{String} -> Pset .
 eq places(N, WL) = $places(N, WL, emptyPset) .  
 op $places : Net List{String} Pset -> Pset . 
 eq $places(emptyN, WL, S) = S . 
 eq $places(Q |-> W ; N, WL, S) = $places(N, WL, S U places(WL, Q)) . *** places in Imatrix has the args in reverse order to avoid looping
 
*** set of places whose label's suffix matches the given one --- the suffix header is specified exactly
 op places : Net Elab List{String} -> Pset .
 *** set of places whose label's suffix matches the given one --- the suffix header is specified exactly
 var E : Elab .
 eq places(N, E, WL) = $places(N, E, WL, emptyPset) .  
 op $places : Net Elab List{String} Pset -> Pset . 
 eq $places(emptyN, E, WL, S) = S . 
 eq $places(Q |-> W ; N, E, WL, S) = $places(N, E, WL, S U places(WL, Q)) .
 
 *** returns the sorted list of places of a netop placeList : Net -> Plist .
 op placeList : Net -> Plist . 
 eq placeList(N) = $makePlist(places(N), emptyPlist) .
 op $makePlist : Pset Plist -> Plist . 
 eq $makePlist(emptyPset, L) = sort(L) . 
 eq $makePlist(P U S, L) = $makePlist(S, P L) . 

 *** remove places
 op remove :  Net Pset -> Net .
 eq remove(N, emptyPset) = N .
 eq remove(N, S) = $remove(N, emptyN, S) .
 op $remove : Net Net NePset -> Net .
 eq $remove(emptyN, N, S) = N .
 eq $remove(Q |-> W ; N', N, S) = $remove(N', remove(Q, S)  |-> W ; N, S).

 *** remove transitions with given labels
 op remove :  Net Set{String} -> Net .
 eq remove(N, emptyStr) = N .
 eq remove(N, Z) = $remove(N, emptyN, Z) .
 op $remove : Net Net NeSet{String} -> Net .
 eq $remove(emptyN, N, Z) = N .
ceq $remove(Q |-> W ; N', N, Z) = $remove(N', N, Z) if W in Z .
 eq $remove(Q |-> W ; N', N, Z) = $remove(N', Q |-> W ; N, Z) [owise] .

 *** add a new tag to the net's places, but those to share (i.e., to which not to add the tag)
 op addLab : Net Lab Pset -> Net . 
 eq addLab(N, Lab, S) = $addLab(N, emptyN, Lab, S) .
 op $addLab : Net Net Lab Pset -> Net .
 eq $addLab(emptyN, N, Lab, S) = N .
 eq $addLab(Q |-> W ; N', N, Lab, S) = $addLab(N', addLab(Q, Lab, S) |-> W ; N, Lab, S) .
 *** simple (default) version
 op addLab : Net Lab -> Net . 
 eq addLab(N, Lab) = addLab(N, Lab, emptyPset) .
 
endfm

*** trivial view to a PT-NET
view PTnet from TRIV to PT-NET is 
 sort Elt to Net .
endv

*** PT system's signature (including a simple(r) one with an implicit representation of transition)
fmod PT-SYS is
 pr PT-NET .
 sorts ElSys System ElSimpSys SimpleSys .
 subsorts ElSys < System . *** PT system built of one transition 
 op __ : Net Pbag  -> System      [ctor] .
 op __ : Tmatrix Pbag  -> ElSys    [ctor] .
 
 op emptySys  : -> System . *** alias
 eq emptySys = emptyN nilP .
 
 vars N N' : Net .
 vars T T' : Tmatrix .
 vars P P' P'' : Place .
 vars I O H S S' : Pbag .
 vars Q Q' : Imatrix .
 vars K K' : NzNat .
 var W :  String .
 var Y : List{String} .
 var Z : Set{String} .
 *** all the ops are duplicated to consider simple nets
 op net : System -> Net . 
 op marking : System -> Pbag .
 eq net(N S) = N .
 eq marking(N S) = S .
 
 *** net transition enabling (partial operation: defined if the transition belongs to the net)
 op enabled : Tmatrix System -> [Bool] .
 eq enabled(Q |-> W, (Q |-> W ; N) S) = enabled(Q, S) .
 
 *** checks for a deadlock
 op dead : System -> Bool . 
ceq dead((T ; N) S) = false if enabled(T, (T ; N) S) .
 eq dead(N S) = true [owise] .
 
 *** tests the existence of a place
 op in :  System Place -> Bool . 
 eq in(N S, P) =  S[P] =/= 0 or-else in(N, P).
 *** system's places
 op places : System -> Pset .
 eq places(N S) = places(N) U support(S) .
 *** gets out the places whose labels match the given prefix 
 op places : System List{String} -> Pset .
 eq places(N S, Y) = places(N, Y) U support(S, Y) .
 *** system's oredered list of places
 op placeList : System -> Plist .
 eq placeList(N S) = $makePlist(places(N S), emptyPlist) .
*** add a new label to a system's places (not to transitions)
 var Lab : Lab .
 op addLab : System Lab -> System .
 eq addLab(N S, Lab) = addLab(N, Lab) addLab(S, Lab) .
 *** version specifying shared elements (helpful!)
 op addLab : System Lab Pset -> System .
 var PS : Pset .
 eq addLab(N S, Lab, PS) = addLab(N, Lab, PS) addLab(S, Lab, PS) .
 *** remove some places
 op remove :  System Pset -> System .
 eq remove(N S, PS) = remove(N, PS) remove(S, PS) .
endfm

*** trivial view to a PT-SYS
view System from TRIV to PT-SYS is 
 sort Elt to System .
endv

fmod NET-OP is
 pr PT-SYS .  
 vars P P' P'' : Place .
 vars T T' T'' : Tmatrix .
 vars N N' : Net .
 vars B B' B'' : Pbag .
 var Sys Sys' : System .
 vars I J : Nat .
 vars K K' : NzNat .
 vars W W' W'' W''' : String .
 vars Lw Lw' : List{String} .
 var Z : Set{String} .
 vars Q Q' : Imatrix .
 var S : Pset .
 
 *** "merges" identically labelled net transitions whose labels belong to the given set
 op merge : Net Set{String} -> Net .
ceq merge(N ; Q |-> W ; Q' |-> W, Z) = Q + Q' |->  W ; merge(N, Z) if W in Z .
 eq merge(N, Z) = N [owise] . 
 *** "forced" merge of identically labelled net transitions
 op merge! : Net  -> Net .
 eq merge!(N ; Q |-> W ; Q' |-> W) = Q + Q' |->  W ; merge!(N) .
 eq merge!(N) = N [owise] .
 *** join two systems by summing their markings (identical places are implicitly merged)
 op join : System System -> System [assoc comm] .
 eq join(N B, N' B') = (N ; N') B + B' .
 *** join two systems and then merge transitions identically labelled whose labels belong to the given set
 op join : System System Set{String} -> System .
 eq join(N B, N' B', Z) = merge(N ; N', Z) B + B' . 
 *** forced join (builds on transitions'  merge!)
 op join! : System System  -> System .
 eq join(N B, N' B') = merge!(N ; N') B + B' . 
 
 *** "symmetric" juxtaposition: creates K (disjoint) replica of a system each one with a suitably added label suffix (with index 0..K-1) denoting the "nesting" level
 ***  general version specifying elements to share among replicas
 op replica&share : System NzNat String Pset Set{String} -> System .
 eq replica&share(Sys, K, W, S, Z) = $replica&share(Sys, K, W, emptySys, S, Z)  .
 op $replica&share  : System Nat String System Pset Set{String} -> System .
 eq $replica&share(Sys, 0, W, Sys', S, Z) = Sys' .
 eq $replica&share(Sys, K, W, Sys', S, Z) = $replica&share(Sys, K - 1, W, join(Sys', addLab(Sys, < W ; K - 1 >, S), Z), S, Z) .
 *** overloaded version in which shared places are specified through a suffix in their labels
 op replica&share : System NzNat String List{String} Set{String} -> System .
 eq replica&share(Sys, K, W, Lw, Z) = replica&share(Sys, K, W, places(Sys, Lw), Z) .
 *** default version
 op replica  : System NzNat String -> System . 
 eq replica(Sys, K, W) =  replica&share(Sys, K, W, emptyPset, emptyStr) .
 *** net versions (build on system replica)
 op replica&share : Net NzNat String Pset Set{String} -> Net .
 eq replica&share(N, K, W, S, Z) = net(replica&share(N nilP, K, W, S, Z)) .
 op replica&share : Net NzNat String List{String} Set{String} -> Net .
 eq replica&share(N, K, W, Lw, Z) = net(replica&share(N nilP, K, W, Lw, Z)) .
 op replica : Net NzNat String -> Net .
 eq replica(N, K, W) = net(replica(N nilP, K, W)) .
 
 *** elementary operators/operators acting on elementary nets
 var TQ : Tmatrix .
 var A : Atype .
 var L : Elab .
 *** builds a "symmetric" transition's matrix with a pre/post/inhibitor set of K places of weight K' and with a given elementary label (indices 0..K-1)
 *** the transition's labe is the 1st arg
 op tnew : String String Atype NzNat NzNat  -> Tmatrix . 
 eq tnew(W', W, A, K, K') = $tnew( [nilP, nilP, nilP] |-> W', W, A, K, K') . 
 op $tnew : Tmatrix String Atype Nat NzNat  -> Tmatrix .
 eq $tnew(TQ, W, A, 0, K) = TQ .
 eq $tnew(Q |-> W', W, A, K', K) = $tnew(set(Q, A, p(< W ; K' - 1 >), K) |-> W', W, A, K' - 1, K) .
 
 *** set a marking for net places with label with a given suffix
 op setMark : Net List{String} NzNat -> System .
 eq setMark(N, Lw, K) = setMark(N nilP, Lw, K) . 
 op setMark : System List{String} NzNat -> System .
 eq setMark(N B, Lw, K) = N set(B, places(N B, Lw), K) . 
 
 *** connnect a new transition to net's places with a given label's suffix using the 2nd string as the fresh transition's lab
 *** op connect : Net String String Atype NzNat -> [Net] .
 *** eq connect(N, W, W', A, K) = connect(N, places(N, W), t(< W' ; 0 >), A, K) .
 *** overloaded op: connnect a system to a fresh transition
 *** op connect : System String String Atype NzNat -> [System] . 
 *** eq connect(N B, W, W', A, K) = connect(N, W, W', A, K) B .
 *** "synch" K replica of a system on a new fresh transition of given type 
 op synch  : System NzNat Atype String String String  -> System . 
*** ceq synch(Sys, K, A, W, W', W'') = connect(Sys', W, W', A, 1) if Sys' := replica(Sys, K, W'') .
 *** net version of synch
 op synch : Net NzNat Atype String String String  -> Net . 
 eq synch(N, K, A, W, W', W'') = net(synch(N nilP, K, A, W, W', W'')) .
 *** parallelize K replica of a system 
 op par  : System NzNat String String String String  -> System . 
 *** eq par(Sys, K, W, W', W'', W''') = connect(synch(Sys, K, o, W, W', "||"), W'',  W''', i, 1) . 
endfm

*** this module defines the operators to bring a Net (System) to a minimal/canonical form
*** should be used in combination with NET-OP: i.e., assumes that models are built according
*** to the net-operators there defined
*** praticamente lo stesso usato per la codifica originale: si può importare

fmod MINIMIZATION is
 pr PT-SYS .
 pr SET+{Nat} * (op emptyS to emptyNat) .
 vars P P' P'' : Place .
 vars N N' : Net .
 vars B B' B'' B0 B1 B2 : Pbag .
 var Sys Sys' : System .
 vars I J : Nat .
 vars K K' : NzNat .
 vars W W' W'' W''' : String .
 vars L L' L'' : Lab .
 var NeL : NeLab .
 vars Ls Ls' : List{String} .
 *** minimization plus name abstraction
 op normalize : Pbag -> Pbag .
 *** eq normalize(B) = abstract(minimize(B)) .
 eq normalize(B) = minimize(abstract(B)) . *** seems slightly better 
 *** extension to systems
 op normalize : System -> System .
 eq normalize(N B) = N normalize(B) .
 *** brings a marking (of a symmetric net) to a minimal form
 op minimize : Pbag -> Pbag [memo] .
 ceq minimize(B) = minimize(B'' + (B' - B2 )) if K . p(L' < W ; I > L) + K' . p(L'' < W ; J > L)  + B' := B  /\ J =/= I /\ 
                    (K =/= K' or-else L' =/= L'')  /\ B1 := extract(B', W, I U J, L)  /\ 
                    B2 := B1 + K . p(L' < W ; I > L) + K' . p(L'' < W ; J > L) /\ 
                    B'' := swapLab(B1, W, L, I, J) + K . p(L' < W ; J > L) + K' . p(L'' < W ; I > L) /\ B'' < B2 .            
 
 eq minimize(B) = B [owise] .
 
 *** given a marking, a label suffix with an header element and two indices, rewrites the marking by swapping the suffix's header indices
 op swapLab : Pbag String Lab Nat Nat -> Pbag .
 eq swapLab(B, W, L, I, I) = B .
ceq swapLab(B, W, L, I, J) = $swapLab(B, nilP, W, L, I, J) if I =/= J . 
 op $swapLab : Pbag Pbag String Lab Nat Nat -> Pbag .
 eq $swapLab(nilP, B, W, L, I, J) = B .
 eq $swapLab(K . p(L' < W ; I > L) + B, B', W, L, I, J) = $swapLab(B, K . p(L' < W ; J > L) + B', W, L, I, J) .
 eq $swapLab(K . p(L' < W ; J > L) + B, B', W, L, I, J) = $swapLab(B, K . p(L' < W ; I > L) + B', W, L, I, J) .
 eq $swapLab(K . P + B, B', W, L, I, J) = $swapLab(B, K . P + B', W, L, I, J) [owise] .
*** makes the name (index) abstraction in a marking
 op abstract : Pbag -> Pbag .
 *** this version consider the suffix exactly as it is 
ceq abstract(B) = abstract(replaceWithPrec(B, < W ; K' > L)) if K . p(L' < W ; K' > L) + B' := B /\ exists(B', < W ; K' - 1 > L) == false .
 eq abstract(B) = B [owise] .
 
 *** replaces in a bag all the occurrences of places whose label matches the given prefix (whose last element's index K' is given) and suffix using K' - 1 in place of K' 
 op replaceWithPrec : Pbag NeLab -> Pbag . 
 eq replaceWithPrec(B, NeL) = $replaceWithPrec(B, nilP, NeL) .
 op $replaceWithPrec : Pbag Pbag NeLab -> Pbag .
ceq $replaceWithPrec(K . p(L' NeL) + B, B', NeL) = $replaceWithPrec(B, K . p(L' < W ; K' - 1 > L) + B', NeL) if < W ; K' > L := NeL .
 eq $replaceWithPrec(nilP, B, NeL) = B .
 eq $replaceWithPrec(K . P + B', B, NeL) = $replaceWithPrec(B', K . P + B, NeL) [owise] .
 
 *** checks for the existence in bag of a place whose label matches the given suffix (whose last element's index is given)
 op exists : Pbag NeLab -> Bool .
 eq exists(K . p(L' NeL) + B, NeL) = true  .
 eq exists(B, NeL) = false [owise] .
 *** slightly different version checking for a suffix with a given header label
 *** op exists : Pbag String Lab -> Bool .
 *** eq exists(K . p(L' < W ; I > L) + B, W, L) = true .
 *** eq exists(B, W, L) = false [owise] .
 *** extracts the elements with a given suffix
 op extract : Pbag String Lab ->  Pbag .
 eq extract(B, W, L) = $extract(B, nilP, W, L) .
 op $extract : Pbag Pbag String Lab ->  Pbag .
 eq $extract(nilP, B, W, L) = B .
 eq $extract(K . p(L' < W ; I > L) + B, B', W, L) = $extract(B, B' + K . p(L' < W ; I > L) , W, L) . 
 eq $extract(K . P + B, B', W, L) = $extract(B, B' , W, L) [owise] . 
 *** extracts the elements with a given suffix and the suffix header's index in a set
 var A : Set{Nat} .
 op extract : Pbag String Set{Nat} Lab ->  Pbag .
 eq extract(B, W, A, L) = $extract(B, nilP, W, A, L) .
 op $extract : Pbag Pbag String Set{Nat} Lab ->  Pbag .
 eq $extract(nilP, B, W, A, L) = B .
ceq $extract(K . p(L' < W ; I > L) + B, B', W, A, L) = $extract(B, B' + K . p(L' < W ; I > L) , W, A, L) if I in A . 
 eq $extract(K . P + B, B', W, A, L) = $extract(B, B' , W, A, L) [owise] . 
endfm 

mod PT-EMU is
 pr MINIMIZATION .
 var  T : Tmatrix .
 vars I O H M : Pbag .
 vars N N' : Net .
 var W : String .
 *** ordinary firing rule
 crl [firing] : N M => N M + O - I if [I,O,H] |-> W ; N' := N /\ enabled([I,O,H], M) .
 *** including minimization
 *** crl [cfiring] : N M => N normalize(M + O - I) if [I,O,H] |-> W ; N' := N /\ enabled([I,O,H], M)  .
endm

fmod PT-FMS is
 protecting NET-OP .
 ops sline sload sass sfault faultysload faultysass :  Nat -> Imatrix .
 ops line load ass fault faultyload faultyass : Nat -> Tmatrix . 
 ops cycle PL faultycycle faultyPL : Nat -> Net .
 op NPL : NzNat -> Net . *** N prod lines
 op NPLsys : NzNat NzNat -> System . *** N prod lines with 2 * M tokens (raw pieces)
 
 var I : Nat . 
 vars N M : NzNat .
 eq sline(I) =  [1 . p(< "w" ; I >) , 1 . p(< "a" ; I >), 1 . p(< "f" ; I >) ] .
 eq line(I) = sline(I) |-> "l" .
 eq sfault(I) =  [1 . p(< "o" ; I >) , 1 . p(< "f" ; I >), nilP ] .
 eq fault(I) = sfault(I) |-> "f" .
 eq sload(I) = [1 . p(< "s" ; I >) , 1 . p(< "w" ; I >) , nilP ] .
 eq load(I) = sload(I) |-> "w" .
 eq sass(I) =  [1 . p(< "a" ; I >) , 1 . p(< "s" ; I >)  , nilP ] .
 eq ass(I)  = sass(I)  |-> "a" .
 eq cycle(I) = load(I) ; line(I) ; ass(I) ; fault(I) .
 eq PL(I) = replica&share(cycle(I), 2, "L", p (< "o" ; I >) U p(< "s" ; I >), "a" U "w") . *** a PL is built of two symmetric lines 
 eq NPL(N) = replica&share(PL(0), N, "PL", p(< "s" ; 0 >), emptyStr) .
 eq NPLsys(N, M) = setMark(setMark(NPL(N), "o" "PL", 1), "s", 2 * M) .
 
 *** faulty PL working with one line
 eq faultysload(I) =  [2 . p(< "s" ; I >) , 2 . p(< "w" ; I >) , nilP ] .
 eq faultysass(I)  =  [2 . p(< "a" ; I >) , 2 . p(< "s" ; I >)  , nilP ] .
 eq faultyload(I) = faultysload(I) |-> "l" . 
 eq faultyass(I)  = faultysass(I)  |-> "a" .
 eq faultycycle(I) = faultyload(I) ; line(I) ; faultyass(I) ; fault(I) .
 eq faultyPL(I) = replica&share(faultycycle(I), 1, "fPL", "s",  emptyStr) . *** a faulty PL is built of 1 line
endfm

mod RWPT-FMS is
 pr  PT-FMS .
 inc PT-EMU .
 vars N N' : Net .
 vars Tload Tfail Tfail1 Tfail2 Tass Tline Tline1 Tline2  : String .
 vars P0 P1 P2 P3 P4 P5 P6 P7 : Place .
 var S : Pbag .
 var K : NzNat .
 var I : Nat .
 var W : String .
 vars L L0 L1 L2 L3 L4 L5 L6 L7 : Lab .
 
crl [syr1] : N S + 1 . P7 => ( N' ; [2 . P1, 2 . P2, nilP] |-> Tload ;  [2 . P4, 2 . P1, nilP] |-> Tass  ) set(S, P3, 0) + S[P3] . P2 + 1 . P0 
        if (N' ; [2 . P1, 1 . P2 + 1 . P3, nilP ] |-> Tload  ; [1 . P3, 1 . P5, 1 . P7] |-> Tline2 ; [1 . P4 + 1 . P5, 2 . P1, nilP ] |-> Tass  ;[1 . P0, 1 . P7, nilP] |-> Tfail2 ) := N /\ dead(N S + 1 . P7)  .
*** crl [syr1new] : N S + 1 . p(L7 < "f" ; I >) => ( N' ; Tload |-> [2 . P1, 2 . P2, nilP] ;  Tass |-> [2 . P4, 2 . P1, nilP]) set(S, P3, 0) + S[P3] . P2 + 1 . P0 
***          if (N' ; NPL(1, I)) := N /\ dead(N S + 1 . P7)  .
crl [syr2] : N  S + 1 . P6  => N' (set(set(S, P1, S[P1] + S[P2] + S[P4]), P2, 0)) - 1 . P4 if (N' ; [1 . P0, 1 . P6, nilP] |-> Tfail1 ; [2 . P1, 2 . P2, nilP] |-> Tload  ; [1 . P2, 1 . P4, 1 . P6] |-> Tline1 ; [2 . P4, 2 . P1, nilP ] |-> Tass ) := N  /\ N' =/= emptyN /\
         dead(([2 . P1, 2 . P2, nilP] |-> Tload ; [2 . P4, 2 . P1, nilP ] |-> Tass) S) .
*** including minimization

endm