*** a new, more effective net representation
in IMATRIX
*** in ../shared/MAP+
in ../shared/MAP-SET

*** signature of a PT net : a PT net is a map Imatrix -> String (In general Imatrix -> Tag)
fmod PT-NET is
 pr MAP-SET{Imatrix,String} * (sort Map{Imatrix,String} to Net, sort Entry{Imatrix,String} to Tmatrix, op emptyM to emptyN,
                              sort Set{Imatrix} to Iset, sort NeSet{Imatrix} to NeIset, op emptyS to emptyIset) .
 pr SORTABLE-LIST{Place<} * (sort List{Place<} to Plist, sort NeList{Place<} to NePlist, op nil to emptyPlist ) .
 pr SET+{String} * (op emptyS to emptyStr) .

 vars N N'  : Net .
 vars T T' : Tmatrix .
 vars P P' P'' : Place .
 vars Y J  : Nat .
 vars K K' : NzNat .
 vars I O H B : Pbag .
 vars Q Q' : Imatrix . 
 vars S S' PS : Pset .
 vars L L1 : Plist .
 var W :  String .
 var WL : List{String} .
 var NWL : NeList{String} .
 var Z  : Set{String} .  
 var Lab : Lab .
 var NeL : NeLab .

 op lab : Tmatrix -> String .
 eq lab(Q |-> W) = W .

 *** dead transition
 op dead : Tmatrix -> Bool .   
 eq dead(Q |-> W) = dead(Q) .
 
 *** test the existence of a place
 op in :  Net Place -> Bool . 
ceq in(Q |-> W ; N, P) = true if in (Q, P) .
 eq in(N, P) = false [owise] .

 *** test the existence of a transition
 op in :  Net Imatrix -> Bool . 
 eq in(N, Q) = $hasMapping(N, Q) .

 *** gets out the places of the net
 op places : Net -> Pset [memo] .
 eq places(N) = $places(N, emptyPset) .  
 op $places : Net Pset -> Pset . 
 eq $places(emptyN, S) = S . 
 eq $places(Q |-> W ; N, S) = $places(N, S U places(Q)) .
 
 *** extract the subnet matching a given suffix ()
 op subnet : Net NeList{String} -> Net .
 eq subnet(N, NWL) = $subnet(N, NWL, emptyN) .  
 op $subnet : Net NeList{String} Net -> Net . 
 eq $subnet(emptyN, NWL, N) = clearup(N) . 
 eq $subnet(Q |-> W ; N, NWL, N') = $subnet(N, NWL, N' ; sumatrix(Q, NWL) |-> W) .
 ***
 op subnet : Net List{String} NeLab -> Net .
 eq subnet(N, WL, NeL) = $subnet(N, WL, NeL, emptyN) .  
 op $subnet : Net List{String} NeLab Net -> Net . 
 eq $subnet(emptyN, WL, NeL, N) = clearup(N) . 
 eq $subnet(Q |-> W ; N, WL, NeL, N') = $subnet(N, WL, NeL, N' ; sumatrix(Q, WL, NeL) |-> W) .
 ***
 op subnet : Net NeLab -> Net .
 eq subnet(N, NeL) = subnet(N, emptyLs, NeL) .
 *** extract the subnet matching a given pre-suffix
 op netmatch : Net List{String} NeLab -> Net .
 eq netmatch(N, WL, NeL) = $netmatch(N, WL, NeL, emptyN) .  
 op $netmatch : Net List{String} NeLab Net -> Net . 
 eq $netmatch(emptyN, WL, NeL, N) = clearup(N) . 
 eq $netmatch(Q |-> W ; N, WL, NeL, N') = $netmatch(N, WL, NeL, N' ; match(Q, WL, NeL) |-> W) .

 *** places matching a suffix (derived definitions) 
 op places : Net NeList{String} -> Pset .
 eq places(N, NWL) = places(subnet(N, NWL)) .
 op places : Net List{String} NeLab -> Pset .
 eq places(N, WL, NeL) = places(subnet(N, WL, NeL)) .
 op placematch : Net List{String} NeLab -> Pset .
 eq placematch(N, WL, NeL) = places(netmatch(N, WL, NeL)) .
 
 *** returns the sorted list of places of a netop placeList : Net -> Plist .
 op placeList : Net -> Plist . 
 eq placeList(N) = $makePlist(places(N), emptyPlist) .
 op $makePlist : Pset Plist -> Plist . 
 eq $makePlist(emptyPset, L) = sort(L) . 
 eq $makePlist(P U S, L) = $makePlist(S, P L) . 

 *** removes self-loops
 op clearup : Net -> Net .
 eq clearup([I, I, H] |-> W ; N) = clearup(N) .
 eq clearup(N) = N [owise] .

 *** removes the 2nd net from the first, if it is a subnet (does nothing otherwise)
 op detache : Net Net -> Net .
 eq detache(N ; N', N') = N .
 eq detache(N, N') = N [owise] .

 *** remove places
 op remove :  Net Pset -> Net .
 eq remove(N, emptyPset) = N .
 eq remove(N, S) = $remove(N, emptyN, S) .
 op $remove : Net Net NePset -> Net .
 eq $remove(emptyN, N, S) = N .
 eq $remove(Q |-> W ; N', N, S) = $remove(N', remove(Q, S)  |-> W ; N, S).

 *** remove transitions with given labels
 op remove :  Net Set{String} -> Net .
 eq remove(N, emptyStr) = N .
 eq remove(N, Z) = $remove(N, emptyN, Z) .
 op $remove : Net Net NeSet{String} -> Net .
 eq $remove(emptyN, N, Z) = N .
ceq $remove(Q |-> W ; N', N, Z) = $remove(N', N, Z) if W in Z .
 eq $remove(Q |-> W ; N', N, Z) = $remove(N', Q |-> W ; N, Z) [owise] .
 
 *** net algebra
 *** add a new tag to the net's places, but those to share (i.e., to which not to add the tag)
 op addLab : Net Lab Pset -> Net . 
 eq addLab(N, Lab, S) = $addLab(N, emptyN, Lab, S) .
 op $addLab : Net Net Lab Pset -> Net .
 eq $addLab(emptyN, N, Lab, S) = N .
 eq $addLab(Q |-> W ; N', N, Lab, S) = $addLab(N', addLab(Q, Lab, S) |-> W ; N, Lab, S) .
 *** simple (default) version
 op addLab : Net Lab -> Net . 
 eq addLab(N, Lab) = addLab(N, Lab, emptyPset) .
 *** defined for convenience (maps to the previous version)
 op addLab : Net Lab List{String} -> Net .
 eq addLab(N, Lab, WL) = addLab(N, Lab, places(N, WL)) . 
 
 *** replaces all the occurrences of places whose label matches the given suffix with a corresponding suffix having as header's index the specified value
 op replaceWith : Net NeLab Nat -> Net . 
 eq replaceWith(N, NeL, Y) = $replaceWith(N, NeL, Y, emptyN) .  
 op $replaceWith : Net NeLab Nat Net -> Net . 
 eq $replaceWith(emptyN, NeL, Y, N) = N . 
 eq $replaceWith(Q |-> W ; N, NeL, Y, N') = $replaceWith(N, NeL, Y, N' ; replaceWith(Q, NeL, Y) |-> W) .
 
endfm

*** trivial view to a PT-NET
view PTnet from TRIV to PT-NET is 
 sort Elt to Net .
endv

*** PT system's signature (including a simple(r) one with an implicit representation of transition)
fmod PT-SYS is
 pr PT-NET .
 sorts ElSys System ElSimpSys SimpleSys .
 subsorts ElSys < System . *** PT system built of one transition 
 op __ : Net Pbag  -> System      [ctor] .
 op __ : Tmatrix Pbag  -> ElSys    [ctor] .
 
 op emptySys  : -> System . *** alias
 eq emptySys = emptyN nilP .
 
 vars N N' : Net .
 vars T T' : Tmatrix .
 vars P P' P'' : Place .
 vars I O H S S' : Pbag .
 vars Q Q' : Imatrix .
 vars K K' : NzNat .
 var W :  String .
 var Y : List{String} .
 var Z : Set{String} .
 var Sys : System .

 op net : System -> Net . 
 op marking : System -> Pbag .
 eq net(N S) = N .
 eq marking(N S) = S .
 
 *** net transition enabling (partial operation: defined if the transition belongs to the net)
 op enabled : Tmatrix System -> [Bool] .
 eq enabled(Q |-> W, (Q |-> W ; N) S) = enabled(Q, S) .
 
 *** checks for a deadlock
 op dead : System -> Bool . 
ceq dead((T ; N) S) = false if enabled(T, (T ; N) S) .
 eq dead(N S) = true [owise] .
 
 *** tests the existence of a place
 op in :  System Place -> Bool . 
 eq in(N S, P) =  S[P] =/= 0 or-else in(N, P).
 *** system's places: assumes that it is the same as net's places
 op places : System -> Pset .
 eq places(N S) = places(N) .
 *** gets out the places whose labels match the given prefix 
 op places : System List{String} -> Pset .
 eq places(N S, Y) = places(N, Y) .
 *** system's oredered list of places
 op placeList : System -> Plist .
 eq placeList(Sys) = $makePlist(places(Sys), emptyPlist) .

*** add a new label to a system's places
 var Lab : Lab .
 op addLab : System Lab -> System .
 eq addLab(N S, Lab) = addLab(N, Lab) addLab(S, Lab) .
 *** version specifying shared elements (helpful!)
 op addLab : System Lab Pset -> System .
 var PS : Pset .
 eq addLab(N S, Lab, PS) = addLab(N, Lab, PS) addLab(S, Lab, PS) .
 *** defined for convenience
 op addLab : System Lab List{String} -> System .
 eq addLab(Sys, Lab, Y) = addLab(Sys, Lab, places(Sys, Y)) . 
 
 *** clears the system's marking by removing non encoded places
 op clearupM : System -> System .
ceq clearupM(N K . P + S) = clearupM(N S) if in(N, P) == false .
 eq clearupM(X:System) = X:System [owise] .

 *** remove some places
 op remove :  System Pset -> System .
 eq remove(N S, PS) = remove(N, PS) remove(S, PS) .

  *** derived version 
 var NeL : NeLab . 
 var J : Nat .
 op replaceWith : System NeLab Nat -> System .
 eq replaceWith(N S, NeL, J) = replaceWith(N, NeL, J) replaceWith(S, NeL, J) .

 *** 
 op subsys : System NeLab -> System .
 eq subsys(N S, NeL) = subnet(N, NeL) subag(S, NeL) .
 *** si dovrebbero definire anche le versioni overloaded di subsys a matchsys
 
endfm

*** trivial view to a PT-SYS
view System from TRIV to PT-SYS is 
 sort Elt to System .
endv

fmod NET-OP is
 pr PT-SYS .  
 vars P P' P'' : Place .
 vars T T' T'' : Tmatrix .
 vars N N' : Net .
 vars B B' B'' : Pbag .
 var Sys Sys' : System .
 vars I J : Nat .
 vars K K' : NzNat .
 vars W W' W'' W''' : String .
 vars Lw Lw' : List{String} .
 var Z : Set{String} .
 vars Q Q' : Imatrix .
 var S : Pset .
 
 *** "merges" identically labelled net transitions whose labels belong to the given set
 op merge : Net Set{String} -> Net .
ceq merge(N ; Q |-> W ; Q' |-> W, Z) = Q + Q' |->  W ; merge(N, Z) if W in Z .
 eq merge(N, Z) = N [owise] . 
 *** "forced" merge of identically labelled net transitions
 op merge! : Net  -> Net .
 eq merge!(N ; Q |-> W ; Q' |-> W) = Q + Q' |->  W ; merge!(N) .
 eq merge!(N) = N [owise] .
 *** join two systems by summing their markings (identical places are implicitly merged)
 op join : System System -> System [assoc comm] .
 eq join(N B, N' B') = (N ; N') B + B' .
 *** join two systems and then merge transitions identically labelled whose labels belong to the given set
 op join : System System Set{String} -> System .
 eq join(N B, N' B', Z) = merge(N ; N', Z) B + B' . 
 *** forced join (builds on transitions'  merge!)
 op join! : System System  -> System .
 eq join(N B, N' B') = merge!(N ; N') B + B' . 
 
 *** "symmetric" juxtaposition: creates K (disjoint) replica of a system each one with a suitably added label suffix (with index 0..K-1) denoting the "nesting" level
 ***  general version specifying elements to share among replicas
 op replica&share : System NzNat String Pset Set{String} -> System .
 eq replica&share(Sys, K, W, S, Z) = $replica&share(Sys, K, W, emptySys, S, Z)  .
 op $replica&share  : System Nat String System Pset Set{String} -> System .
 eq $replica&share(Sys, 0, W, Sys', S, Z) = Sys' .
 eq $replica&share(Sys, K, W, Sys', S, Z) = $replica&share(Sys, K - 1, W, join(Sys', addLab(Sys, < W ; K - 1 >, S), Z), S, Z) .
 *** overloaded version in which shared places are specified through a suffix in their labels
 op replica&share : System NzNat String List{String} Set{String} -> System .
 eq replica&share(Sys, K, W, Lw, Z) = replica&share(Sys, K, W, places(Sys, Lw), Z) .
 *** default version
 op replica  : System NzNat String -> System . 
 eq replica(Sys, K, W) =  replica&share(Sys, K, W, emptyPset, emptyStr) .
 *** net versions (build on system replica)
 op replica&share : Net NzNat String Pset Set{String} -> Net .
 eq replica&share(N, K, W, S, Z) = net(replica&share(N nilP, K, W, S, Z)) .
 op replica&share : Net NzNat String List{String} Set{String} -> Net .
 eq replica&share(N, K, W, Lw, Z) = net(replica&share(N nilP, K, W, Lw, Z)) .
 op replica : Net NzNat String -> Net .
 eq replica(N, K, W) = net(replica(N nilP, K, W)) .
 
 *** elementary operators/operators acting on elementary nets
 var TQ : Tmatrix .
 var A : Atype .
 var L : Elab .
 *** builds a "symmetric" transition's matrix with a pre/post/inhibitor set of K places of weight K' and with a given elementary label (indices 0..K-1)
 *** the transition's labe is the 1st arg
 op tnew : String String Atype NzNat NzNat  -> Tmatrix . 
 eq tnew(W', W, A, K, K') = $tnew( [nilP, nilP, nilP] |-> W', W, A, K, K') . 
 op $tnew : Tmatrix String Atype Nat NzNat  -> Tmatrix .
 eq $tnew(TQ, W, A, 0, K) = TQ .
 eq $tnew(Q |-> W', W, A, K', K) = $tnew(set(Q, A, p(< W ; K' - 1 >), K) |-> W', W, A, K' - 1, K) .
 
 *** set a marking for net places with label with a given suffix
 op setMark : Net List{String} Nat -> System .
 eq setMark(N, Lw, 0) = N nilP . 
 eq setMark(N, Lw, K) = setMark(N nilP, Lw, K) . 
 op setMark : System List{String} Nat -> System .
 eq setMark(N B, Lw, I) = N set(B, places(N B, Lw), I) . 
 
 *** connnect a new transition to net's places with a given label's suffix using the 2nd string as the fresh transition's lab
 *** op connect : Net String String Atype NzNat -> [Net] .
 *** eq connect(N, W, W', A, K) = connect(N, places(N, W), t(< W' ; 0 >), A, K) .
 *** overloaded op: connnect a system to a fresh transition
 *** op connect : System String String Atype NzNat -> [System] . 
 *** eq connect(N B, W, W', A, K) = connect(N, W, W', A, K) B .
 *** "synch" K replica of a system on a new fresh transition of given type 
 op synch  : System NzNat Atype String String String  -> System . 
*** ceq synch(Sys, K, A, W, W', W'') = connect(Sys', W, W', A, 1) if Sys' := replica(Sys, K, W'') .
 *** net version of synch
 op synch : Net NzNat Atype String String String  -> Net . 
 eq synch(N, K, A, W, W', W'') = net(synch(N nilP, K, A, W, W', W'')) .
 *** parallelize K replica of a system 
 op par  : System NzNat String String String String  -> System . 
 *** eq par(Sys, K, W, W', W'', W''') = connect(synch(Sys, K, o, W, W', "||"), W'',  W''', i, 1) . 
endfm

*** this module defines the operators to bring a Net (System) to a minimal/canonical form
*** should be used in combination with NET-OP: i.e., assumes that models are built according
*** to the net-operators there defined
*** praticamente lo stesso usato per la codifica originale: si può importare

fmod PT-NORM is
 pr PT-SYS .
 pr SET+{Nat} * (op emptyS to emptyNat) .
 vars P P' P'' : Place .
 vars S S' : Pset .
 vars N N' : Net .
 vars B B' B'' B0 B1 B2 : Pbag .
 var Sys Sys' : System .
 vars I J : Nat .
 vars K K' : NzNat .
 var Z : Int .
 vars W W' W'' : String .
 vars L L' L'' : Lab .
 var NeL : NeLab .
 vars Ls Ls' : List{String} .
 
 *** marking normalization plus name abstraction
 op normalize : Pbag -> Pbag .
 eq normalize(B) = minimize(abstract(B)) . *** seems slightly better than the alternative 
 *** eq normalize(B) = abstract(minimize(B)) . *** alternative
 *** version 2 (i.e., version using abstract2)
 op normalize2 : Pbag -> Pbag .
 eq normalize2(B) = minimize(abstract2(B)) . *** seems slightly better 
 
 *** optimized version
 op normalize : Pbag Bool -> Pbag .
 eq normalize(B, F:Bool) = if F:Bool then minimize(B) else normalize(B) fi .
 *** version 2 
 op normalize2 : Pbag Bool -> Pbag .
 eq normalize2(B, F:Bool) = if F:Bool then minimize(B) else normalize2(B) fi .
 
 *** brings a marking (of a symmetric net) to a minimal form
 op minimize : Pbag -> Pbag [memo] .
 op minimize2 : Pbag -> Pbag [memo] .
 
 eq minimize(B) = B [owise] .
 ceq minimize(K . P + K' . P' + B) = minimize(B' + (B - B'' )) if p(L' < W ; I > L) := P /\ p(L'' < W ; J > L) := P' /\
                      J > I /\ (K =/= K' or-else L' =/= L'')  /\ B'' := extract(B, W, I U J, L) /\
                      B' := swapLab(B'' + K . P + K' . P', W, L, I, J) /\ le(B', B'' + K . P + K' . P') . *** J > I prunes some matches (same as I > J) 

 *** using lex instead of le seems to be a bit less efficient
 *** given a marking, a label suffix with an header element and two indices, rewrites the marking by swapping the suffix's header indices
 op swapLab : Pbag String Lab Nat Nat -> Pbag .
 eq swapLab(B, W, L, I, I) = B .
ceq swapLab(B, W, L, I, J) = $swapLab(B, nilP, W, L, I, J) if I =/= J . 
 op $swapLab : Pbag Pbag String Lab Nat Nat -> Pbag .
 eq $swapLab(nilP, B, W, L, I, J) = B .
 eq $swapLab(K . p(L' < W ; I > L) + B, B', W, L, I, J) = $swapLab(B, K . p(L' < W ; J > L) + B', W, L, I, J) .
 eq $swapLab(K . p(L' < W ; J > L) + B, B', W, L, I, J) = $swapLab(B, K . p(L' < W ; I > L) + B', W, L, I, J) .
 eq $swapLab(K . P + B, B', W, L, I, J) = $swapLab(B, K . P + B', W, L, I, J) [owise] .

*** makes name (index) abstraction in a marking in a simple way: repeatedly searches (and in the event, replaces with) a suffix header's index with a missing prdecessor
 op abstract : Pbag -> Pbag .
ceq abstract(B) = abstract(K . p(L' < W ; K' - 1 > L) + replaceWith(B', < W ; K' > L, K' - 1)) if K . p(L' < W ; K' > L) + B' := B /\ exists(B', < W ; K' - 1 > L) == false .
 eq abstract(B) = B [owise] .
 *** version 2 : (repeatedly) finds the smallest missing suffix header's index and the greatest one (if any) and replaces the former with the latter
 *** negli esempi è un po' meno efficiente ma in generale (in casi meno semplici) può essere meglio
 op abstract2 : Pbag -> Pbag .
ceq abstract2(B) = abstract2(replaceWith(B, NeL, I)) if K' . p(L' NeL) + B' := B /\ < W ; K > L := NeL /\ I := minnotin(B', W, L) /\ I < K  /\ K := maxin(B, W, L) .
 eq abstract2(B) = B [owise] .

*** net/system versions
 **** op abstract : Net -> Net . *** needed?
 op abstract : System -> System .
ceq abstract(Sys) = abstract(replaceWith(Sys, < W ; K' > L, K' - 1)) if S := places(Sys) /\ p(L' < W ; K' > L) U S' := S /\ exists(S', < W ; K' - 1 > L) == false .
 eq abstract(Sys) = Sys [owise] .
*** version 2
 op abstract2 : System -> System .
ceq abstract2(Sys) = abstract2(replaceWith(Sys, NeL, I)) if S := places(Sys) /\ p(L' NeL) U S' := S /\ < W ; K > L := NeL /\ I := minnotin(S', W, L) /\ I < K  /\ K := maxin(S, W, L) .
 eq abstract2(Sys) = Sys [owise] .

****** NEW excludes from index abstraction those places (components) matching a given suffix
op abstractBut : System String -> System .
ceq abstractBut(Sys, W') = abstractBut(replaceWith(Sys, < W ; K' > L, K' - 1), W') if S := places(Sys) /\ p(L' < W ; K' > L) U S' := S /\ 1st(last(L' < W ; K' > L)) =/= W' /\ exists(S', < W ; K' - 1 > L) == false .
 eq abstractBut(Sys, W) = Sys [owise] .
******

*** normalize a system assuming that its labeleing is well-defined: for the net only index abstraction applies 
 op normalize : System -> System .
ceq normalize(Sys) = net(Sys') normalize(marking(Sys')) if Sys' := abstract(Sys) .  

****** NEW excludes from index abstraction those net places (components) matching a given suffix
op normalize : System String -> System .
ceq normalize(Sys, W) = net(Sys') normalize(marking(Sys')) if Sys' := abstractBut(Sys, W) .  
*****

*** version 2
 op normalize2 : System -> System .
 ceq normalize2(Sys) = net(Sys') normalize2(marking(Sys')) if Sys' := abstract2(Sys) . 
 
 *** checks for the existence in a set of a place whose label matches the given suffix 
 op exists : Pset NeLab  -> Bool .
 eq exists(p(L' NeL) U S, NeL) = true  .
 eq exists(S, NeL) = false [owise] .
 *** bag version 
 op exists : Pbag NeLab -> Bool .
 eq exists(K . p(L' NeL) + B, NeL) = true  .
 eq exists(B, NeL) = false [owise] .
 *** eq exists(B, NeL) = exists(support(B), NeL) . *** alternative
 *** net/system versions building on Net.places: efficient if places is set as [memo] -- otherwise better to define from scratch
 op exists : Net NeLab  -> Bool .
 eq exists(N, NeL) = exists(places(N), NeL) .
 *** op exists : System NeLab -> Bool . *** inutile, se assumiano che Marking \subseteq Net
 *** eq exists(N B, NeL) = exists(B, NeL) or-else exists(N, NeL) .
 *** new: checks the existence of a place in a set with a suffix header's index greater than the specified one
 op existsgr : Pset NeLab  -> Bool .
ceq existsgr(p(L' < W ; J > L) U S, < W ; I > L) = true  if J > I .
 eq existsgr(S, NeL) = false [owise] .
 *** bag version
op existsgr : Pbag NeLab  -> Bool .
ceq existsgr(K . p(L' < W ; J > L) + B, < W ; I > L) = true  if J > I .
 eq existsgr(B, NeL) = false [owise] .
*** returns the biggest suffix header's index in the specified set of places (-1 if no place with a matching suffix does exist)
 op maxin : Pset String Lab -> Int .
ceq maxin(p(L' NeL) U S, W, L) = J if < W ; J > L := NeL /\ existsgr(S, NeL) == false .  
 eq maxin(S, W, L) = -1 [owise] .
 *** bag version
 op maxin : Pbag String Lab -> Int .
ceq maxin(K . p(L' NeL) + B, W, L) = J if < W ; J > L := NeL /\ existsgr(B, NeL) == false .  
 eq maxin(B, W, L) = -1 [owise] .
 
 *** find the min suffix header's index non present in the set of places
 op minnotin : Pset String Lab -> Nat .
 eq minnotin(S, W, L) = $minnotin(S, W, L, 0) .
 op $minnotin : Pset String Lab Nat -> Nat . 
 eq $minnotin(S, W, L, I) = if exists(S, < W ; I > L) then $minnotin(S, W, L, I + 1) else I fi .  
*** ceq $minnotin(S, W, L, I) = $minnotin(S, W, L, I + 1) if exists(S, < W ; I > L) . *** alternative
 *** eq $minnotin(S, W, L, I) = I [owise] .
 *** net version (defined for convenience)
 op minnotin : Net String Lab -> Nat .
 eq minnotin(N, W, L) = minnotin(places(N), W, L) .
 
 *** bag version (defined for efficiency)
 op minnotin : Pbag String Lab -> Nat .
 eq minnotin(B, W, L) = $minnotin(B, W, L, 0) .
 op $minnotin : Pbag String Lab Nat -> Nat . 
 eq $minnotin(B, W, L, I) = if exists(B, < W ; I > L) then $minnotin(B, W, L, I + 1) else I fi .  
 
 *** default versions (with a null suffix last part)
 op minnotin : Net String -> Nat .
 eq minnotin(N, W) = minnotin(N, W, emptyLab) .
 op minnotin : Pbag String -> Nat .
 eq minnotin(B, W) = minnotin(B, W, emptyLab) .

 var A : Set{Nat} .
 *** extracts the elements with a given suffix and the suffix header's index in a set
 op extract : Pbag String Set{Nat} Lab ->  Pbag .
 eq extract(B, W, A, L) = $extract(B, nilP, W, A, L) .
 op $extract : Pbag Pbag String Set{Nat} Lab ->  Pbag .
 eq $extract(nilP, B, W, A, L) = B .
ceq $extract(K . p(L' < W ; I > L) + B, B', W, A, L) = $extract(B,
 B' + K . p(L' < W ; I > L) , W, A, L) if I in A . 
 eq $extract(K . P + B, B', W, A, L) = $extract(B, B' , W, A, L) [owise] .  
endfm 

mod PT-EMU is
 pr PT-NORM .
 var  T : Tmatrix .
 vars I O H M M' : Pbag .
 vars N N' : Net .
 var W : String .
 *** ordinary firing rule
 *** crl [firing] : N M => N M + O - I if [I,O,H] |-> W ; N' := N /\ enabled([I,O,H], M) .
 *** including PT-NORM
  crl [cfiring] : N M => N normalize(M + O - I) if [I,O,H] |-> W ; N' := N /\ enabled([I,O,H], M)  .
 *** includes a further optimization: if the marked places are retained then name abstraction is skipped
 ***crl [cfiring] : N M => N normalize(M', eqsupp(M, M')) if [I,O,H] |-> W ; N' := N /\ enabled([I,O,H], M) /\ M' := M + O - I  .
endm

fmod PT-FMS is
 protecting NET-OP .
 ops sline sload sass sfault faultysload faultysass :  -> Imatrix .
 ops line load ass fault faultyload faultyass : -> Tmatrix . 
 ops cycle PL faultycycle : -> Net .
 ops nomPL faultyPL : Nat -> Net . *** templates for a single PL
 op faultySys : Nat -> System . 
 ops NPL NfaultyPL : NzNat -> Net . *** N (faulty) prod lines 0 .. N- 1
 op NPLsys : NzNat NzNat -> System . *** N prod lines with 2 * M tokens (raw pieces)
 

 var I : Nat . 
 vars N M : NzNat .
 eq sline =  [1 . p(< "w" ; 0 >) , 1 . p(< "a" ; 0 >), 1 . p(< "f" ; 0 >) ] .
 eq line = sline |-> "l" .
 eq sfault =  [1 . p(< "o" ; 0 >) , 1 . p(< "f" ; 0 >), nilP ] .
 eq fault = sfault |-> "f" .
 eq sload = [1 . p(< "s" ; 0 >) , 1 . p(< "w" ; 0 >) , nilP ] .
 eq load = sload |-> "w" .
 eq sass =  [1 . p(< "a" ; 0 >) , 1 . p(< "s" ; 0 >)  , nilP ] .
 eq ass  = sass  |-> "a" .
 eq cycle = load ; line ; ass ; fault .
 eq PL = replica&share(cycle, 2, "L", p (< "o" ; 0 >) U p(< "s" ; 0 >), "a" U "w") . *** a PL is built of two symmetric lines 
 eq NPL(N) = replica&share(PL, N, "PL", p(< "s" ; 0 >), emptyStr) .
 eq NPLsys(N, M) = setMark(setMark(NPL(N), "o" "PL", 1), "s", 2 * M) .
 *** helpful in system rewrite
*** the i-th nominal PL
 eq nomPL(I) = addLab(PL, < "PL" ; I >, p(< "s" ; 0 >)) .
 *** the i-th faulty PL working with one line
 eq faultysload =  [2 . p(< "s" ; 0 >) , 2 . p(< "w" ; 0 >) , nilP ] .
 eq faultysass  =  [2 . p(< "a" ; 0 >) , 2 . p(< "s" ; 0 >)  , nilP ] .
 eq faultyload = faultysload |-> "w" . 
 eq faultyass  = faultysass  |-> "a" .
 eq faultycycle = faultyload ; line ; faultyass ; fault .
 eq faultyPL(I) = addLab(faultycycle, < "fPL" ; I >, "s") . *** a faulty PL is built of 1 line
 eq faultySys(I) = setMark(faultyPL(I), "o" "fPL", 1) .
 ***
 eq NfaultyPL(N) = replica&share(faultycycle, N, "fPL", p(< "s" ; 0 >), emptyStr) .
 
endfm

mod RWPT-FMS is
 pr  PT-FMS .
 inc PT-EMU .
 vars N N' N'' : Net .
 vars Tload Tfail Tfail1 Tfail2 Tass Tline Tline1 Tline2  : String .
 vars P0 P1 P2 P3 P4 P5 P6 P7 : Place .
 vars S S' : Pbag .
 var K : NzNat .
 vars I Imin : Nat .
 var W : String .
 vars L L0 L1 L2 L3 L4 L5 L6 L7 : Lab .
 var Sys : System .

*** the rule syr1 replaces a nominal PL with a faulty one: is correct (symmetric) but doesn't match the normalization requirements
***crl [syr1] : N S + 1 . P7 => ( N' ; [2 . P1, 2 . P2, nilP] |-> Tload ;  [2 . P4, 2 . P1, nilP] |-> Tass  ) set(S, P3, 0) + S[P3] . P2 + 1 . P0 
***       if (N' ; [2 . P1, 1 . P2 + 1 . P3, nilP ] |-> Tload  ; [1 . P3, 1 . P5, 1 . P7] |-> Tline2 ; [1 . P4 + 1 . P5, 2 . P1, nilP ] |-> Tass  ;[1 . P0, 1 . P7, nilP] |-> Tfail2 ) := N /\ dead(N S + 1 . P7)  .
*** alternative rule coherent with normalization, but higly inefficient
 *** crl [nor1] : N  S + 1 . p(< "f" ; 0 > L < "PL" ; I >) => normalize(join(detache(N, nomPL(I))  S - S', setMark(setMark(faultySys(minnotin(N, "fPL")), "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |)))
 ***      if dead (N S + 1 . p(< "f" ; 0 > L < "PL" ; I >)) /\  S' := subag(S, < "PL" ; I >) .
 *** optimized version of nor1 exploiting the fact that the faulty PL do not need abstraction
crl [nor1] : N  S + 1 . p(< "f" ; 0 > L < "PL" ; I >) => normalize(join(detache(N, nomPL(I))  S - S', setMark(setMark(faultySys(minnotin(N, "fPL")), "w" "fPL", | match(S', "w") |), "a" "fPL", | match(S', "a") |)),"fPL")
     if dead (N S + 1 . p(< "f" ; 0 > L < "PL" ; I >)) /\  S' := subag(S, < "PL" ; I >) .
 
*** syr2 removes a faulty PL after a 2nd fault occurrence (analogous considerations to syr1)
***crl [syr2] : N  S + 1 . P6  => N' (set(set(S, P1, S[P1] + S[P2] + S[P4]), P2, 0)) - 1 . P4 if (N' ; [1 . P0, 1 . P6, nilP] |-> Tfail1 ; [2 . P1, 2 . P2, nilP] |-> Tload  ; [1 . P2, 1 . P4, 1 . P6] |-> Tline1 ; [2 . P4, 2 . P1, nilP ] |-> Tass ) := N  /\ N' =/= emptyN /\
***  dead(([2 . P1, 2 . P2, nilP] |-> Tload ; [2 . P4, 2 . P1, nilP ] |-> Tass) S) .

*** version coherent with normalization
crl [nor2] : N  S + 1 . p(< "f" ; 0 > L < "fPL" ; I >) => normalize(N'' set(S - S', p(< "s" ; 0 >), S[p(< "s" ; 0 >)] + | S' |))  if 
   N' := faultyPL(I) /\ N'' := detache(N, N') /\ N'' =/= emptyN /\
   dead(N' S + 1 . p(< "f" ; 0 > L < "fPL" ; I >)) /\ S' := subag(S, < "fPL" ; I >) .

endm
